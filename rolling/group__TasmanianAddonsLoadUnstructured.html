<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: Load from Unstructured Point Set</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TasmanianAddonsLoadUnstructured.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Load from Unstructured Point Set<div class="ingroups"><a class="el" href="group__TasmanianAddons.html">Additional Capabilities</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Load from Unstructured Point Set:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianAddonsLoadUnstructured.png" border="0" usemap="#agroup____TasmanianAddonsLoadUnstructured" alt=""/></div>
<map name="agroup____TasmanianAddonsLoadUnstructured" id="agroup____TasmanianAddonsLoadUnstructured">
<area shape="rect" href="group__TasmanianAddons.html" title=" " alt="" coords="5,13,156,38"/>
<area shape="rect" title=" " alt="" coords="204,5,363,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabe0495b6cefaafd2df73884ddd4f406e" id="r_gabe0495b6cefaafd2df73884ddd4f406e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#gabe0495b6cefaafd2df73884ddd4f406e">TasGrid::hasGPUBasis</a> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;grid)</td></tr>
<tr class="memdesc:gabe0495b6cefaafd2df73884ddd4f406e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the grid has a GPU algorithm for computing the hierarchical basis.  <br /></td></tr>
<tr class="separator:gabe0495b6cefaafd2df73884ddd4f406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0005385aef9c60db6f3aef3128d20acf" id="r_ga0005385aef9c60db6f3aef3128d20acf"><td class="memTemplParams" colspan="2">template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:ga0005385aef9c60db6f3aef3128d20acf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#ga0005385aef9c60db6f3aef3128d20acf">TasGrid::generateCoefficientsGPU</a> (double const data_points[], int num_data, scalar_type model_values[], double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:ga0005385aef9c60db6f3aef3128d20acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the coefficients and solves the least-squares problem.  <br /></td></tr>
<tr class="separator:ga0005385aef9c60db6f3aef3128d20acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f54cda879b13547eb8bafe9454a4d0e" id="r_ga8f54cda879b13547eb8bafe9454a4d0e"><td class="memTemplParams" colspan="2">template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:ga8f54cda879b13547eb8bafe9454a4d0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#ga8f54cda879b13547eb8bafe9454a4d0e">TasGrid::generateCoefficients</a> (double const data_points[], int num_data, double const model_values[], double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:ga8f54cda879b13547eb8bafe9454a4d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the coefficients and solves the least-squares problem.  <br /></td></tr>
<tr class="separator:ga8f54cda879b13547eb8bafe9454a4d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478a4f8551e93cb64540567b50e03a02" id="r_ga478a4f8551e93cb64540567b50e03a02"><td class="memTemplParams" colspan="2">template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:ga478a4f8551e93cb64540567b50e03a02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#ga478a4f8551e93cb64540567b50e03a02">TasGrid::loadUnstructuredDataL2tmpl</a> (double const data_points[], int num_data, double const model_values[], double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:ga478a4f8551e93cb64540567b50e03a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template implementation that handles the case of Fourier grids vs. all other types.  <br /></td></tr>
<tr class="separator:ga478a4f8551e93cb64540567b50e03a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cc3abfc7b72c6258932ea149f11adf" id="r_gaf6cc3abfc7b72c6258932ea149f11adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#gaf6cc3abfc7b72c6258932ea149f11adf">TasGrid::loadUnstructuredDataL2</a> (double const data_points[], int num_data, double const model_values[], double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:gaf6cc3abfc7b72c6258932ea149f11adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate using a least-squares fit.  <br /></td></tr>
<tr class="separator:gaf6cc3abfc7b72c6258932ea149f11adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103f434b565f3f81a7d750d9fc57a1eb" id="r_ga103f434b565f3f81a7d750d9fc57a1eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#ga103f434b565f3f81a7d750d9fc57a1eb">TasGrid::loadUnstructuredDataL2</a> (std::vector&lt; double &gt; const &amp;data_points, std::vector&lt; double &gt; const &amp;model_values, double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:ga103f434b565f3f81a7d750d9fc57a1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that used vectors and infers the number of data points from the size of the vectors.  <br /></td></tr>
<tr class="separator:ga103f434b565f3f81a7d750d9fc57a1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Templates that infer sparse grid coefficients from a set of unstructured points and model values. These work very similar to <a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad49a95d0766243ba2d5d1a8f10dedb15" title="Alias to loadNeededValues(), array variant.">TasGrid::loadNeededPoints()</a>, but the data is not assumed to align to the sparse grid. While removing some of the restrictions, the unstructured approach always requires more data to achieve the same level of accuracy compared to the carefully chosen points, and the approximation is valid only in the convex hull of the data, i.e., extrapolating outside of the data-cloud is not mathematically stable. In the interior of the data-cloud, the accuracy of the surrogate is very sensitive to the distribution of the points and good accuracy can be achieved only in areas where the points are sufficiently dense.</p>
<p>The inference usually relies on solving some linear or non-linear problem which may not be stable and may require additional regularization, especially if the data is not sufficient to provide values for all hierarchical coefficients, e.g., all data falls outside of the support of some locally supported basis functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabe0495b6cefaafd2df73884ddd4f406e" name="gabe0495b6cefaafd2df73884ddd4f406e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe0495b6cefaafd2df73884ddd4f406e">&#9670;&#160;</a></span>hasGPUBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TasGrid::hasGPUBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the grid has a GPU algorithm for computing the hierarchical basis. </p>

</div>
</div>
<a id="ga0005385aef9c60db6f3aef3128d20acf" name="ga0005385aef9c60db6f3aef3128d20acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0005385aef9c60db6f3aef3128d20acf">&#9670;&#160;</a></span>generateCoefficientsGPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::generateCoefficientsGPU </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>data_points</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_type&#160;</td>
          <td class="paramname"><em>model_values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the coefficients and solves the least-squares problem. </p>
<p>The template assumes that the arrays are allocated on the GPU device and the <b>model_values</b> are set to the correct size that would include padding needed for the regularization (note that the padded may not be initialized). The basis matrix will be constructed on the GPU and must fit in memory. </p>

</div>
</div>
<a id="ga8f54cda879b13547eb8bafe9454a4d0e" name="ga8f54cda879b13547eb8bafe9454a4d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f54cda879b13547eb8bafe9454a4d0e">&#9670;&#160;</a></span>generateCoefficients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; scalar_type &gt; TasGrid::generateCoefficients </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>data_points</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>model_values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the coefficients and solves the least-squares problem. </p>
<p>The template assumes that the arrays are allocated on the CPU. The basis matrix is build on the CPU, unless MAGMA acceleration is enabled; in the magma case, the matrix will be build on the GPU by using several rows at a time as to avoid overfilling the GPU memory (out-of-core). </p>

</div>
</div>
<a id="ga478a4f8551e93cb64540567b50e03a02" name="ga478a4f8551e93cb64540567b50e03a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga478a4f8551e93cb64540567b50e03a02">&#9670;&#160;</a></span>loadUnstructuredDataL2tmpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::loadUnstructuredDataL2tmpl </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>data_points</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>model_values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template implementation that handles the case of Fourier grids vs. all other types. </p>
<p>Fourier grids require complex arithmetic while the other grid works with real types. This template operates on the double or std::complex&lt;double&gt; specified by <b>scalar_type</b>. </p>

</div>
</div>
<a id="gaf6cc3abfc7b72c6258932ea149f11adf" name="gaf6cc3abfc7b72c6258932ea149f11adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6cc3abfc7b72c6258932ea149f11adf">&#9670;&#160;</a></span>loadUnstructuredDataL2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::loadUnstructuredDataL2 </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>data_points</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>model_values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a sparse grid surrogate using a least-squares fit. </p>
<p>Constructs the coefficients of the grid using a least-squares fit <picture><source srcset="form_59_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \min_c \| G_c(x) - Y \|_2 $" src="form_59.png" width="145" height="19"/></picture>, where <b>c</b> indicates the hierarchical coefficients of the grid, <b>x</b> indicates the data-points and <b>Y</b> is the associated model outputs. The problem is set as a linear system of equations so that <picture><source srcset="form_60_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ G_c(x) = H c $" src="form_60.png" width="91" height="19"/></picture> where <b>H</b> is the matrix of hierarchical coefficients. Depending on the distribution of the points and/or the type of grid, the system may not be well posed, hence the simple regularization option to add <b>tolerance</b> multiplied by the norm of <b>c</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_points</td><td>array of data points similar to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afa1f2b9ae8a96023bbf529a78173daee" title="Add pairs of points with associated model values.">TasmanianSparseGrid::loadConstructedPoints()</a> with size grid.getNumDimensions() by <b>num_data</b> </td></tr>
    <tr><td class="paramname">num_data</td><td>the number of data points </td></tr>
    <tr><td class="paramname">model_values</td><td>array of model values corresponding to the <b>data_points</b>, the size is grid.getNumOutputs() by <b>num_data</b> </td></tr>
    <tr><td class="paramname">tolerance</td><td>if positive, will add regularization to the least-squares problem, must be less than the accuracy of the surrogate so that it will not affect the approximation error; if set to zero or less, no regularization will be used but depending on the type of grid and the distribution of the points, the problem may not be well posed </td></tr>
    <tr><td class="paramname">grid</td><td>is a non-empty grid, if a refinement has been set, it will be merged with the existing points before inference</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is empty or <b>accel_none</b> is used </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>on various cuda errors, e.g., not enough GPU memory, or if the matrix <b>G_c</b> does not have a full column rank, e.g., regularization tolerance is <b>0</b> and the data is not sufficient to provide coefficients for all basis functions</td></tr>
  </table>
  </dd>
</dl>
<p>The problem requires the QR factorization of <b>G_c</b> and the solution against multiple right hand sides corresponding to the model outputs. This is computationally very expensive and cannot be done without an appropriate acceleration mode:</p><ul>
<li><b>accel_cpu_blas</b> will perform all operations on the CPU using OpenMP and the BLAS and LAPACK implementations, OpenMP is optional but recommended</li>
<li><b>accel_gpu_cublas</b> will form <b>G_c</b> on the CPU, but then the matrix will be moved to the GPU device and will perform the solver stage using cuBlas and cuSolverDn</li>
<li><b>accel_gpu_cuda</b> will form <b>G_c</b> on the GPU and perform the solve using cuBlas and cuSolverDn, if the there is no GPU algorithm for the corresponding <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab521b88c5efcfe07a6630623f5aa1fdf" title="Computes the values of the hierarchical function basis at the specified points (CUDA version).">TasmanianSparseGrid::evaluateHierarchicalFunctionsGPU()</a> then the CPU will be used identical to the cublas mode</li>
<li><b>accel_gpu_magma</b> will form <b>G_c</b> on the GPU device, but will do so in batches as to limit the GPU memory used at a given time, then the linear algebra will be performed using the MAGMA out-of-core methods</li>
</ul>
<p>The cuda and cublas modes, require that the data and the associated matrices fit in the memory of the GPU device, MAGMA does not have that restriction. </p>

</div>
</div>
<a id="ga103f434b565f3f81a7d750d9fc57a1eb" name="ga103f434b565f3f81a7d750d9fc57a1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga103f434b565f3f81a7d750d9fc57a1eb">&#9670;&#160;</a></span>loadUnstructuredDataL2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::loadUnstructuredDataL2 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>data_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>model_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that used vectors and infers the number of data points from the size of the vectors. </p>
<p>See <a class="el" href="group__TasmanianAddonsLoadUnstructured.html#gaf6cc3abfc7b72c6258932ea149f11adf" title="Construct a sparse grid surrogate using a least-squares fit.">TasGrid::loadUnstructuredDataL2()</a> for details, in addition</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the sizes of the <b>data_points</b> and <b>model_values</b> do not match </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
