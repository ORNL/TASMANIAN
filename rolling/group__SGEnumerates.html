<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2 (development): Enumerated types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.1
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2 (development)
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__SGEnumerates.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Enumerated types<div class="ingroups"><a class="el" href="group__TasmanianSG.html">Sparse Grids</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Enumerated types:</div>
<div class="dyncontent">
<div class="center"><img src="group__SGEnumerates.png" border="0" usemap="#agroup____SGEnumerates" alt=""/></div>
<map name="agroup____SGEnumerates" id="agroup____SGEnumerates">
<area shape="rect" title=" " alt="" coords="152,5,280,31"/>
<area shape="rect" href="group__TasmanianSG.html" title=" " alt="" coords="5,5,104,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3fb5157c08df3be790274a1fd4797b03"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga3fb5157c08df3be790274a1fd4797b03">TasGrid::TypeIndexRelation</a> { <a class="el" href="group__SGEnumerates.html#gga3fb5157c08df3be790274a1fd4797b03a3eb44e742249543476989540b62af5a3">TasGrid::type_abeforeb</a>
, <a class="el" href="group__SGEnumerates.html#gga3fb5157c08df3be790274a1fd4797b03a965f57668df761cbb1d607e6a47704de">TasGrid::type_bbeforea</a>
, <a class="el" href="group__SGEnumerates.html#gga3fb5157c08df3be790274a1fd4797b03a5dc486f1ab0a095e77e6a85e78734666">TasGrid::type_asameb</a>
 }</td></tr>
<tr class="memdesc:ga3fb5157c08df3be790274a1fd4797b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the relation between two multi-indexes when compared during sorting.  <a href="group__SGEnumerates.html#ga3fb5157c08df3be790274a1fd4797b03">More...</a><br /></td></tr>
<tr class="separator:ga3fb5157c08df3be790274a1fd4797b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94134756077eff395566c64e6426455f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TasGrid::TypeDepth</a> { <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa72fded97960f7e090b1403ed2d01b790">TasGrid::type_none</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa6feeea3001da5a72dcf3602b9e3cfb0c">TasGrid::type_level</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa069fe8d0a40c574481e4789b9669fb04">TasGrid::type_curved</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa8dcb7523e6a608823c0afd448ac2e21e">TasGrid::type_hyperbolic</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">TasGrid::type_iptotal</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa383f228695e32d25b6b4d298b5ee55c8">TasGrid::type_qptotal</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455faf73c4f175fa56147e2ce42c169f450e1">TasGrid::type_ipcurved</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa66ffa652c94f7b1949380972395294e0">TasGrid::type_qpcurved</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455faabd7440eb86c1ae28dfda4dacf4479a1">TasGrid::type_iphyperbolic</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa6ffee71d521ab15a983c92cad37060ee">TasGrid::type_qphyperbolic</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fadb7975fabba0d6f63b7d00509e596123">TasGrid::type_tensor</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa215db093a13c1a5e2768d277dddd5778">TasGrid::type_iptensor</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa830de3e55afd3399509d5edf7e3a60a6">TasGrid::type_qptensor</a>
<br />
 }</td></tr>
<tr class="memdesc:ga94134756077eff395566c64e6426455f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by Global Sequence and Fourier grids, indicates the selection criteria.  <a href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">More...</a><br /></td></tr>
<tr class="separator:ga94134756077eff395566c64e6426455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga145e27d5ae92acdd5f74149c6d4f2ca2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TasGrid::TypeOneDRule</a> { <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aafe5a9e98c5e60a1cf580e61e54f22db">TasGrid::rule_none</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a7979fed9357e95bf01dc3169051f9fcf">TasGrid::rule_clenshawcurtis</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aaf84ed914bf71f1bd57a1888d4abd00a">TasGrid::rule_clenshawcurtis0</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a11001d1417caa84b4946aa042e78d953">TasGrid::rule_fejer2</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab0538d89ae16fccbbd0c546d6148f913">TasGrid::rule_chebyshev</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a2cf9d51120ca7132669f100fc19f4cad">TasGrid::rule_chebyshevodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">TasGrid::rule_leja</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ad21417c53c20d8c7ed2781c7d778d626">TasGrid::rule_lejaodd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67">TasGrid::rule_rleja</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2add4c0da371b3328de2b5aa9c0d78f356">TasGrid::rule_rlejadouble2</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2abaf13f719d258617bd1db267f7d81090">TasGrid::rule_rlejadouble4</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ad9eb31cd2ddc3a5b807db9f4946cbe99">TasGrid::rule_rlejaodd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab25addae4849761fabd0648c409e4fe0">TasGrid::rule_rlejashifted</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ade9f8d67ad4ee3a10694746daae35a4e">TasGrid::rule_rlejashiftedeven</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1993c6374109c34a09aaabb151b45a30">TasGrid::rule_rlejashifteddouble</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aae014e63a109512fecddb1a0b1a6443f">TasGrid::rule_maxlebesgue</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aad90e60b60d10ece133d91672c2a6d40">TasGrid::rule_maxlebesgueodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a013fec186e156860f5c89b56c18be6ca">TasGrid::rule_minlebesgue</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a333f195780c87bff6573f432c6fc2f39">TasGrid::rule_minlebesgueodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4f62c63dee6ab4c61c62ea4b179bb92c">TasGrid::rule_mindelta</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab956a3457075ae3dac6a1b55e9f82b9b">TasGrid::rule_mindeltaodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a0ffdbf062c3c6e6f546b99719c153813">TasGrid::rule_gausslegendre</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a40ba886acb7924987021756e388864b6">TasGrid::rule_gausslegendreodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae0ddcd23738e332619bc84102647c14c">TasGrid::rule_gausspatterson</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a474a0012b25fb9615d91201eb9c3d813">TasGrid::rule_gausschebyshev1</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab065e2757800e8faf5f8104cc59b88ee">TasGrid::rule_gausschebyshev1odd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab36508ddee56313531d08a0b2f875361">TasGrid::rule_gausschebyshev2</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a88b316c918d22ef5ea9d2eead1b445c3">TasGrid::rule_gausschebyshev2odd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a016bbf5f9c46bedb8a2957a88c1affc2">TasGrid::rule_gaussgegenbauer</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a655191cb6dcb11ec04e417a3e95c81d6">TasGrid::rule_gaussgegenbauerodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae857a1ff20402a00c130cbb119f030aa">TasGrid::rule_gaussjacobi</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2acb6535ae2d81e83d1163087da86e6357">TasGrid::rule_gaussjacobiodd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4a9504cb0e82ac9edf4b010303cd7a64">TasGrid::rule_gausslaguerre</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1b0686c22526434ed94fceb92c125ac5">TasGrid::rule_gausslaguerreodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a043726272ee899f7ef10961e90698c3c">TasGrid::rule_gausshermite</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a775cee952a979f569572d2bfa3ec3ecc">TasGrid::rule_gausshermiteodd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a7597d0c89be786bb966355bc34b4e0f0">TasGrid::rule_customtabulated</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f">TasGrid::rule_localp</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab53ef82abdf78847f8422f0a17d7c28d">TasGrid::rule_localp0</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae337b4afeab83445025e17c5b5c50a4a">TasGrid::rule_semilocalp</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a6ca48da916fa34d52f234d007218d982">TasGrid::rule_localpb</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4abdeb519cfe0de36b03f1d75bb875a0">TasGrid::rule_wavelet</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab88eab2577ab9d7f1c0eae056ea012ae">TasGrid::rule_fourier</a>
<br />
 }</td></tr>
<tr class="memdesc:ga145e27d5ae92acdd5f74149c6d4f2ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify the one dimensional family of rules that induces the sparse grid.  <a href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">More...</a><br /></td></tr>
<tr class="separator:ga145e27d5ae92acdd5f74149c6d4f2ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac709fc494353223f300235750f8b96ed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TasGrid::TypeRefinement</a> { <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd">TasGrid::refine_classic</a>
, <a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda004bf7a9a0d0e7ed8aadba8062c653f4">TasGrid::refine_parents_first</a>
, <a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda8528073ff3d46cee384d8b4fa2db72ed">TasGrid::refine_direction_selective</a>
, <a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda939fdaecc186a219034e156eb8ace917">TasGrid::refine_fds</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96edac00c2b6dda342ab4e3c7b22bcca3755a">TasGrid::refine_stable</a>
, <a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda9df1c5dae76a52a2993bed6a84f4e2bc">TasGrid::refine_none</a>
<br />
 }</td></tr>
<tr class="memdesc:gac709fc494353223f300235750f8b96ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement strategy for local polynomial and wavelet grids.  <a href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">More...</a><br /></td></tr>
<tr class="separator:gac709fc494353223f300235750f8b96ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344ee5be5b77f2ff8e7c98f97ab40581"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TasGrid::TypeAcceleration</a> { <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766">TasGrid::accel_none</a>
, <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a4e99f4378b49ba22efd866d1eff3e689">TasGrid::accel_cpu_blas</a>
, <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a52e9ac2d8d5cb478c18e8f91e3ebaf7e">TasGrid::accel_gpu_default</a>
, <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581abff34d0602911ef3a29a952b793413d3">TasGrid::accel_gpu_cublas</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622">TasGrid::accel_gpu_cuda</a>
, <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581aac3a98fcec9c100e5422a7cd89e37269">TasGrid::accel_gpu_magma</a>
<br />
 }</td></tr>
<tr class="memdesc:ga344ee5be5b77f2ff8e7c98f97ab40581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modes of acceleration.  <a href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">More...</a><br /></td></tr>
<tr class="separator:ga344ee5be5b77f2ff8e7c98f97ab40581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2cf8d40703b53868f4bfa0ad89fe3e30"><td class="memItemLeft" align="right" valign="top"><a id="ga2cf8d40703b53868f4bfa0ad89fe3e30"></a>
constexpr <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga2cf8d40703b53868f4bfa0ad89fe3e30">TasGrid::accel_gpu_hip</a> = <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622">accel_gpu_cuda</a></td></tr>
<tr class="memdesc:ga2cf8d40703b53868f4bfa0ad89fe3e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">At the front API, the HIP and CUDA options are equivalent, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a>. <br /></td></tr>
<tr class="separator:ga2cf8d40703b53868f4bfa0ad89fe3e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1505678eb06b0396c979ac4b77d82857"><td class="memItemLeft" align="right" valign="top"><a id="ga1505678eb06b0396c979ac4b77d82857"></a>
constexpr <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga1505678eb06b0396c979ac4b77d82857">TasGrid::accel_gpu_rocblas</a> = <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581abff34d0602911ef3a29a952b793413d3">accel_gpu_cublas</a></td></tr>
<tr class="memdesc:ga1505678eb06b0396c979ac4b77d82857"><td class="mdescLeft">&#160;</td><td class="mdescRight">At the front API, the HIP and CUDA options are equivalent, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a>. <br /></td></tr>
<tr class="separator:ga1505678eb06b0396c979ac4b77d82857"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Enumerated types</dt><dd>Enumerations are used as input to many Tasmanian functions in both internal and external API. </dd></dl>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3fb5157c08df3be790274a1fd4797b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fb5157c08df3be790274a1fd4797b03">&#9670;&nbsp;</a></span>TypeIndexRelation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SGEnumerates.html#ga3fb5157c08df3be790274a1fd4797b03">TasGrid::TypeIndexRelation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the relation between two multi-indexes when compared during sorting. </p>
<p>The standard C++11 algorithms std::merge and std::binary_search use bools as return types when comparing entries, thus in the case of many repeated entries, two comparisons have to be performed. Repeated entries are encountered in many sparse grids algorithms, especially when dealing with nested one dimensional rules. Thus, for performance reasons, Tasmanian implements merging and searching methods that compare multi-indexes and produce three outcomes in a single comparison.</p>
<p>Specifically, see <b>SetManipulations::push_merge_map()</b> and <b><a class="el" href="classTasGrid_1_1MultiIndexSet.html#a4bc8f56de5f5b5b800d9f2763dff164a" title="Returns the slot containing index p, returns -1 if not found.">MultiIndexSet::getSlot()</a></b> and <b>MultiIndexSet::addSortedInsexes()</b> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3fb5157c08df3be790274a1fd4797b03a3eb44e742249543476989540b62af5a3"></a>type_abeforeb&#160;</td><td class="fielddoc"><p>Indicates that the first multi-index in the call to compare comes before the second. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3fb5157c08df3be790274a1fd4797b03a965f57668df761cbb1d607e6a47704de"></a>type_bbeforea&#160;</td><td class="fielddoc"><p>Indicates that the second multi-index in the call to compare after the second. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3fb5157c08df3be790274a1fd4797b03a5dc486f1ab0a095e77e6a85e78734666"></a>type_asameb&#160;</td><td class="fielddoc"><p>Indicates that the two multi-indexes are the same. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga94134756077eff395566c64e6426455f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94134756077eff395566c64e6426455f">&#9670;&nbsp;</a></span>TypeDepth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TasGrid::TypeDepth</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used by Global Sequence and Fourier grids, indicates the selection criteria. </p>
<dl class="section user"><dt>Approximation Error</dt><dd>The approximation error when interpolating or integrating a target model with a <b>Global</b> sparse grid, is bound by a constant multiplied by the best approximation of the model in the set of polynomial exactness. The exactness set consists of all polynomials that can be <em>captured</em> exactly (approximated to round-off error) by the sparse grid. The constant is the norm of the sparse grid operator (a.k.a., the Lebesgue constant) and the exactness set is the range.</dd></dl>
<dl class="section user"><dt></dt><dd>The operator norm depends primarily on the underlying one dimensional rule used to construct the grid, and all rules implemented in Tasmanian have reasonable norms. Of primary focus is the target model and constructing a grid with range suitable for either integrating or interpolating the model.</dd></dl>
<dl class="section user"><dt>Categories</dt><dd>The types of <b>Global</b> grids fall into four categories:<ul>
<li><b>Level</b> selection uses the order of the one dimensional rules as criteria and pays no regard to the polynomial exactness. <b>Level</b> types are strongly influenced by the growth of points in the one dimensional rule and are seldom optimal, although such grid can be a good initial guess for an iterative refinement process.</li>
<li><b>Total</b> degree polynomial space is good for smooth models, i.e., analytic functions with convergent Taylor series for every point in the domain.</li>
<li><b>Curved</b> polynomial space is essentially a <b>Total</b> degree space with an added logarithmic correction term. The correction can account for rules with slightly higher norm growth (e.g., R-Leja rules) or for models with heavily constrained region of analytic extension, i.e., slightly less smooth.</li>
<li><b>Hyperbolic</b> cross section space is suitable for models with more irregular behavior, e.g., models with only a finite number of derivatives.</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The four main types can be tuned for either interpolation or quadrature (integration); the corresponding enumerate will have either <b>i</b> or <b>q</b> in the name. In all cases, Tasmanian will construct the grid with minimum number of points (or fewest basis functions), that will <em>capture</em> the corresponding polynomial space.</dd></dl>
<dl class="section user"><dt>Anisotropic Weights</dt><dd>All types can be combined with anisotropic weights that adjust the density of the grid in different directions. Below, we denote the anisotropic weights with <img class="formulaInl" alt="$ \xi_1, \xi_2, \cdots, \xi_d $" src="form_1.png" width="95" height="18"/> and <img class="formulaInl" alt="$ \eta_1, \eta_2, \cdots, \eta_d $" src="form_2.png" width="98" height="12"/>, where <img class="formulaInl" alt="$ d $" src="form_6.png" width="9" height="14"/> is the number of dimensions in the grid. Note that only curved types use the <img class="formulaInl" alt="$ \eta $" src="form_7.png" width="11" height="12"/> weights.</dd></dl>
<dl class="section user"><dt></dt><dd>The <b>TypeDepth</b> also uses the <b>depth</b> parameter to define a cut-off point, the <b>depth</b> is normalized by multiplying it by the smallest of the <img class="formulaInl" alt="$ \xi $" src="form_8.png" width="11" height="18"/> weights. In the formulas below, <b>L</b> stands for the normalized offset.</dd></dl>
<p>Details regarding sparse grids construction and polynomial spaces can be found in<br  />
M. Stoyanov, C. G. Webster, <a href="https://arxiv.org/pdf/1508.01125.pdf" style="font-weight:bold">A Dynamically Adaptive Sparse Grid Method for Quasi-Optimal Interpolation of Multidimensional Analytic Functions</a>, arXiv:1508.01125.<br  />
also published in <a href="https://www.sciencedirect.com/science/article/pii/S0898122116000031" style="font-weight:bold">Computers and Mathematics with Applications 71 (2016) 2449–2465.</a></p>
<dl class="section user"><dt>Full Tensor Types</dt><dd>Finally, in addition to the aforementioned types, Tasmanian includes the types for dense tensor grids. Only in 2-dimensions Gauss quadrature rules with full tensors are more efficient than a general sparse grid. Performing interpolation or working with more than 2 dimensions, sparse grids will always result in better approximation error per number of nodes, i.e., model evaluations; nevertheless, dense tensor grids naturally fall in the framework and can be useful for testing purposes.</dd></dl>
<dl class="section user"><dt>Fourier Grids</dt><dd>The Fourier grids are very similar to Global grids, with the exception that polynomial powers are replaced by frequencies of trigonometric functions. The different selection strategies can be used with frequency exactness in place of polynomial power.</dd></dl>
<p>The structure of the Fourier spaces, the convergence estimates, and the refinement strategies are described in<br  />
Z. Morrow, M. Stoyanov, <a href="https://arxiv.org/abs/1908.10672" style="font-weight:bold">A Method for Dimensionally Adaptive Sparse Trigonometric Interpolation of Periodic Functions</a>, arXiv:1908.10672. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa72fded97960f7e090b1403ed2d01b790"></a>type_none&#160;</td><td class="fielddoc"><p>Null type, should <b>never</b> be used for input, indicates an error of some sort. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa6feeea3001da5a72dcf3602b9e3cfb0c"></a>type_level&#160;</td><td class="fielddoc"><p>Ignoring the polynomial space, use rules with index <img class="formulaInl" alt="$ \left\{ (i_1, i_2, \cdots, i_d) : \sum_{k=1}^d \xi_k i_k \leq L \right\} $" src="form_15.png" width="252" height="33"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa069fe8d0a40c574481e4789b9669fb04"></a>type_curved&#160;</td><td class="fielddoc"><p>Ignoring the polynomial space, use rules with index <br  />
 <img class="formulaInl" alt="$ \left\{ (i_1, i_2, \cdots, i_d) : \sum_{k=1}^d \xi_k i_k + \sum_{k=1}^d \eta_k \log(i_k + 1) \leq L \right\} $" src="form_16.png" width="422" height="33"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa8dcb7523e6a608823c0afd448ac2e21e"></a>type_hyperbolic&#160;</td><td class="fielddoc"><p>Ignoring the polynomial space, use rules with index <img class="formulaInl" alt="$ \left\{ (i_1, i_2, \cdots, i_d) : \prod_{k=1}^d (i_k + 1)^{\xi_k} \leq L \right\} $" src="form_17.png" width="289" height="33"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431"></a>type_iptotal&#160;</td><td class="fielddoc"><p>Total degree polynomial space for interpolation, i.e., the span of <br  />
 <img class="formulaInl" alt="$ \left\{ \prod_{k=1}^d x^{i_k} : \sum_{k=1}^d \xi_k i_k \leq L \right\} $" src="form_18.png" width="219" height="33"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa383f228695e32d25b6b4d298b5ee55c8"></a>type_qptotal&#160;</td><td class="fielddoc"><p>Total degree polynomial space for quadrature/integration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455faf73c4f175fa56147e2ce42c169f450e1"></a>type_ipcurved&#160;</td><td class="fielddoc"><p>Curved polynomial space for interpolation, i.e., the span of <br  />
 <img class="formulaInl" alt="$ \left\{ \prod_{k=1}^d x^{i_k} : \sum_{k=1}^d \xi_k i_k + \sum_{k=1}^d \eta_k \log(i_k + 1) \leq L \right\} $" src="form_19.png" width="389" height="33"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa66ffa652c94f7b1949380972395294e0"></a>type_qpcurved&#160;</td><td class="fielddoc"><p>Curved polynomial space for quadrature/integration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455faabd7440eb86c1ae28dfda4dacf4479a1"></a>type_iphyperbolic&#160;</td><td class="fielddoc"><p>Hyperbolic cross section polynomial space for interpolation, i.e., the span of <br  />
 <img class="formulaInl" alt="$ \left\{ \prod_{k=1}^d x^{i_k} : \prod_{k=1}^d (i_k + 1)^{\xi_k} \leq L \right\} $" src="form_20.png" width="256" height="33"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa6ffee71d521ab15a983c92cad37060ee"></a>type_qphyperbolic&#160;</td><td class="fielddoc"><p>Hyperbolic cross section polynomial space for quadrature/integration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fadb7975fabba0d6f63b7d00509e596123"></a>type_tensor&#160;</td><td class="fielddoc"><p>Make a dense tensor grid with rules indexed by <img class="formulaInl" alt="$ \xi_1, \xi_2, \cdots, \xi_d $" src="form_1.png" width="95" height="18"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa215db093a13c1a5e2768d277dddd5778"></a>type_iptensor&#160;</td><td class="fielddoc"><p>Make a dense tensor grid with interpolation range that includes <img class="formulaInl" alt="$ \left\{ \prod_{k=1}^d x^{i_k} : i_k \leq \xi_k \mbox{ for all } k \right\} $" src="form_21.png" width="226" height="33"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94134756077eff395566c64e6426455fa830de3e55afd3399509d5edf7e3a60a6"></a>type_qptensor&#160;</td><td class="fielddoc"><p>Make a dense tensor grid with quadrature/integration range that includes <img class="formulaInl" alt="$ \left\{ \prod_{k=1}^d x^{i_k} : i_k \leq \xi_k \mbox{ for all } k \right\} $" src="form_21.png" width="226" height="33"/>. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga145e27d5ae92acdd5f74149c6d4f2ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga145e27d5ae92acdd5f74149c6d4f2ca2">&#9670;&nbsp;</a></span>TypeOneDRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TasGrid::TypeOneDRule</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to specify the one dimensional family of rules that induces the sparse grid. </p>
<dl class="section user"><dt>One Dimensional Rules</dt><dd>A sparse grid is a superposition of tensors of one dimensional rules with varying precision in the different directions. In this context, a <b>TypeOneDRule</b> defines a family of one dimensional rules with corresponding abscissas (nodes), quadrature weights, and basis functions.</dd></dl>
<dl class="section user"><dt>Categories</dt><dd>The rules fall into 5 categories, corresponding to the 5 main classes of grids.<ul>
<li><b>Global</b> using Lagrange polynomials for interpolation and (sometimes) specialized quadrature weights.</li>
<li><b>Sequence</b> rules are a subset of the <b>Global</b> rules, <b>Sequence</b> rules are always nested and each level adds one node to the previous level.</li>
<li><b>Local</b> <b>Polynomial</b> rules use uniformly spaced nodes and polynomial basis with localized support.</li>
<li><b>Wavelet</b> and <b>Fourier</b> rules also use uniformly spaced nodes, but with wavelet and trigonometric basis functions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Special Quadrature</dt><dd>All rules can be used to approximate integrals of the form <img class="formulaInl" alt="$ \int_\Gamma f(x) \rho(x) dx $" src="form_9.png" width="105" height="23"/> where <img class="formulaInl" alt="$ \Gamma $" src="form_10.png" width="12" height="12"/> is the (transformed) domain and <img class="formulaInl" alt="$ f(x) $" src="form_11.png" width="33" height="19"/> is the model. The majority of rules assume that the weight is constant 1, but in some cases more exotic weights are used. Assume that constant weight 1 is used, unless otherwise specified.</dd></dl>
<dl class="section user"><dt>Domain Transformation</dt><dd>Most rules are defined on a canonical interval [-1, 1], which can be transformed to an arbitrary [a, b] with <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">TasmanianSparseGrid::setDomainTransform()</a></b>, so long as <b>a</b> is less than <b>b</b>. Fourier grids use canonical [0, 1] and can be similarly transformed to [a, b]. Gauss-Laguerre rule is set to <img class="formulaInl" alt="$ [0, \infty) $" src="form_12.png" width="44" height="19"/> transformed to <img class="formulaInl" alt="$ [a, \infty) $" src="form_13.png" width="44" height="19"/> with scale parameter <b>b</b> (see below). Gauss-Hermite is set to <img class="formulaInl" alt="$ (-\infty, \infty) $" src="form_14.png" width="68" height="19"/> with scale and shift parameters. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2aafe5a9e98c5e60a1cf580e61e54f22db"></a>rule_none&#160;</td><td class="fielddoc"><p>Null rule, should <b>never</b> be used as input (default rule for an empty grid). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a7979fed9357e95bf01dc3169051f9fcf"></a>rule_clenshawcurtis&#160;</td><td class="fielddoc"><p>Classic nested rule using Chebyshev nodes with very low Lebesgue constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2aaf84ed914bf71f1bd57a1888d4abd00a"></a>rule_clenshawcurtis0&#160;</td><td class="fielddoc"><p>Same as <b>rule_clenshawcurtis</b> but with modified basis that assumes the model is zero at the boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a11001d1417caa84b4946aa042e78d953"></a>rule_fejer2&#160;</td><td class="fielddoc"><p>Similar to <b>rule_clenshawcurtis</b> but with nodes strictly in the interior. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ab0538d89ae16fccbbd0c546d6148f913"></a>rule_chebyshev&#160;</td><td class="fielddoc"><p>Using Chebyshev nodes with very low Lebesgue constant and slow node growth, but non-nested. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a2cf9d51120ca7132669f100fc19f4cad"></a>rule_chebyshevodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_chebyshev</b> but using only odd levels, partially mitigates the non-nested issues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc"></a>rule_leja&#160;</td><td class="fielddoc"><p>Classic <b>sequence</b> rule, moderate Lebesgue constant growth (empirical result only). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ad21417c53c20d8c7ed2781c7d778d626"></a>rule_lejaodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_leja</b> but using only odd levels, quadrature is more stable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67"></a>rule_rleja&#160;</td><td class="fielddoc"><p>Classic <b>sequence</b> rule based on complex analysis, moderate Lebesgue constant growth (theoretically proven). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2add4c0da371b3328de2b5aa9c0d78f356"></a>rule_rlejadouble2&#160;</td><td class="fielddoc"><p>Using <b>rule_rleja</b> nodes but doubling the nodes every 2 levels, reduces the Lebesgue constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2abaf13f719d258617bd1db267f7d81090"></a>rule_rlejadouble4&#160;</td><td class="fielddoc"><p>Using <b>rule_rleja</b> nodes but doubling the nodes every 4 levels, reduces the Lebesgue constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ad9eb31cd2ddc3a5b807db9f4946cbe99"></a>rule_rlejaodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_rleja</b> but using only odd levels, quadrature is more stable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ab25addae4849761fabd0648c409e4fe0"></a>rule_rlejashifted&#160;</td><td class="fielddoc"><p>Similar <b>sequence</b> to <b>rule_rleja</b> but with nodes strictly in the interior. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ade9f8d67ad4ee3a10694746daae35a4e"></a>rule_rlejashiftedeven&#160;</td><td class="fielddoc"><p>Same as <b>rule_rlejashifted</b> but using only even levels, quadrature is more stable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a1993c6374109c34a09aaabb151b45a30"></a>rule_rlejashifteddouble&#160;</td><td class="fielddoc"><p>Same as <b>rule_rlejashifted</b> but doubling the number of nodes per level, which reduced the Lebesgue constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2aae014e63a109512fecddb1a0b1a6443f"></a>rule_maxlebesgue&#160;</td><td class="fielddoc"><p>A greedy <b>sequence</b> rule with nodes placed at the maximum of the Lebesgue function. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2aad90e60b60d10ece133d91672c2a6d40"></a>rule_maxlebesgueodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_maxlebesgue</b> but using only odd levels, quadrature is more stable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a013fec186e156860f5c89b56c18be6ca"></a>rule_minlebesgue&#160;</td><td class="fielddoc"><p>A greedy <b>sequence</b> rule with nodes added to minimize the Lebesgue constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a333f195780c87bff6573f432c6fc2f39"></a>rule_minlebesgueodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_minlebesgue</b> but using only odd levels, quadrature is more stable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a4f62c63dee6ab4c61c62ea4b179bb92c"></a>rule_mindelta&#160;</td><td class="fielddoc"><p>A greedy <b>sequence</b> rule with nodes added to minimize the norm of the surplus operator. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ab956a3457075ae3dac6a1b55e9f82b9b"></a>rule_mindeltaodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_mindelta</b> but using only odd levels, quadrature is more stable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a0ffdbf062c3c6e6f546b99719c153813"></a>rule_gausslegendre&#160;</td><td class="fielddoc"><p>Non-nested rule but optimized for integration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a40ba886acb7924987021756e388864b6"></a>rule_gausslegendreodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_gausslegendre</b> but using only odd levels, partially mitigates the non-nested issues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ae0ddcd23738e332619bc84102647c14c"></a>rule_gausspatterson&#160;</td><td class="fielddoc"><p>Nested rule that is optimized for integration, probably the best integration rule in more than 2 dimensions. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a474a0012b25fb9615d91201eb9c3d813"></a>rule_gausschebyshev1&#160;</td><td class="fielddoc"><p>Non-nested rule optimized for integral of the form <img class="formulaInl" alt="$ \int_{a}^{b} f(x) / \sqrt{(b - x)(x - a)} dx $" src="form_22.png" width="207" height="26"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ab065e2757800e8faf5f8104cc59b88ee"></a>rule_gausschebyshev1odd&#160;</td><td class="fielddoc"><p>Same as <b>rule_gausschebyshev1</b> but using only odd levels, partially mitigates the non-nested issues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ab36508ddee56313531d08a0b2f875361"></a>rule_gausschebyshev2&#160;</td><td class="fielddoc"><p>Non-nested rule optimized for integral of the form <img class="formulaInl" alt="$ \int_{a}^{b} f(x) \sqrt{(b - x)(x - a)} dx $" src="form_23.png" width="198" height="26"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a88b316c918d22ef5ea9d2eead1b445c3"></a>rule_gausschebyshev2odd&#160;</td><td class="fielddoc"><p>Same as <b>rule_gausschebyshev2</b> but using only odd levels, partially mitigates the non-nested issues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a016bbf5f9c46bedb8a2957a88c1affc2"></a>rule_gaussgegenbauer&#160;</td><td class="fielddoc"><p>Non-nested rule optimized for integral of the form <img class="formulaInl" alt="$ \int_{a}^{b} f(x) (b - x)^\alpha (x - a)^\alpha dx $" src="form_24.png" width="200" height="26"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a655191cb6dcb11ec04e417a3e95c81d6"></a>rule_gaussgegenbauerodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_gaussgegenbauer</b> but using only odd levels, partially mitigates the non-nested issues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ae857a1ff20402a00c130cbb119f030aa"></a>rule_gaussjacobi&#160;</td><td class="fielddoc"><p>Non-nested rule optimized for integral of the form <img class="formulaInl" alt="$ \int_{a}^{b} f(x) (b - x)^\alpha (x - a)^\beta dx $" src="form_25.png" width="200" height="26"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2acb6535ae2d81e83d1163087da86e6357"></a>rule_gaussjacobiodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_gaussjacobi</b> but using only odd levels, partially mitigates the non-nested issues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a4a9504cb0e82ac9edf4b010303cd7a64"></a>rule_gausslaguerre&#160;</td><td class="fielddoc"><p>Non-nested rule optimized for integral of the form <img class="formulaInl" alt="$ \int_{a}^{\infty} f(x) (x - a)^\alpha \exp \left(-b (x - a) \right) dx $" src="form_26.png" width="270" height="23"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a1b0686c22526434ed94fceb92c125ac5"></a>rule_gausslaguerreodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_gausslaguerre</b> but using only odd levels, partially mitigates the non-nested issues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a043726272ee899f7ef10961e90698c3c"></a>rule_gausshermite&#160;</td><td class="fielddoc"><p>Non-nested rule optimized for integral of the form <img class="formulaInl" alt="$ \int_{-\infty}^{\infty} f(x) (x - a)^\alpha \exp \left(-b (x - a)^2 \right) dx $" src="form_27.png" width="287" height="23"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a775cee952a979f569572d2bfa3ec3ecc"></a>rule_gausshermiteodd&#160;</td><td class="fielddoc"><p>Same as <b>rule_gausshermite</b> but using only odd levels, partially mitigates the non-nested issues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a7597d0c89be786bb966355bc34b4e0f0"></a>rule_customtabulated&#160;</td><td class="fielddoc"><p>User provided rule, nodes and weights must be provided with a separate file. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f"></a>rule_localp&#160;</td><td class="fielddoc"><p>Nested rule with a hierarchy of uniformly distributed nodes and functions with compact support. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ab53ef82abdf78847f8422f0a17d7c28d"></a>rule_localp0&#160;</td><td class="fielddoc"><p>Variation of <b>rule_localp</b> assuming the model is zero at the domain boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ae337b4afeab83445025e17c5b5c50a4a"></a>rule_semilocalp&#160;</td><td class="fielddoc"><p>Variation of <b>rule_localp</b> using increased support in exchange for higher order basis (better for smoother functions). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a6ca48da916fa34d52f234d007218d982"></a>rule_localpb&#160;</td><td class="fielddoc"><p>Variation of <b>rule_localp</b> focusing nodes on the boundary instead of the interior. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2a4abdeb519cfe0de36b03f1d75bb875a0"></a>rule_wavelet&#160;</td><td class="fielddoc"><p>Wavelet basis with uniformly distributed nodes (primarily for internal use). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga145e27d5ae92acdd5f74149c6d4f2ca2ab88eab2577ab9d7f1c0eae056ea012ae"></a>rule_fourier&#160;</td><td class="fielddoc"><p>Trigonometric basis with uniformly distributed nodes (primarily for internal use). </p>
</td></tr>
</table>

</div>
</div>
<a id="gac709fc494353223f300235750f8b96ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac709fc494353223f300235750f8b96ed">&#9670;&nbsp;</a></span>TypeRefinement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TasGrid::TypeRefinement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refinement strategy for local polynomial and wavelet grids. </p>
<dl class="section user"><dt>Local Hierarchical Approximation</dt><dd>The nodes and basis functions used in local polynomial and wavelet sparse grid form a complex multidimensional hierarchy, where each node is associated with one or more parents and children in each direction. In both cases, the support of the children is (almost always) smaller than the support of the patent and in the polynomial case, the support of the children nodes is strictly contained within the support of the parent.</dd></dl>
<dl class="section user"><dt></dt><dd>The interpolant is expressed as a linear combination of basis functions with coefficients computed so that the interpolant matches the model values at the sparse gird nodes. The coefficients are thus indicators of the local approximation error and (in the asymptotic limit) the coefficients decrease when going form a parent to a child.</dd></dl>
<dl class="section user"><dt>Convergence Criteria</dt><dd>Using the local error estimator, the sparse grid approximation has reached desired tolerance when all nodes with missing children have coefficients with absolute values smaller than the tolerance. This is a necessary and not a sufficient condition an is heavily reliant on the assumption of monotonic decay of the coefficients; however, in practical situations this is a good way to construct an adaptive grid that captures the behavior of the target model while minimizing the number of nodes.</dd></dl>
<dl class="section user"><dt>Adaptive Refinement</dt><dd>The idea of refinement is to start with a coarse spars grid and gradually add children of existing nodes, but only if the nodes have a large hierarchical coefficient. The nodes are added until the coefficients of all nodes with with missing children drop below user specified tolerance. The refinement types listed below differ in the way that the parents and children are selected in the adaptive construction, and whether local anisotropy is considered.</dd></dl>
<dl class="section user"><dt>Refinement Types</dt><dd>Each nodes is associated with multiple parents corresponding to different directions, even if each one dimensional node has only a single parent. Thus, over several iterations and if the hierarchical coefficients do not decay monotonically, it is possible to have nodes with missing parents for some directions, which can hinter convergence. Furthermore, the hierarchical coefficients do not carry any information regarding potential local anisotropy and a second refinement criteria can be employed, where an interpolant is constructed using only the data associated with the nodes that lay in a single direction. Children and/or parents of a node are added to the grid only when both the isotropic and anisotropic error indicators exceed the user specified tolerance.</dd></dl>
<dl class="section user"><dt></dt><dd>The <b>classic</b> refinement strategy adds only the children for the nodes with hierarchical coefficient that exceed the user provided tolerance (local anisotropy and missing parents are ignored). The <b>parents</b> <b>first</b> and <b>fds</b> strategies loop for missing parents and add the parents before adding children, which usually improves stability when compared to adding only children. The <b>direction</b> <b>selective</b> and <b>fds</b> strategies consider local anisotropy which can reduce the number of required model evaluations, but can also lead to decrease in stability. The <b>stable</b> refinement is both isotropic and maintains lower-complete structures, i.e., no point has a missing parent. While the most stable, the <b>stable</b> strategy can lead to significant oversampling.</dd></dl>
<p>Details regarding adaptive hierarchical sparse grids construction and children-parent relations can be found in: <br  />
M. Stoyanov, <a href="https://link.springer.com/chapter/10.1007/978-3-319-75426-0_8" style="font-weight:bold">Adaptive Sparse Grid Construction in a Context of Local Anisotropy and Multiple Hierarchical Parents</a>,<br  />
Sparse Grids and Applications - Miami 2016 pp 175-199.<br  />
Also in: <a href="https://info.ornl.gov/sites/publications/files/Pub45746.pdf" style="font-weight:bold">Tech Report ORNL/TM-2013/384.</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd"></a>refine_classic&#160;</td><td class="fielddoc"><p>Isotropic refinement using only the children and disregarding missing parents. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac709fc494353223f300235750f8b96eda004bf7a9a0d0e7ed8aadba8062c653f4"></a>refine_parents_first&#160;</td><td class="fielddoc"><p>Isotropic refinement adding children only if the parents are already included. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac709fc494353223f300235750f8b96eda8528073ff3d46cee384d8b4fa2db72ed"></a>refine_direction_selective&#160;</td><td class="fielddoc"><p>Anisotropic refinement using only the children and disregarding missing parents. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac709fc494353223f300235750f8b96eda939fdaecc186a219034e156eb8ace917"></a>refine_fds&#160;</td><td class="fielddoc"><p>Anisotropic refinement adding children only if the parents are already included. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac709fc494353223f300235750f8b96edac00c2b6dda342ab4e3c7b22bcca3755a"></a>refine_stable&#160;</td><td class="fielddoc"><p>Isotropic refinement that ensures the points maintain lower-complete structures. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac709fc494353223f300235750f8b96eda9df1c5dae76a52a2993bed6a84f4e2bc"></a>refine_none&#160;</td><td class="fielddoc"><p>Null method, should <b>never</b> be used as input. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga344ee5be5b77f2ff8e7c98f97ab40581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga344ee5be5b77f2ff8e7c98f97ab40581">&#9670;&nbsp;</a></span>TypeAcceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TasGrid::TypeAcceleration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modes of acceleration. </p>
<dl class="section user"><dt>Acceleration Context</dt><dd>Each Tasmanian object creates a Tasmanian acceleration context that operate on one of several modes (depending on the external libraries being used) and the context will remain persistent on read/write, make/clean, and move operation. The context cannot be copied from one object to another. For example, an object is created and CUDA acceleration is enabled, then makeLocalPolynomial() is called, then the Nvidia GPU device will be used to speed the different operation of the grid, if then read() is called, a new grid will be loaded from a file and regardless of the type of grid the GPU will still be in use by the object. If the grid is copied, both source and destination will retain their original acceleration contexts and only the grid data (e.g., points and model values) will be copied.</dd></dl>
<dl class="section user"><dt>Utilizing Accelerated Libraries</dt><dd>Each Tasmanian operation that has a (potentially) significant computational cost is a candidate for acceleration. Currently, OpenMP is uses throughout the Tasmanian code is essentially all potential places and the evaluateBatch() methods associated with all types of grids can be accelerated with BLAS and CUDA. The BLAS/LAPACK and CUDA acceleration is also available in other select methods, e.g., <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adcb888a2375dcbb51775b3a894eb32df" title="Alias of loadNeededValues().">TasmanianSparseGrid::loadNeededPoints()</a> for local polynomial and wavelet grid.</dd></dl>
<dl class="section user"><dt>OpenMP and Thread Count</dt><dd>If enabled, OpenMP is ubiquitous throughout Tasmanian in almost all computationally expensive operations. The acceleration mode can be disabled only at compile time; however, the standard OpenMP options are respected at runtime, e.g., the method omp_set_num_threads() and OMP_NUM_THREADS environment variable, if either is set to 1, Tasmanian will use only one hardware thread.</dd></dl>
<dl class="section user"><dt>Acceleration Mode None</dt><dd>In this mode, Tasmanian will forego the use of third party libraries (other then OpenMP) and the algorithms will run in the most memory conservative way. Due to improved data-locality and depending on the hardware architecture, the <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766" title="Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the...">TasGrid::accel_none</a> mode can be the fastest mode for small grids with few points and few outputs.</dd></dl>
<dl class="section user"><dt>Memory Management and Persistent Data</dt><dd>The use of third party libraries requires that matrices are explicitly formed even when that can be avoided in the no-acceleration mode. Furthermore, operations that are called repeatedly, i.e., evaluateBatch() used in the context of DREAM sampling, will also cache matrices that can be reused in multiple calls. The cache is particularly an issue for the various GPU modes since the memory on the accelerator devices is sometimes limited. One-shot calls, such as <a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad49a95d0766243ba2d5d1a8f10dedb15" title="Alias to loadNeededValues(), array variant.">loadNeededPoints()</a>, will not use cache that persistent after the call to the method. The cache can always be cleared by either changing the grid (creating a new grid or loading more points as part of iterative refinement), or by switching to mode <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766" title="Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the...">TasGrid::accel_none</a> and then back to one of the fast modes.</dd></dl>
<dl class="section user"><dt>Memory usage for Evaluate Batch</dt><dd>Global, Sequence, Fourier and Wavelet grids operate only with dense matrices and require one persistent matrix of size <b><a class="el" href="namespaceTasGrid_1_1OneDimensionalMeta.html#af23764f9bb4844dfa8231283f55da3ec" title="Return the number of points for the rule at the level, includes all global rules.">getNumPoints()</a></b> times <b>getNumOutputs()</b>, one temporary matrix of size <b><a class="el" href="namespaceTasGrid_1_1OneDimensionalMeta.html#af23764f9bb4844dfa8231283f55da3ec" title="Return the number of points for the rule at the level, includes all global rules.">getNumPoints()</a></b> times <b>num_x</b>, and user provided matrix to hold the result of size <b>getNumOutputs()</b> times <b>num_x</b>. The batch size <b>num_x</b> can be adjusted to accommodate memory constraints, but better performance is usually achieved when <b>num_x</b> is large due to the increased opportunities to parallelize. Local polynomial grids (when using the default sparse mode) will use sparse representation of the transient matrix and thus the memory usage strongly depends on the graph structure of the grid. In addition, all grids use a relatively small amount of GPU cache which depends on the number of underlying tensors and the specific graph structure of the grid.</dd></dl>
<dl class="section user"><dt>Defaults</dt><dd>If <b>Tasmanian_ENABLE_BLAS</b> is enabled in CMake, then <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a4e99f4378b49ba22efd866d1eff3e689" title="Default (if available), uses both BLAS and LAPACK libraries.">TasGrid::accel_cpu_blas</a> will be the default acceleration mode, otherwise the default mode is <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766" title="Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the...">TasGrid::accel_none</a>. The <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a52e9ac2d8d5cb478c18e8f91e3ebaf7e" title="Equivalent to the first available from MAGMA, CUDA, BLAS, or none.">TasGrid::accel_gpu_default</a> uses the first available in the list:<ul>
<li><a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581aac3a98fcec9c100e5422a7cd89e37269" title="Same the CUDA option but uses the UTK MAGMA library for the linear algebra operations.">TasGrid::accel_gpu_magma</a></li>
<li><a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622" title="Similar to the cuBLAS option but also uses a set of Tasmanian custom GPU kernels.">TasGrid::accel_gpu_cuda</a></li>
<li><a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a4e99f4378b49ba22efd866d1eff3e689" title="Default (if available), uses both BLAS and LAPACK libraries.">TasGrid::accel_cpu_blas</a></li>
<li><a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766" title="Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the...">TasGrid::accel_none</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The defaults and fallback extend to all methods that could use accelerations. For example, if GPU acceleration has been enabled, but the current method does not have a GPU implementation, the "next-best" BLAS implementation will be used instead. Thus, the use of BLAS and LAPACK can be disabled either at compile time or with accel_none, but not with accel_gpu_cuda.</dd></dl>
<dl class="section user"><dt></dt><dd>Note that regardless of the acceleration mode, all evaluate methods will to generate output that is identical up to rounding error. By design, the <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">TasmanianSparseGrid::enableAcceleration()</a></b> can be called with any acceleration type regardless whether it has been enabled by CMake. In order to facilitate code portability, Tasmanian implements sane fall-back modes so that "the next best mode" will be automatically selected if the desired mode is not present. Specifically, missing MAGMA will fallback to CUDA, missing CUDA will fallback to BLAS, and missing BLAS will fallback to none.</dd></dl>
<dl class="section user"><dt>Thread Safety and Const-correctness</dt><dd>Using mode <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766" title="Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the...">TasGrid::accel_none</a>, Tasmanian will not use any transient data-structures and the code is const-correct in the strictest definition, i.e., any two const-methods can be called concurrently from any two threads and will produce the correct result. Other modes use transient cache (with the C++ keyword mutable), which will be generated after the first call to the method and will be reused in follow on call. Thus, the first call is not thread-safe, while the follow on calls are strictly const-correct in the same sense as <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766" title="Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the...">TasGrid::accel_none</a>. Also note that some third party libraries can have additional restrictions, e.g., concurrent calls to OpenBLAS are not thread-safe unless the library is build with a specific flag. The CUDA and MAGMA libraries appear to not have such limitations.</dd></dl>
<dl class="section user"><dt>Library Handles</dt><dd>The GPU libraries use context handles to manage metadata such as active device and device pointer type. By default, Tasmanian will automatically create the handles whenever needed and will destroy them whenever the object is destroyed or the acceleration mode is updated. However, Tasmanian also provides an API where the user can provide the corresponding handles: <div class="fragment"><div class="line"><span class="comment">// Nvidia CUDA framework</span></div>
<div class="line">grid.setCuBlasHandle(cublas_handle);</div>
<div class="line">grid.setCuSparseHandle(cusparse_handle);</div>
<div class="line">grid.setCuSolverHandle(cusolverdn_handle);</div>
<div class="line"><span class="comment">// AMD ROCm framework</span></div>
<div class="line">grid.setRocBlasHandle(rocblas_handle);</div>
<div class="line">grid.setRocSparseHandle(rocsparse_handle);</div>
<div class="line"><span class="comment">// Intel DPC++ framework</span></div>
<div class="line">grid.setSycleQueue(pointer_to_sycl_queue);</div>
</div><!-- fragment --><ul>
<li>Each handle must be a valid, i.e., already created by the corresponding API call and must be associated with the currently selected GPU device ID.</li>
<li>Tasmanian assumes that the pointer mode is "host pointer" (for Nvidia and AMD) and if a different mode is set in-between Tasmanian API calls, the mode must be reset before the next Tasmanian call.</li>
<li>The SYCL queue is accepted as a pointer, which is different then the usual SYCL approach but it is consistent within the Tasmanian API.</li>
<li>The methods interact directly with the TPL API and hence the methods do not have fallback modes if GPU has not been enabled. </li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766"></a>accel_none&#160;</td><td class="fielddoc"><p>Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the fastest mode for small problems. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga344ee5be5b77f2ff8e7c98f97ab40581a4e99f4378b49ba22efd866d1eff3e689"></a>accel_cpu_blas&#160;</td><td class="fielddoc"><p>Default (if available), uses both BLAS and LAPACK libraries. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga344ee5be5b77f2ff8e7c98f97ab40581a52e9ac2d8d5cb478c18e8f91e3ebaf7e"></a>accel_gpu_default&#160;</td><td class="fielddoc"><p>Equivalent to the first available from MAGMA, CUDA, BLAS, or none. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga344ee5be5b77f2ff8e7c98f97ab40581abff34d0602911ef3a29a952b793413d3"></a>accel_gpu_cublas&#160;</td><td class="fielddoc"><p>Mixed usage of the CPU (OpenMP) and GPU libraries. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622"></a>accel_gpu_cuda&#160;</td><td class="fielddoc"><p>Similar to the cuBLAS option but also uses a set of Tasmanian custom GPU kernels. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga344ee5be5b77f2ff8e7c98f97ab40581aac3a98fcec9c100e5422a7cd89e37269"></a>accel_gpu_magma&#160;</td><td class="fielddoc"><p>Same the CUDA option but uses the UTK MAGMA library for the linear algebra operations. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div> -->
</body>
</html>
