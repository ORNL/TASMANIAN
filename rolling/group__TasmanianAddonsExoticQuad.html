<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: Exotic Quadrature</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TasmanianAddonsExoticQuad.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Exotic Quadrature<div class="ingroups"><a class="el" href="group__TasmanianAddons.html">Additional Capabilities</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Exotic Quadrature:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianAddonsExoticQuad.png" border="0" usemap="#agroup____TasmanianAddonsExoticQuad" alt=""/></div>
<map name="agroup____TasmanianAddonsExoticQuad" id="agroup____TasmanianAddonsExoticQuad">
<area shape="rect" href="group__TasmanianAddons.html" title=" " alt="" coords="5,5,156,31"/>
<area shape="rect" title=" " alt="" coords="204,5,331,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:tsgExoticQuadrature_8hpp" id="r_tsgExoticQuadrature_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsgExoticQuadrature_8hpp.html">tsgExoticQuadrature.hpp</a></td></tr>
<tr class="memdesc:tsgExoticQuadrature_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header to include the exotic quadrature templates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad9f15829a6b9b13a62e90cbc6ca8740f" id="r_gad9f15829a6b9b13a62e90cbc6ca8740f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#gad9f15829a6b9b13a62e90cbc6ca8740f">TasGrid::poly_eval</a> (const std::vector&lt; double &gt; &amp;roots, double x)</td></tr>
<tr class="memdesc:gad9f15829a6b9b13a62e90cbc6ca8740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a polynomial with roots given by <b>roots</b> at the point <b>x</b>.  <br /></td></tr>
<tr class="separator:gad9f15829a6b9b13a62e90cbc6ca8740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3102cd0928f73082d0c1cbf533ca5cfc" id="r_ga3102cd0928f73082d0c1cbf533ca5cfc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga3102cd0928f73082d0c1cbf533ca5cfc">TasGrid::lagrange_eval</a> (size_t idx, const std::vector&lt; double &gt; &amp;roots, double x)</td></tr>
<tr class="memdesc:ga3102cd0928f73082d0c1cbf533ca5cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a Lagrange basis polynomial at a point <b>x</b>.  <br /></td></tr>
<tr class="separator:ga3102cd0928f73082d0c1cbf533ca5cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4591280048835a763f665137aefad5" id="r_gabf4591280048835a763f665137aefad5"><td class="memTemplParams" colspan="2">template&lt;bool is_symmetric&gt; </td></tr>
<tr class="memitem:gabf4591280048835a763f665137aefad5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#gabf4591280048835a763f665137aefad5">TasGrid::getGaussNodesAndWeights</a> (const int n, const std::vector&lt; double &gt; &amp;ref_points, const std::vector&lt; double &gt; &amp;ref_weights, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;points_cache, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;weights_cache)</td></tr>
<tr class="memdesc:gabf4591280048835a763f665137aefad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates n levels of points and weights using orthogonal polynomials with respect to ref_points and ref_weights.  <br /></td></tr>
<tr class="separator:gabf4591280048835a763f665137aefad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9baa7cec8f4096683e6f17b2c4aa1f88" id="r_ga9baa7cec8f4096683e6f17b2c4aa1f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga9baa7cec8f4096683e6f17b2c4aa1f88">TasGrid::getShiftedExoticQuadrature</a> (const int n, const double shift, const std::vector&lt; double &gt; &amp;shifted_weights, const std::vector&lt; double &gt; &amp;ref_points, const char *description, const bool is_symmetric=false)</td></tr>
<tr class="memdesc:ga9baa7cec8f4096683e6f17b2c4aa1f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the exotic quadrature points and weights and load them into a <a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">TasGrid::CustomTabulated</a> object.  <br /></td></tr>
<tr class="separator:ga9baa7cec8f4096683e6f17b2c4aa1f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5740bba8e7517b684377786bad6a4bff" id="r_ga5740bba8e7517b684377786bad6a4bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga5740bba8e7517b684377786bad6a4bff">TasGrid::shiftReferenceWeights</a> (std::vector&lt; double &gt; const &amp;vals, double shift, std::vector&lt; double &gt; &amp;ref_weights)</td></tr>
<tr class="memdesc:ga5740bba8e7517b684377786bad6a4bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the reference quadrature weights by the shifted values of the weight function.  <br /></td></tr>
<tr class="separator:ga5740bba8e7517b684377786bad6a4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cfd0f3dda72fcacc6288ddae24e2d19" id="r_ga2cfd0f3dda72fcacc6288ddae24e2d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga2cfd0f3dda72fcacc6288ddae24e2d19">TasGrid::getExoticQuadrature</a> (const int num_levels, const double shift, const <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a> &amp;grid, const char *description, const bool is_symmetric=false)</td></tr>
<tr class="memdesc:ga2cfd0f3dda72fcacc6288ddae24e2d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an exotic quadrature from a sparse grid object.  <br /></td></tr>
<tr class="separator:ga2cfd0f3dda72fcacc6288ddae24e2d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61aaac9fcfbb38c259453c3029f20cc0" id="r_ga61aaac9fcfbb38c259453c3029f20cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga61aaac9fcfbb38c259453c3029f20cc0">TasGrid::getExoticQuadrature</a> (const int num_levels, const double shift, std::function&lt; double(double)&gt; weight_fn, const int num_ref_points, const char *description, const bool is_symmetric=false)</td></tr>
<tr class="memdesc:ga61aaac9fcfbb38c259453c3029f20cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__TasmanianAddonsExoticQuad.html#ga2cfd0f3dda72fcacc6288ddae24e2d19" title="Constructs an exotic quadrature from a sparse grid object.">getExoticQuadrature()</a> but the weight function is defined by a lambda expression.  <br /></td></tr>
<tr class="separator:ga61aaac9fcfbb38c259453c3029f20cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Exotic Quadrature</dt><dd>The Exotic Quadrature module of Tasmanian offers a collection of functions for generating one dimensional quadrature rules with weight functions that are not strictly non-negative. The quadrature rules are loaded inside <a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">TasGrid::CustomTabulated</a> objects and be used in calls to TasmanianSparseGrid::makeGlobalGrid() to extend those to a multidimensional context.</dd></dl>
<dl class="section user"><dt></dt><dd>The integral of interest has the form <picture><source srcset="form_52_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \int_{-1}^{1} f(x) \rho(x) dx $" src="form_52.png" width="114" height="26"/></picture> and it differs from the classical Gaussian rules by allowing the weight function <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \rho(x) $" src="form_4.png" width="33" height="19"/></picture> to be negative in portions of the domain. We still require that the weight is integrable and bounded from below, i.e., <picture><source srcset="form_53_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \int_{-1}^{1} | \rho(x) | dx &lt; \infty $" src="form_53.png" width="131" height="26"/></picture> and <picture><source srcset="form_54_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \rho(x) \geq c &gt; -\infty $" src="form_54.png" width="119" height="19"/></picture>.</dd></dl>
<dl class="section user"><dt></dt><dd>The quadrature consists of two components, one is a quadrature that uses classical Gaussian construction using the root of polynomials that are orthogonal with respect to a shifted positive weight <picture><source srcset="form_55_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \rho(x) + c \geq 0 $" src="form_55.png" width="95" height="19"/></picture> and a correction term using Gauss-Legendre rule scaled by -c. While the asymptotic convergence rate is inferior to that of Gauss-Legendre, for small number of points the accuracy of the combined quadrature rule can be significantly greater. This advantage is further magnified in a sparse grid context where reaching the asymptotic regime for Gauss-Legendre may require a prohibitive number of points due to the curse of dimensionality.</dd></dl>
<dl class="section user"><dt></dt><dd>The weight can be defined either with a C++ lambda expression or a one-dimensional TasmanianSparseGrid object. The lambda expression will be evaluated at a large number of Gauss-Legendre points that will be used for a reference quadrature to build the orthogonal polynomial basis. In the case of a sparse grid object, only the loaded points and quadrature weights will be used, and no interpolation will be performed inbetween (i.e., we circumvent potential interpolation error). </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad9f15829a6b9b13a62e90cbc6ca8740f" name="gad9f15829a6b9b13a62e90cbc6ca8740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9f15829a6b9b13a62e90cbc6ca8740f">&#9670;&#160;</a></span>poly_eval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TasGrid::poly_eval </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a polynomial with roots given by <b>roots</b> at the point <b>x</b>. </p>
<p>The polynomial is defined by a simple product of (x - roots[i]) and will not be normalized. </p>

</div>
</div>
<a id="ga3102cd0928f73082d0c1cbf533ca5cfc" name="ga3102cd0928f73082d0c1cbf533ca5cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3102cd0928f73082d0c1cbf533ca5cfc">&#9670;&#160;</a></span>lagrange_eval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TasGrid::lagrange_eval </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a Lagrange basis polynomial at a point <b>x</b>. </p>
<p>The Lagrange basis at idx is 1 when x = roots[idx] and 0 for all other roots. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>is the index of the Lagrange polynomial </td></tr>
    <tr><td class="paramname">roots</td><td>is the point set the defines the Lagrange polynomials </td></tr>
    <tr><td class="paramname">x</td><td>is the point of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf4591280048835a763f665137aefad5" name="gabf4591280048835a763f665137aefad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf4591280048835a763f665137aefad5">&#9670;&#160;</a></span>getGaussNodesAndWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_symmetric&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::getGaussNodesAndWeights </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates n levels of points and weights using orthogonal polynomials with respect to ref_points and ref_weights. </p>
<p>Given the reference points and weights, finds the roots of the first n + 1 orthogonal polynomials. The first polynomial is always constant, every following polynomial is chosen so that it is orthogonal with respect to all previous polynomials and the orthogonality (i.e., inner product integral) is computed with the reference quadrature points and weights.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">is_symmetric</td><td>indicates whether the weight function is symmetric or not, the algorithm makes slight modifications that improve stability in the symmetric case</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the number of quadrature rules to construct </td></tr>
    <tr><td class="paramname">ref_points</td><td>are the points of the reference quadrature </td></tr>
    <tr><td class="paramname">ref_weights</td><td>are the weights of the reference quadrature multiplied by the shifted weight function </td></tr>
    <tr><td class="paramname">points_cache</td><td>on exit will be loaded so that points_cache[i] will be roots of the i+1-st orthogonal polynomial </td></tr>
    <tr><td class="paramname">weights_cache</td><td>on exit will be loaded with the quadrature weights corresponding to the points_cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9baa7cec8f4096683e6f17b2c4aa1f88" name="ga9baa7cec8f4096683e6f17b2c4aa1f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9baa7cec8f4096683e6f17b2c4aa1f88">&#9670;&#160;</a></span>getShiftedExoticQuadrature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a> TasGrid::getShiftedExoticQuadrature </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>shifted_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the exotic quadrature points and weights and load them into a <a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">TasGrid::CustomTabulated</a> object. </p>
<p>The method calls <a class="el" href="group__TasmanianAddonsExoticQuad.html#gabf4591280048835a763f665137aefad5" title="Generates n levels of points and weights using orthogonal polynomials with respect to ref_points and ...">getGaussNodesAndWeights()</a> and adds the Gauss-Legendre correction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the number of levels to compute </td></tr>
    <tr><td class="paramname">shift</td><td>is the correction term applied to the weight function to enforce positivity </td></tr>
    <tr><td class="paramname">shifted_weights</td><td>are the reference quadrature points multiplied by the values of the shifted weight function at the reference points </td></tr>
    <tr><td class="paramname">ref_points</td><td>are the reference quadrature points </td></tr>
    <tr><td class="paramname">description</td><td>is the human readable string to identify the quadrature rule </td></tr>
    <tr><td class="paramname">is_symmetric</td><td>indicates whether we can use algorithm modifications that can improve stability </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5740bba8e7517b684377786bad6a4bff" name="ga5740bba8e7517b684377786bad6a4bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5740bba8e7517b684377786bad6a4bff">&#9670;&#160;</a></span>shiftReferenceWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::shiftReferenceWeights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the reference quadrature weights by the shifted values of the weight function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>are the values of the exotic weight function at the reference quadrature points </td></tr>
    <tr><td class="paramname">shift</td><td>is a real-valued scalar that ensures all <b>vals</b>[i] + <b>shift</b> are positive </td></tr>
    <tr><td class="paramname">ref_weights</td><td>are the reference quadrature weights, will be overwritten with the result ref_weights[i] * (vals[i] + shift)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <b>vals</b>[i] + <b>shift</b> is negative for some index i</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2cfd0f3dda72fcacc6288ddae24e2d19" name="ga2cfd0f3dda72fcacc6288ddae24e2d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cfd0f3dda72fcacc6288ddae24e2d19">&#9670;&#160;</a></span>getExoticQuadrature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a> TasGrid::getExoticQuadrature </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an exotic quadrature from a sparse grid object. </p>
<p>Constructs a set of one dimensional quadrature rules with respect to a 1D weight function approximated by <b>grid</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_levels</td><td>is the number of levels that should be computed </td></tr>
    <tr><td class="paramname">shift</td><td>is a real-valued scalar that needs to be added to the weight function to make it positive </td></tr>
    <tr><td class="paramname">grid</td><td>has dimension 1 and at least one loaded point, should use as many points as possible for better accuracy (up to some point where numerical stability is lost) </td></tr>
    <tr><td class="paramname">description</td><td>is a human readable string that can be used to identify the quadrature rule (could be empty) </td></tr>
    <tr><td class="paramname">is_symmetric</td><td>indicates whether to assume that the weight is symmetric, which allows for some stability improvements; symmetric means "even" on [-1, 1], which leads to all odd power polynomials integrating to zero; the same holds for shifted domains so long as the weight is "even" with respect to the mid-point of the domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">TasGrid::CustomTabulated</a> object holding the points and weights for the different levels of the quadrature</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <b>grid</b> doesn't have a single input and output or no loaded points, or if the value of the weight function plus the shift is not non-negative</td></tr>
  </table>
  </dd>
</dl>
<p>The <b>grid</b> object is used in two ways: first, it defines a reference quadrature that will be used to compute the inner-product integrals that define orthogonal polynomials; second, it defines the values of the weight function <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \rho(x) $" src="form_4.png" width="33" height="19"/></picture> at the quadrature points. Note that the values of the weight function will not be interpolated between the reference points.</p>
<p>Examples of symmetric weight functions are <picture><source srcset="form_56_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \sin(x) $" src="form_56.png" width="46" height="19"/></picture>, <picture><source srcset="form_57_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \sin(x) / x $" src="form_57.png" width="65" height="19"/></picture>, constant weight, and the Gauss-Chebyshev weights. On the other hand, <picture><source srcset="form_58_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \cos(x) $" src="form_58.png" width="47" height="19"/></picture> is not symmetric in the context of this algorithm due to the shift that must be applied. </p>

</div>
</div>
<a id="ga61aaac9fcfbb38c259453c3029f20cc0" name="ga61aaac9fcfbb38c259453c3029f20cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61aaac9fcfbb38c259453c3029f20cc0">&#9670;&#160;</a></span>getExoticQuadrature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a> TasGrid::getExoticQuadrature </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>weight_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_ref_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__TasmanianAddonsExoticQuad.html#ga2cfd0f3dda72fcacc6288ddae24e2d19" title="Constructs an exotic quadrature from a sparse grid object.">getExoticQuadrature()</a> but the weight function is defined by a lambda expression. </p>
<p>Constructs a <a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">CustomTabulated</a> object holding the points and weights for the different levels of the quadrature for the given parameter <b>weight_fn</b>. The <b>num_ref_points</b> parameter sets the number of reference points from a Gauss-Legendre quadrature that will be used to compute the inner-product integrals that define the orthogonal polynomials. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
