<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: Static Load Model Values</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TasmanianAddonsLoadNeededVals.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Static Load Model Values<div class="ingroups"><a class="el" href="group__TasmanianAddons.html">Additional Capabilities</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Static Load Model Values:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianAddonsLoadNeededVals.png" border="0" usemap="#agroup____TasmanianAddonsLoadNeededVals" alt=""/></div>
<map name="agroup____TasmanianAddonsLoadNeededVals" id="agroup____TasmanianAddonsLoadNeededVals">
<area shape="rect" href="group__TasmanianAddons.html" title=" " alt="" coords="5,5,156,31"/>
<area shape="rect" title=" " alt="" coords="204,5,375,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad239942d20e99244061b4886f96dea4a" id="r_gad239942d20e99244061b4886f96dea4a"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </td></tr>
<tr class="memitem:gad239942d20e99244061b4886f96dea4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a">TasGrid::loadNeededValues</a> (std::function&lt; void(double const x[], double y[], size_t thread_id)&gt; model, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, size_t num_threads)</td></tr>
<tr class="memdesc:gad239942d20e99244061b4886f96dea4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the current grid with model values, does not perform any refinement.  <br /></td></tr>
<tr class="separator:gad239942d20e99244061b4886f96dea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91382894cb86187d4a043af2f0d3c5c0" id="r_ga91382894cb86187d4a043af2f0d3c5c0"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </td></tr>
<tr class="memitem:ga91382894cb86187d4a043af2f0d3c5c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadNeededVals.html#ga91382894cb86187d4a043af2f0d3c5c0">TasGrid::loadNeededValues</a> (std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y, size_t thread_id)&gt; model, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, size_t num_threads)</td></tr>
<tr class="memdesc:ga91382894cb86187d4a043af2f0d3c5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses vectors for the model inputs and outputs.  <br /></td></tr>
<tr class="separator:ga91382894cb86187d4a043af2f0d3c5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49a95d0766243ba2d5d1a8f10dedb15" id="r_gad49a95d0766243ba2d5d1a8f10dedb15"><td class="memTemplParams" colspan="2"><a id="gad49a95d0766243ba2d5d1a8f10dedb15" name="gad49a95d0766243ba2d5d1a8f10dedb15"></a>
template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </td></tr>
<tr class="memitem:gad49a95d0766243ba2d5d1a8f10dedb15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TasGrid::loadNeededPoints</b> (std::function&lt; void(double const x[], double y[], size_t thread_id)&gt; model, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, size_t num_threads)</td></tr>
<tr class="memdesc:gad49a95d0766243ba2d5d1a8f10dedb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a" title="Loads the current grid with model values, does not perform any refinement.">loadNeededValues()</a>, array variant. <br /></td></tr>
<tr class="separator:gad49a95d0766243ba2d5d1a8f10dedb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765e36b8991244a94e3e57f48dcce874" id="r_ga765e36b8991244a94e3e57f48dcce874"><td class="memTemplParams" colspan="2"><a id="ga765e36b8991244a94e3e57f48dcce874" name="ga765e36b8991244a94e3e57f48dcce874"></a>
template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </td></tr>
<tr class="memitem:ga765e36b8991244a94e3e57f48dcce874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TasGrid::loadNeededPoints</b> (std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y, size_t thread_id)&gt; model, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, size_t num_threads)</td></tr>
<tr class="memdesc:ga765e36b8991244a94e3e57f48dcce874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a" title="Loads the current grid with model values, does not perform any refinement.">loadNeededValues()</a>, vector variant. <br /></td></tr>
<tr class="separator:ga765e36b8991244a94e3e57f48dcce874"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Handy templates to automate the common use case of evaluating a model at the needed (or loaded) points and feeding the values to the grid. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad239942d20e99244061b4886f96dea4a" name="gad239942d20e99244061b4886f96dea4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad239942d20e99244061b4886f96dea4a">&#9670;&#160;</a></span>loadNeededValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::loadNeededValues </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(double const x[], double y[], size_t thread_id)&gt;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the current grid with model values, does not perform any refinement. </p>
<p>Loads model values into the grid using the provided lambda function, the model can be computed either sequentially or in parallel. This is a non-adaptive procedure, i.e., the points will not be changes only the associated model values will be modified.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_construction</td><td>defines whether to run in parallel or sequential mode. </td></tr>
    <tr><td class="paramname">overwrite_loaded</td><td>defines whether to overwrite the currently loaded model values or to assign values to the needed points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>is the lambda representation of a model with inputs <b>x</b> and outputs <b>y</b>, the lambda must accept arrays with size equal to the grid dimensions and outputs. For each <b>x</b>, the <b>y</b> must be overwritten with the corresponding model values. If parallel sampling is uses, then <b>thread_id</b> will be a unique number between 0 and <b>num_threads-1</b> associated with the running thread. The id can help associate each thread with additional external resources, e.g., a separate CUDA device can be associated with each thread.</td></tr>
    <tr><td class="paramname">grid</td><td>is the sparse grid that will be loaded. The grid must not be set for construction and the number of inputs must be positive. The method grid.loadNeededValues() will be called with values corresponding to the model outputs at either the loaded or the needed points.</td></tr>
    <tr><td class="paramname">num_threads</td><td>is the number of parallel calls to the <b>model</b> lambda. If set to zero, sequential mode will be used without launching any threads, the number is ignored in sequential mode. Note that this is using the C++ native std::thread as opposed to OpenMP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if grid.isUsingConstruction() is true or if grid.getNumOutputs() is zero.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// construct a grid for 10-th order global polynomials</span></div>
<div class="line"><span class="keyword">auto</span> grid = <a class="code hl_function" href="group__TasmanianSG.html#ga734013b4f52c4d1d9a35d674b459e13a">TasGrid::makeGlobalGrid</a>(4, 1, 10, <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">TasGrid::type_iptotal</a>, <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">TasGrid::rule_leja</a>);</div>
<div class="line"><span class="comment">// note that the grid is set to 4 inputs and 1 output, the model function should be the same</span></div>
<div class="line"><span class="keyword">auto</span> model = [](<span class="keywordtype">double</span> <span class="keyword">const</span> x[], <span class="keywordtype">double</span> y[], size_t)-&gt;<span class="keywordtype">void</span>{</div>
<div class="line">     y[0] = std::exp(x[0] + x[1] + x[2] + x[3]);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a">loadNeededValues</a>(model, grid, 4); <span class="comment">// using parallel sampling with 4 threads</span></div>
<div class="line"><span class="comment">// at this point, grid is a 10-th order polynomial approximation to exp(x0 + x2 + x3 + x4)</span></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">TasGrid::rule_leja</a></div><div class="ttdeci">@ rule_leja</div><div class="ttdoc">Classic sequence rule, moderate Lebesgue constant growth (empirical result only).</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:299</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431"><div class="ttname"><a href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">TasGrid::type_iptotal</a></div><div class="ttdeci">@ type_iptotal</div><div class="ttdoc">Total degree polynomial space for interpolation, i.e., the span of   .</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:221</div></div>
<div class="ttc" id="agroup__TasmanianAddonsLoadNeededVals_html_gad239942d20e99244061b4886f96dea4a"><div class="ttname"><a href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a">TasGrid::loadNeededValues</a></div><div class="ttdeci">void loadNeededValues(std::function&lt; void(double const x[], double y[], size_t thread_id)&gt; model, TasmanianSparseGrid &amp;grid, size_t num_threads)</div><div class="ttdoc">Loads the current grid with model values, does not perform any refinement.</div><div class="ttdef"><b>Definition</b> tsgLoadNeededValues.hpp:104</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_ga734013b4f52c4d1d9a35d674b459e13a"><div class="ttname"><a href="group__TasmanianSG.html#ga734013b4f52c4d1d9a35d674b459e13a">TasGrid::makeGlobalGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeGlobalGrid(int dimensions, int outputs, int depth, TypeDepth type, TypeOneDRule rule, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), double alpha=0.0, double beta=0.0, const char *custom_filename=nullptr, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeGlobalGrid().</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:2287</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga91382894cb86187d4a043af2f0d3c5c0" name="ga91382894cb86187d4a043af2f0d3c5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91382894cb86187d4a043af2f0d3c5c0">&#9670;&#160;</a></span>loadNeededValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::loadNeededValues </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y, size_t thread_id)&gt;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses vectors for the model inputs and outputs. </p>
<p>The template will accept the array inputs from the main implementation and copy those to the vectors. Thus, there is an extra copy of data, which is unavoidable since <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html" title="The master-class that represents an instance of a Tasmanian sparse grid.">TasGrid::TasmanianSparseGrid</a> returns contiguous vectors that cannot be split without copy. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
