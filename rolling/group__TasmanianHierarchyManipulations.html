<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2 (development): Hierarchical multi-Index manipulation algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.1
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2 (development)
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TasmanianHierarchyManipulations.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Hierarchical multi-Index manipulation algorithms<div class="ingroups"><a class="el" href="group__TasmanianSG.html">Sparse Grids</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Hierarchical multi-Index manipulation algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianHierarchyManipulations.png" border="0" usemap="#agroup____TasmanianHierarchyManipulations" alt=""/></div>
<map name="agroup____TasmanianHierarchyManipulations" id="agroup____TasmanianHierarchyManipulations">
<area shape="rect" title=" " alt="" coords="152,5,287,60"/>
<area shape="rect" href="group__TasmanianSG.html" title=" " alt="" coords="5,20,104,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:tsgHierarchyManipulator_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsgHierarchyManipulator_8hpp.html">tsgHierarchyManipulator.hpp</a></td></tr>
<tr class="memdesc:tsgHierarchyManipulator_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms for manipulating multi-indexes defined by hierarchy rules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1HierarchyManipulations_1_1SplitDirections.html">TasGrid::HierarchyManipulations::SplitDirections</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganize the <b>points</b> into sets of nodes that align in one-dimension, used for directional localp refinement.  <a href="classTasGrid_1_1HierarchyManipulations_1_1SplitDirections.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga84f3e4e87704b2609acf1a7e738c0c6a"><td class="memTemplParams" colspan="2">template&lt;RuleLocal::erule effrule&gt; </td></tr>
<tr class="memitem:ga84f3e4e87704b2609acf1a7e738c0c6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga84f3e4e87704b2609acf1a7e738c0c6a">TasGrid::HierarchyManipulations::computeDAGup</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset)</td></tr>
<tr class="memdesc:ga84f3e4e87704b2609acf1a7e738c0c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache the indexes slot numbers of the parents of the multi-indexes in <b>mset</b>.  <a href="group__TasmanianHierarchyManipulations.html#ga84f3e4e87704b2609acf1a7e738c0c6a">More...</a><br /></td></tr>
<tr class="separator:ga84f3e4e87704b2609acf1a7e738c0c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c00aa0721275bf8afd3e1739cbe38a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gaf5c00aa0721275bf8afd3e1739cbe38a">TasGrid::HierarchyManipulations::computeDAGup</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, RuleLocal::erule effrule)</td></tr>
<tr class="memdesc:gaf5c00aa0721275bf8afd3e1739cbe38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache the indexes slot numbers of the parents of the multi-indexes in <b>mset</b>.  <a href="group__TasmanianHierarchyManipulations.html#gaf5c00aa0721275bf8afd3e1739cbe38a">More...</a><br /></td></tr>
<tr class="separator:gaf5c00aa0721275bf8afd3e1739cbe38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2461d8111423f5fe7b3a45f2c69441f"><td class="memTemplParams" colspan="2">template&lt;RuleLocal::erule effrule&gt; </td></tr>
<tr class="memitem:gae2461d8111423f5fe7b3a45f2c69441f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gae2461d8111423f5fe7b3a45f2c69441f">TasGrid::HierarchyManipulations::computeDAGup</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, bool &amp;is_complete)</td></tr>
<tr class="memdesc:gae2461d8111423f5fe7b3a45f2c69441f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant that also check if all points have all parents.  <a href="group__TasmanianHierarchyManipulations.html#gae2461d8111423f5fe7b3a45f2c69441f">More...</a><br /></td></tr>
<tr class="separator:gae2461d8111423f5fe7b3a45f2c69441f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52a0183c4c106541c0956404e6a072f"><td class="memTemplParams" colspan="2">template&lt;RuleLocal::erule effrule&gt; </td></tr>
<tr class="memitem:gaa52a0183c4c106541c0956404e6a072f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gaa52a0183c4c106541c0956404e6a072f">TasGrid::HierarchyManipulations::computeDAGDown</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset)</td></tr>
<tr class="memdesc:gaa52a0183c4c106541c0956404e6a072f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache the indexes slot numbers of the children of the multi-indexes in <b>mset</b>.  <a href="group__TasmanianHierarchyManipulations.html#gaa52a0183c4c106541c0956404e6a072f">More...</a><br /></td></tr>
<tr class="separator:gaa52a0183c4c106541c0956404e6a072f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be1fabd3daca3a893169648ea17cf6e"><td class="memTemplParams" colspan="2">template&lt;RuleLocal::erule effrule&gt; </td></tr>
<tr class="memitem:ga9be1fabd3daca3a893169648ea17cf6e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga9be1fabd3daca3a893169648ea17cf6e">TasGrid::HierarchyManipulations::computeLevels</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset)</td></tr>
<tr class="memdesc:ga9be1fabd3daca3a893169648ea17cf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector that is the sum of the one dimensional levels of each multi-index in the set..  <a href="group__TasmanianHierarchyManipulations.html#ga9be1fabd3daca3a893169648ea17cf6e">More...</a><br /></td></tr>
<tr class="separator:ga9be1fabd3daca3a893169648ea17cf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ddc3f1020bcecc8d23c11211ccc6550"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga0ddc3f1020bcecc8d23c11211ccc6550">TasGrid::HierarchyManipulations::computeLevels</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, RuleLocal::erule effrule)</td></tr>
<tr class="memdesc:ga0ddc3f1020bcecc8d23c11211ccc6550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that turns switch statement into template instantiations.  <a href="group__TasmanianHierarchyManipulations.html#ga0ddc3f1020bcecc8d23c11211ccc6550">More...</a><br /></td></tr>
<tr class="separator:ga0ddc3f1020bcecc8d23c11211ccc6550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0833ae9bf4dc1e7714dc227c82e9c190"><td class="memTemplParams" colspan="2">template&lt;RuleLocal::erule effrule&gt; </td></tr>
<tr class="memitem:ga0833ae9bf4dc1e7714dc227c82e9c190"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga0833ae9bf4dc1e7714dc227c82e9c190">TasGrid::HierarchyManipulations::completeToLower</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;refined)</td></tr>
<tr class="memdesc:ga0833ae9bf4dc1e7714dc227c82e9c190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete <b>refined</b> so that the union of <b>refined</b> and <b>mset</b> is lower w.r.t. the <b>rule</b>. .  <a href="group__TasmanianHierarchyManipulations.html#ga0833ae9bf4dc1e7714dc227c82e9c190">More...</a><br /></td></tr>
<tr class="separator:ga0833ae9bf4dc1e7714dc227c82e9c190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78ff4cd614395eb3e5accc1e020aba9"><td class="memTemplParams" colspan="2">template&lt;RuleLocal::erule effrule, typename callable_method &gt; </td></tr>
<tr class="memitem:gaf78ff4cd614395eb3e5accc1e020aba9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gaf78ff4cd614395eb3e5accc1e020aba9">TasGrid::HierarchyManipulations::touchAllImmediateRelatives</a> (std::vector&lt; int &gt; &amp;point, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, callable_method apply)</td></tr>
<tr class="memdesc:gaf78ff4cd614395eb3e5accc1e020aba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will call <b>apply()</b> with the slot index in <b>mset</b> of each parent/child of <b>point</b>..  <a href="group__TasmanianHierarchyManipulations.html#gaf78ff4cd614395eb3e5accc1e020aba9">More...</a><br /></td></tr>
<tr class="separator:gaf78ff4cd614395eb3e5accc1e020aba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427eb4fa1080f66e14207852af9c1e32"><td class="memTemplParams" colspan="2">template&lt;RuleLocal::erule effrule&gt; </td></tr>
<tr class="memitem:ga427eb4fa1080f66e14207852af9c1e32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga427eb4fa1080f66e14207852af9c1e32">TasGrid::HierarchyManipulations::getLevelZeroPoints</a> (size_t num_dimensions)</td></tr>
<tr class="memdesc:ga427eb4fa1080f66e14207852af9c1e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tensor set of all points that sit on level zero (i.e., have no parents).  <a href="group__TasmanianHierarchyManipulations.html#ga427eb4fa1080f66e14207852af9c1e32">More...</a><br /></td></tr>
<tr class="separator:ga427eb4fa1080f66e14207852af9c1e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga831813a44d44da11eadae85e186d7da7"><td class="memTemplParams" colspan="2">template&lt;RuleLocal::erule effrule&gt; </td></tr>
<tr class="memitem:ga831813a44d44da11eadae85e186d7da7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga831813a44d44da11eadae85e186d7da7">TasGrid::HierarchyManipulations::getLargestConnected</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;current, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;candidates)</td></tr>
<tr class="memdesc:ga831813a44d44da11eadae85e186d7da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest subset of <b>candidates</b> such that adding it to <b>current</b> will result in a connected graph.  <a href="group__TasmanianHierarchyManipulations.html#ga831813a44d44da11eadae85e186d7da7">More...</a><br /></td></tr>
<tr class="separator:ga831813a44d44da11eadae85e186d7da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b99f917762d0a819a421af53a8bf49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa8b99f917762d0a819a421af53a8bf49"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gaa8b99f917762d0a819a421af53a8bf49">TasGrid::HierarchyManipulations::splitByLevels</a> (size_t stride, typename std::vector&lt; T &gt;::const_iterator ibegin, typename std::vector&lt; T &gt;::const_iterator iend, std::vector&lt; int &gt;::const_iterator ilevels)</td></tr>
<tr class="memdesc:gaa8b99f917762d0a819a421af53a8bf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the range between <b>ibegin</b> and <b>iend</b> into strips of <b>stride</b> and orders those by levels according to the level index in <b>ilevels</b>.  <a href="group__TasmanianHierarchyManipulations.html#gaa8b99f917762d0a819a421af53a8bf49">More...</a><br /></td></tr>
<tr class="separator:gaa8b99f917762d0a819a421af53a8bf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e71f808c63d1ec5487f9f8fc3ec1d85"><td class="memItemLeft" align="right" valign="top"><a id="ga5e71f808c63d1ec5487f9f8fc3ec1d85"></a>
std::vector&lt; <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga5e71f808c63d1ec5487f9f8fc3ec1d85">TasGrid::HierarchyManipulations::splitByLevels</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, std::vector&lt; int &gt; const &amp;levels)</td></tr>
<tr class="memdesc:ga5e71f808c63d1ec5487f9f8fc3ec1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that operates on an entire multi-index set. <br /></td></tr>
<tr class="separator:ga5e71f808c63d1ec5487f9f8fc3ec1d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7bf2cc030e5bc451248ce56080a455a"><td class="memTemplParams" colspan="2"><a id="gab7bf2cc030e5bc451248ce56080a455a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab7bf2cc030e5bc451248ce56080a455a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gab7bf2cc030e5bc451248ce56080a455a">TasGrid::HierarchyManipulations::splitByLevels</a> (<a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; T &gt; const &amp;data, std::vector&lt; int &gt; const &amp;levels)</td></tr>
<tr class="memdesc:gab7bf2cc030e5bc451248ce56080a455a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that operates on an entire <a class="el" href="classTasGrid_1_1Data2D.html" title="Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix).">Data2D</a> structure set. <br /></td></tr>
<tr class="separator:gab7bf2cc030e5bc451248ce56080a455a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6594bfaf4f5a85503ce295f9b92c8160"><td class="memItemLeft" align="right" valign="top"><a id="ga6594bfaf4f5a85503ce295f9b92c8160"></a>
std::vector&lt; <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga6594bfaf4f5a85503ce295f9b92c8160">TasGrid::HierarchyManipulations::splitByLevels</a> (<a class="el" href="classTasGrid_1_1StorageSet.html">StorageSet</a> const &amp;stortage, std::vector&lt; int &gt; const &amp;levels)</td></tr>
<tr class="memdesc:ga6594bfaf4f5a85503ce295f9b92c8160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that operates on an entire <a class="el" href="classTasGrid_1_1StorageSet.html" title="Class that stores values, i.e., model outputs, the order of the values is in sync with the order of s...">StorageSet</a> structure set. <br /></td></tr>
<tr class="separator:ga6594bfaf4f5a85503ce295f9b92c8160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>One Dimensional Hierarchy</dt><dd>The construction of Global, Sequence and Fourier grids the multi-index hierarchy is associated with tensors and has very simple structure, in one dimension there is only one parent and one child indicated by the previous and next index. The Local-Polynomial and Wavelet girds use more complex hierarchies that have multiple children and (in some cases) parents. Many of the associated manipulation algorithms require a <b>rule</b> object that describes the hierarchy, and additional algorithms are needed to handle the more complex parent-child relations.</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga84f3e4e87704b2609acf1a7e738c0c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84f3e4e87704b2609acf1a7e738c0c6a">&#9670;&nbsp;</a></span>computeDAGup() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RuleLocal::erule effrule&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt;int&gt; TasGrid::HierarchyManipulations::computeDAGup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache the indexes slot numbers of the parents of the multi-indexes in <b>mset</b>. </p>
<p>Each node defined by a multi-index in <b>mset</b> can have one or more parents in each direction, where the parent-offspring relation is defined by the <b>rule</b>. For each index in <b>mset</b>, the <a class="el" href="classTasGrid_1_1Data2D.html" title="Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix).">Data2D</a> structure <b>parents</b> will hold a strip with the location of each parent in <b>mset</b> (or -1 if the parent is missing from <b>mset</b>). </p>

</div>
</div>
<a id="gaf5c00aa0721275bf8afd3e1739cbe38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5c00aa0721275bf8afd3e1739cbe38a">&#9670;&nbsp;</a></span>computeDAGup() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt;int&gt; TasGrid::HierarchyManipulations::computeDAGup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RuleLocal::erule&#160;</td>
          <td class="paramname"><em>effrule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache the indexes slot numbers of the parents of the multi-indexes in <b>mset</b>. </p>
<p>The effective rule is passed in at runtime and a switch statement finds the correct template. </p>

</div>
</div>
<a id="gae2461d8111423f5fe7b3a45f2c69441f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2461d8111423f5fe7b3a45f2c69441f">&#9670;&nbsp;</a></span>computeDAGup() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RuleLocal::erule effrule&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt;int&gt; TasGrid::HierarchyManipulations::computeDAGup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant that also check if all points have all parents. </p>
<p>This is merged together so it will do only one pass over the data.</p>
<p>On exit, <b>is_complete</b> will indicate whether there are points with missing parents. </p>

</div>
</div>
<a id="gaa52a0183c4c106541c0956404e6a072f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52a0183c4c106541c0956404e6a072f">&#9670;&nbsp;</a></span>computeDAGDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RuleLocal::erule effrule&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt;int&gt; TasGrid::HierarchyManipulations::computeDAGDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache the indexes slot numbers of the children of the multi-indexes in <b>mset</b>. </p>
<p>Each node defined by a multi-index in <b>mset</b> can have one or more children in each direction, where the parent-offspring relation is defined by the <b>rule</b>. For each index in <b>mset</b>, the returned <a class="el" href="classTasGrid_1_1Data2D.html" title="Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix).">Data2D</a> structure will hold a strip with the location of each child in <b>mset</b> (or -1 if the kid is missing from <b>mset</b>). </p>

</div>
</div>
<a id="ga9be1fabd3daca3a893169648ea17cf6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be1fabd3daca3a893169648ea17cf6e">&#9670;&nbsp;</a></span>computeLevels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RuleLocal::erule effrule&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; TasGrid::HierarchyManipulations::computeLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector that is the sum of the one dimensional levels of each multi-index in the set.. </p>

</div>
</div>
<a id="ga0ddc3f1020bcecc8d23c11211ccc6550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ddc3f1020bcecc8d23c11211ccc6550">&#9670;&nbsp;</a></span>computeLevels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; TasGrid::HierarchyManipulations::computeLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RuleLocal::erule&#160;</td>
          <td class="paramname"><em>effrule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that turns switch statement into template instantiations. </p>

</div>
</div>
<a id="ga0833ae9bf4dc1e7714dc227c82e9c190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0833ae9bf4dc1e7714dc227c82e9c190">&#9670;&nbsp;</a></span>completeToLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RuleLocal::erule effrule&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::HierarchyManipulations::completeToLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>refined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete <b>refined</b> so that the union of <b>refined</b> and <b>mset</b> is lower w.r.t. the <b>rule</b>. . </p>

</div>
</div>
<a id="gaf78ff4cd614395eb3e5accc1e020aba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf78ff4cd614395eb3e5accc1e020aba9">&#9670;&nbsp;</a></span>touchAllImmediateRelatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RuleLocal::erule effrule, typename callable_method &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::HierarchyManipulations::touchAllImmediateRelatives </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callable_method&#160;</td>
          <td class="paramname"><em>apply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will call <b>apply()</b> with the slot index in <b>mset</b> of each parent/child of <b>point</b>.. </p>

</div>
</div>
<a id="ga427eb4fa1080f66e14207852af9c1e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga427eb4fa1080f66e14207852af9c1e32">&#9670;&nbsp;</a></span>getLevelZeroPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RuleLocal::erule effrule&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::HierarchyManipulations::getLevelZeroPoints </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the tensor set of all points that sit on level zero (i.e., have no parents). </p>

</div>
</div>
<a id="ga831813a44d44da11eadae85e186d7da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga831813a44d44da11eadae85e186d7da7">&#9670;&nbsp;</a></span>getLargestConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RuleLocal::erule effrule&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::HierarchyManipulations::getLargestConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the largest subset of <b>candidates</b> such that adding it to <b>current</b> will result in a connected graph. </p>

</div>
</div>
<a id="gaa8b99f917762d0a819a421af53a8bf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b99f917762d0a819a421af53a8bf49">&#9670;&nbsp;</a></span>splitByLevels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt;T&gt; &gt; TasGrid::HierarchyManipulations::splitByLevels </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; T &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>ibegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; T &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>iend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>ilevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the range between <b>ibegin</b> and <b>iend</b> into strips of <b>stride</b> and orders those by levels according to the level index in <b>ilevels</b>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div> -->
</body>
</html>
