<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: Multi-Index manipulation algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TasmanianMultiIndexManipulations.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Multi-Index manipulation algorithms<div class="ingroups"><a class="el" href="group__TasmanianSG.html">Sparse Grids</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Multi-Index manipulation algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianMultiIndexManipulations.png" border="0" usemap="#agroup____TasmanianMultiIndexManipulations" alt=""/></div>
<map name="agroup____TasmanianMultiIndexManipulations" id="agroup____TasmanianMultiIndexManipulations">
<area shape="rect" title=" " alt="" coords="152,5,315,45"/>
<area shape="rect" href="group__TasmanianSG.html" title=" " alt="" coords="5,13,104,38"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:tsgIndexManipulator_8hpp" id="r_tsgIndexManipulator_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsgIndexManipulator_8hpp.html">tsgIndexManipulator.hpp</a></td></tr>
<tr class="memdesc:tsgIndexManipulator_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms for manipulating sets of multi-indexes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceTasGrid_1_1MultiIndexManipulations" id="r_namespaceTasGrid_1_1MultiIndexManipulations"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1MultiIndexManipulations.html">TasGrid::MultiIndexManipulations</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1MultiIndexManipulations"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of algorithm to manipulate multi-indexes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTasGrid_1_1MultiIndexManipulations_1_1ProperWeights.html">TasGrid::MultiIndexManipulations::ProperWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds anisotropic weights in a usable format.  <a href="structTasGrid_1_1MultiIndexManipulations_1_1ProperWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga08182964c69cbf125f546f273064a34c" id="r_ga08182964c69cbf125f546f273064a34c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga08182964c69cbf125f546f273064a34c">TasGrid::MultiIndexManipulations::generateFullTensorSet</a> (std::vector&lt; int &gt; const &amp;num_entries)</td></tr>
<tr class="memdesc:ga08182964c69cbf125f546f273064a34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a full-tensor multi-index set with <b>num_entries</b> in each direction.  <br /></td></tr>
<tr class="separator:ga08182964c69cbf125f546f273064a34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga895481e5c9a48c10b6ef12e691b483f7" id="r_ga895481e5c9a48c10b6ef12e691b483f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga895481e5c9a48c10b6ef12e691b483f7">TasGrid::MultiIndexManipulations::generateLowerMultiIndexSet</a> (size_t num_dimensions, std::function&lt; bool(const std::vector&lt; int &gt; &amp;index)&gt; inside)</td></tr>
<tr class="memdesc:ga895481e5c9a48c10b6ef12e691b483f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the multi-index with entries satisfying the <b>inside()</b>, assumes that <b>inside()</b> defines a lower-complete set. .  <br /></td></tr>
<tr class="separator:ga895481e5c9a48c10b6ef12e691b483f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7ec3fa566b90db37d38a779f6e7dfa4" id="r_gac7ec3fa566b90db37d38a779f6e7dfa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gac7ec3fa566b90db37d38a779f6e7dfa4">TasGrid::MultiIndexManipulations::completeSetToLower</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;set)</td></tr>
<tr class="memdesc:gac7ec3fa566b90db37d38a779f6e7dfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the <b>set</b> with the minimum number of multi-indexes that will result in a lower complete set. .  <br /></td></tr>
<tr class="separator:gac7ec3fa566b90db37d38a779f6e7dfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c2a73862afd24e85d2b33a9836d2a2" id="r_gac1c2a73862afd24e85d2b33a9836d2a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gac1c2a73862afd24e85d2b33a9836d2a2">TasGrid::MultiIndexManipulations::computeLevels</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset)</td></tr>
<tr class="memdesc:gac1c2a73862afd24e85d2b33a9836d2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector that is the sum of entries of each multi-index in the set.  <br /></td></tr>
<tr class="separator:gac1c2a73862afd24e85d2b33a9836d2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba7181ed8539d782d78ad559f461f0f4" id="r_gaba7181ed8539d782d78ad559f461f0f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gaba7181ed8539d782d78ad559f461f0f4">TasGrid::MultiIndexManipulations::getMaxIndexes</a> (const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;mset)</td></tr>
<tr class="memdesc:gaba7181ed8539d782d78ad559f461f0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the maximum index in each dimension.  <br /></td></tr>
<tr class="separator:gaba7181ed8539d782d78ad559f461f0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf77cc773b3734f46986b406fd5ba91" id="r_gaedf77cc773b3734f46986b406fd5ba91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gaedf77cc773b3734f46986b406fd5ba91">TasGrid::MultiIndexManipulations::computeDAGup</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset)</td></tr>
<tr class="memdesc:gaedf77cc773b3734f46986b406fd5ba91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classTasGrid_1_1Data2D.html" title="Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix).">Data2D</a> structure where each strip holds the slot-index of the parents of indexes in <b>mset</b> (for each direction), using one-point-growth hierarchy.  <br /></td></tr>
<tr class="separator:gaedf77cc773b3734f46986b406fd5ba91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480eb8e9aca89f02489c8078daaffcc4" id="r_ga480eb8e9aca89f02489c8078daaffcc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga480eb8e9aca89f02489c8078daaffcc4">TasGrid::MultiIndexManipulations::selectFlaggedChildren</a> (const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;mset, const std::vector&lt; bool &gt; &amp;flagged, const std::vector&lt; int &gt; &amp;level_limits)</td></tr>
<tr class="memdesc:ga480eb8e9aca89f02489c8078daaffcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the <b>flagged</b> map, create a set with the flagged children of <b>mset</b> but only if they obey the <b>level_limits</b>.  <br /></td></tr>
<tr class="separator:ga480eb8e9aca89f02489c8078daaffcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98d8641e997154a06e1c7f5f8dcd5fd" id="r_gae98d8641e997154a06e1c7f5f8dcd5fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gae98d8641e997154a06e1c7f5f8dcd5fd">TasGrid::MultiIndexManipulations::generateNestedPoints</a> (const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;tensors, std::function&lt; int(int)&gt; getNumPoints)</td></tr>
<tr class="memdesc:gae98d8641e997154a06e1c7f5f8dcd5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a set of nested <b>tensors</b> to the actual points, where each level has <b>getNumPoints()</b> in each direction.  <br /></td></tr>
<tr class="separator:gae98d8641e997154a06e1c7f5f8dcd5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b661ecdd2a4c87d0c1a1d92baf1d80" id="r_gad9b661ecdd2a4c87d0c1a1d92baf1d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gad9b661ecdd2a4c87d0c1a1d92baf1d80">TasGrid::MultiIndexManipulations::generateNonNestedPoints</a> (const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;tensors, const <a class="el" href="classTasGrid_1_1OneDimensionalWrapper.html">OneDimensionalWrapper</a> &amp;wrapper)</td></tr>
<tr class="memdesc:gad9b661ecdd2a4c87d0c1a1d92baf1d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a set of non-nested active <b>tensors</b> to the actual points, the <b>wrapper</b> gives mapping between level and point indexes.  <br /></td></tr>
<tr class="separator:gad9b661ecdd2a4c87d0c1a1d92baf1d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d2c0a33763de3d92e055ef78b0fa2b" id="r_ga49d2c0a33763de3d92e055ef78b0fa2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga49d2c0a33763de3d92e055ef78b0fa2b">TasGrid::MultiIndexManipulations::resortIndexes</a> (const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;iset, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;map, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;lines1d)</td></tr>
<tr class="memdesc:ga49d2c0a33763de3d92e055ef78b0fa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a map with sorted indexes dimension by dimension.  <br /></td></tr>
<tr class="separator:ga49d2c0a33763de3d92e055ef78b0fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b1c5fe80065668824c3832271c027a" id="r_gad2b1c5fe80065668824c3832271c027a"><td class="memTemplParams" colspan="2">template&lt;bool nested&gt; </td></tr>
<tr class="memitem:gad2b1c5fe80065668824c3832271c027a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gad2b1c5fe80065668824c3832271c027a">TasGrid::MultiIndexManipulations::referencePoints</a> (const int levels[], const <a class="el" href="classTasGrid_1_1OneDimensionalWrapper.html">OneDimensionalWrapper</a> &amp;wrapper, const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;points)</td></tr>
<tr class="memdesc:gad2b1c5fe80065668824c3832271c027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the indexes of all points associated with the tensor with <b>levels</b> within the global <b>points</b> set.  <br /></td></tr>
<tr class="separator:gad2b1c5fe80065668824c3832271c027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10bd79cecd051f5b28ffbd1ea2834ff8" id="r_ga10bd79cecd051f5b28ffbd1ea2834ff8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga10bd79cecd051f5b28ffbd1ea2834ff8">TasGrid::MultiIndexManipulations::computeTensorWeights</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset)</td></tr>
<tr class="memdesc:ga10bd79cecd051f5b28ffbd1ea2834ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weights for the tensor linear combination, <b>mset</b> must be a lower complete set.  <br /></td></tr>
<tr class="separator:ga10bd79cecd051f5b28ffbd1ea2834ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4185c2c64e662e38201e6d7bc69de855" id="r_ga4185c2c64e662e38201e6d7bc69de855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga4185c2c64e662e38201e6d7bc69de855">TasGrid::MultiIndexManipulations::createActiveTensors</a> (const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;mset, const std::vector&lt; int &gt; &amp;weights)</td></tr>
<tr class="memdesc:ga4185c2c64e662e38201e6d7bc69de855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set containing only the entries of <b>mset</b> that have non-zero <b>weights</b>.  <br /></td></tr>
<tr class="separator:ga4185c2c64e662e38201e6d7bc69de855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2cd5c29fb458f530b75873e0346fbf0" id="r_gad2cd5c29fb458f530b75873e0346fbf0"><td class="memItemLeft" align="right" valign="top"><a id="gad2cd5c29fb458f530b75873e0346fbf0" name="gad2cd5c29fb458f530b75873e0346fbf0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TasGrid::MultiIndexManipulations::computeActiveTensorsWeights</b> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;tensors, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;active_tensors, std::vector&lt; int &gt; &amp;active_w)</td></tr>
<tr class="memdesc:gad2cd5c29fb458f530b75873e0346fbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the <a class="el" href="group__TasmanianMultiIndexManipulations.html#ga10bd79cecd051f5b28ffbd1ea2834ff8" title="Computes the weights for the tensor linear combination, mset must be a lower complete set.">computeTensorWeights()</a> and <a class="el" href="group__TasmanianMultiIndexManipulations.html#ga4185c2c64e662e38201e6d7bc69de855" title="Creates a set containing only the entries of mset that have non-zero weights.">createActiveTensors()</a> to extract the active tensors and the active (non-zero) weights. <br /></td></tr>
<tr class="separator:gad2cd5c29fb458f530b75873e0346fbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d43cc012c6faf7ad49d5d847f010b8" id="r_gae8d43cc012c6faf7ad49d5d847f010b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gae8d43cc012c6faf7ad49d5d847f010b8">TasGrid::MultiIndexManipulations::createPolynomialSpace</a> (const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;tensors, std::function&lt; int(int)&gt; exactness)</td></tr>
<tr class="memdesc:gae8d43cc012c6faf7ad49d5d847f010b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a set of <b>tensors</b> compute the corresponding polynomial space assuming the 1D rules have given <b>exactness()</b>.  <br /></td></tr>
<tr class="separator:gae8d43cc012c6faf7ad49d5d847f010b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1d871cdfa81f64235607e04964951e" id="r_gaeb1d871cdfa81f64235607e04964951e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gaeb1d871cdfa81f64235607e04964951e">TasGrid::MultiIndexManipulations::isLowerComplete</a> (std::vector&lt; int &gt; const &amp;point, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, std::vector&lt; int &gt; &amp;scratch)</td></tr>
<tr class="memdesc:gaeb1d871cdfa81f64235607e04964951e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that <b>mset</b> is lower complete, return <b>true</b> if adding the <b>point</b> will preserve completeness.  <br /></td></tr>
<tr class="separator:gaeb1d871cdfa81f64235607e04964951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c087c720ae04c6cc3e9ba2a1f15798" id="r_ga67c087c720ae04c6cc3e9ba2a1f15798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga67c087c720ae04c6cc3e9ba2a1f15798">TasGrid::MultiIndexManipulations::getLargestCompletion</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;current, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;candidates)</td></tr>
<tr class="memdesc:ga67c087c720ae04c6cc3e9ba2a1f15798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest subset of <b>candidates</b> such that adding it to <b>current</b> will preserve lower completeness.  <br /></td></tr>
<tr class="separator:ga67c087c720ae04c6cc3e9ba2a1f15798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aff1894c942e6787ad49b616f9b931a" id="r_ga8aff1894c942e6787ad49b616f9b931a"><td class="memTemplParams" colspan="2">template&lt;bool limited&gt; </td></tr>
<tr class="memitem:ga8aff1894c942e6787ad49b616f9b931a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga8aff1894c942e6787ad49b616f9b931a">TasGrid::MultiIndexManipulations::addExclusiveChildren</a> (const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;tensors, const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;exclude, const std::vector&lt; int &gt; level_limits)</td></tr>
<tr class="memdesc:ga8aff1894c942e6787ad49b616f9b931a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a set of <b>tensors</b> create an <b>mset</b> that contain the children of indexes in <b>tensors</b> that are missing from <b>exclude</b> and obey the <b>level_limits</b>.  <br /></td></tr>
<tr class="separator:ga8aff1894c942e6787ad49b616f9b931a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36bc18ce85c328997b40051292cd3966" id="r_ga36bc18ce85c328997b40051292cd3966"><td class="memTemplParams" colspan="2">template&lt;class IndexList , class RuleLike , class OutputIteratorLike &gt; </td></tr>
<tr class="memitem:ga36bc18ce85c328997b40051292cd3966"><td class="memTemplItemLeft" align="right" valign="top">OutputIteratorLike&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga36bc18ce85c328997b40051292cd3966">TasGrid::MultiIndexManipulations::indexesToNodes</a> (IndexList const &amp;list, RuleLike const &amp;rule, OutputIteratorLike nodes)</td></tr>
<tr class="memdesc:ga36bc18ce85c328997b40051292cd3966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts int-indexes to double-valued abscissas using the provided rule.  <br /></td></tr>
<tr class="separator:ga36bc18ce85c328997b40051292cd3966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbe126d1b11092d6beead9604c761b01" id="r_gabbe126d1b11092d6beead9604c761b01"><td class="memTemplParams" colspan="2"><a id="gabbe126d1b11092d6beead9604c761b01" name="gabbe126d1b11092d6beead9604c761b01"></a>
template&lt;class IteratorLike , class RuleLike , class OutputIteratorLike &gt; </td></tr>
<tr class="memitem:gabbe126d1b11092d6beead9604c761b01"><td class="memTemplItemLeft" align="right" valign="top">OutputIteratorLike&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TasGrid::MultiIndexManipulations::indexesToNodes</b> (IteratorLike ibegin, size_t num_entries, RuleLike const &amp;rule, OutputIteratorLike nodes)</td></tr>
<tr class="memdesc:gabbe126d1b11092d6beead9604c761b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses a begin and a number of entries. <br /></td></tr>
<tr class="separator:gabbe126d1b11092d6beead9604c761b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14b3be8149e213280bc4c3c307ae525" id="r_gac14b3be8149e213280bc4c3c307ae525"><td class="memTemplParams" colspan="2"><a id="gac14b3be8149e213280bc4c3c307ae525" name="gac14b3be8149e213280bc4c3c307ae525"></a>
template&lt;class IndexList , class RuleLike &gt; </td></tr>
<tr class="memitem:gac14b3be8149e213280bc4c3c307ae525"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TasGrid::MultiIndexManipulations::getIndexesToNodes</b> (IndexList const &amp;list, RuleLike const &amp;rule)</td></tr>
<tr class="memdesc:gac14b3be8149e213280bc4c3c307ae525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that returns the result in a vector. <br /></td></tr>
<tr class="separator:gac14b3be8149e213280bc4c3c307ae525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c565a820a3e769bbb1f8ced655519e8" id="r_ga5c565a820a3e769bbb1f8ced655519e8"><td class="memTemplParams" colspan="2"><a id="ga5c565a820a3e769bbb1f8ced655519e8" name="ga5c565a820a3e769bbb1f8ced655519e8"></a>
template&lt;class IteratorLike , class RuleLike &gt; </td></tr>
<tr class="memitem:ga5c565a820a3e769bbb1f8ced655519e8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TasGrid::MultiIndexManipulations::getIndexesToNodes</b> (IteratorLike ibegin, size_t num_entries, RuleLike const &amp;rule)</td></tr>
<tr class="memdesc:ga5c565a820a3e769bbb1f8ced655519e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that returns the result in a vector. <br /></td></tr>
<tr class="separator:ga5c565a820a3e769bbb1f8ced655519e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82b339b09d3f2f2af253beab14f1ba1" id="r_gaa82b339b09d3f2f2af253beab14f1ba1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gaa82b339b09d3f2f2af253beab14f1ba1">TasGrid::MultiIndexManipulations::inferAnisotropicWeights</a> (<a class="el" href="structTasGrid_1_1AccelerationContext.html">AccelerationContext</a> const *acceleration, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> depth, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;points, std::vector&lt; double &gt; const &amp;coefficients, double tol)</td></tr>
<tr class="memdesc:gaa82b339b09d3f2f2af253beab14f1ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that returns the result in a vector.  <br /></td></tr>
<tr class="separator:gaa82b339b09d3f2f2af253beab14f1ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b5fb19d931e9acfe597176070b1765" id="r_gaa7b5fb19d931e9acfe597176070b1765"><td class="memTemplParams" colspan="2">template&lt;bool use_parents_direction&gt; </td></tr>
<tr class="memitem:gaa7b5fb19d931e9acfe597176070b1765"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gaa7b5fb19d931e9acfe597176070b1765">TasGrid::MultiIndexManipulations::repeatAddIndexes</a> (std::function&lt; bool(const std::vector&lt; int &gt; &amp;index)&gt; inside, std::vector&lt; <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &gt; &amp;level_sets)</td></tr>
<tr class="memdesc:gaa7b5fb19d931e9acfe597176070b1765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a series of <b>level_sets</b> where each set has the parents/children of the previous one that satisfy the <b>inside()</b> criteria.  <br /></td></tr>
<tr class="separator:gaa7b5fb19d931e9acfe597176070b1765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c95605911096e0153108491947613ea" id="r_ga0c95605911096e0153108491947613ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga0c95605911096e0153108491947613ea">TasGrid::MultiIndexManipulations::unionSets</a> (std::vector&lt; <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &gt; &amp;level_sets)</td></tr>
<tr class="memdesc:ga0c95605911096e0153108491947613ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retuns the union of all <b>level_sets</b>, all sets are destroyed in the process.  <br /></td></tr>
<tr class="separator:ga0c95605911096e0153108491947613ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f77e3c61fcfee9b070766d710f4f80" id="r_gaf1f77e3c61fcfee9b070766d710f4f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#gaf1f77e3c61fcfee9b070766d710f4f80">TasGrid::MultiIndexManipulations::generateGeneralMultiIndexSet</a> (size_t num_dimensions, std::function&lt; bool(const std::vector&lt; int &gt; &amp;index)&gt; criteria)</td></tr>
<tr class="memdesc:gaf1f77e3c61fcfee9b070766d710f4f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the minimum lower complete multi-index set that includes the indexes satisfying <b>criteria()</b>, assumes <b>criteria()</b> defines a connected set.  <br /></td></tr>
<tr class="separator:gaf1f77e3c61fcfee9b070766d710f4f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1136e06d031ce690d582505cef7ef5d7" id="r_ga1136e06d031ce690d582505cef7ef5d7"><td class="memTemplParams" colspan="2">template&lt;bool check_limits&gt; </td></tr>
<tr class="memitem:ga1136e06d031ce690d582505cef7ef5d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianMultiIndexManipulations.html#ga1136e06d031ce690d582505cef7ef5d7">TasGrid::MultiIndexManipulations::selectGeneralSet</a> (<a class="el" href="structTasGrid_1_1MultiIndexManipulations_1_1ProperWeights.html">ProperWeights</a> const &amp;weights, std::function&lt; int(int i)&gt; rule_exactness, int normalized_offset, std::vector&lt; int &gt; const &amp;level_limits)</td></tr>
<tr class="memdesc:ga1136e06d031ce690d582505cef7ef5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the minimum lower complete set that contains all indexes with weights less than <b>normalized_offset</b>.  <br /></td></tr>
<tr class="separator:ga1136e06d031ce690d582505cef7ef5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Multi-Index manipulation algorithms</dt><dd>A series of templates, lambda, and regular functions that allow the manipulation of multi-indexes and sets of multi-indexes. The algorithms include the selection of multi-indexes according to a criteria, union of a vector of multi-index sets, normalization of anisotropic weights, map parents and children within a set (which generates a DAG structure), complete a set to satisfy the lower-property, etc. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga08182964c69cbf125f546f273064a34c" name="ga08182964c69cbf125f546f273064a34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08182964c69cbf125f546f273064a34c">&#9670;&#160;</a></span>generateFullTensorSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::generateFullTensorSet </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>num_entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a full-tensor multi-index set with <b>num_entries</b> in each direction. </p>

</div>
</div>
<a id="ga895481e5c9a48c10b6ef12e691b483f7" name="ga895481e5c9a48c10b6ef12e691b483f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga895481e5c9a48c10b6ef12e691b483f7">&#9670;&#160;</a></span>generateLowerMultiIndexSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::generateLowerMultiIndexSet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const std::vector&lt; int &gt; &amp;index)&gt;&#160;</td>
          <td class="paramname"><em>inside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the multi-index with entries satisfying the <b>inside()</b>, assumes that <b>inside()</b> defines a lower-complete set. . </p>

</div>
</div>
<a id="gac7ec3fa566b90db37d38a779f6e7dfa4" name="gac7ec3fa566b90db37d38a779f6e7dfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7ec3fa566b90db37d38a779f6e7dfa4">&#9670;&#160;</a></span>completeSetToLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::MultiIndexManipulations::completeSetToLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the <b>set</b> with the minimum number of multi-indexes that will result in a lower complete set. . </p>

</div>
</div>
<a id="gac1c2a73862afd24e85d2b33a9836d2a2" name="gac1c2a73862afd24e85d2b33a9836d2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1c2a73862afd24e85d2b33a9836d2a2">&#9670;&#160;</a></span>computeLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; TasGrid::MultiIndexManipulations::computeLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector that is the sum of entries of each multi-index in the set. </p>

</div>
</div>
<a id="gaba7181ed8539d782d78ad559f461f0f4" name="gaba7181ed8539d782d78ad559f461f0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba7181ed8539d782d78ad559f461f0f4">&#9670;&#160;</a></span>getMaxIndexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; TasGrid::MultiIndexManipulations::getMaxIndexes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>mset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the maximum index in each dimension. </p>

</div>
</div>
<a id="gaedf77cc773b3734f46986b406fd5ba91" name="gaedf77cc773b3734f46986b406fd5ba91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf77cc773b3734f46986b406fd5ba91">&#9670;&#160;</a></span>computeDAGup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt; TasGrid::MultiIndexManipulations::computeDAGup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classTasGrid_1_1Data2D.html" title="Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix).">Data2D</a> structure where each strip holds the slot-index of the parents of indexes in <b>mset</b> (for each direction), using one-point-growth hierarchy. </p>
<p>Adds -1 in places where the parents are missing. </p>

</div>
</div>
<a id="ga480eb8e9aca89f02489c8078daaffcc4" name="ga480eb8e9aca89f02489c8078daaffcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga480eb8e9aca89f02489c8078daaffcc4">&#9670;&#160;</a></span>selectFlaggedChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::selectFlaggedChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>flagged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using the <b>flagged</b> map, create a set with the flagged children of <b>mset</b> but only if they obey the <b>level_limits</b>. </p>

</div>
</div>
<a id="gae98d8641e997154a06e1c7f5f8dcd5fd" name="gae98d8641e997154a06e1c7f5f8dcd5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98d8641e997154a06e1c7f5f8dcd5fd">&#9670;&#160;</a></span>generateNestedPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::generateNestedPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(int)&gt;&#160;</td>
          <td class="paramname"><em>getNumPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a set of nested <b>tensors</b> to the actual points, where each level has <b>getNumPoints()</b> in each direction. </p>
<p>Working with nested points, it is more efficient to interpret the tensors as a surplus operators and generate only the surplus points; then take the union without repeated indexes. This can work if and only if <b>tensors</b> is a lower-complete set, i.e., the <b>tensors</b> in <b>GridGlobal</b> and not the active_tensors. </p>

</div>
</div>
<a id="gad9b661ecdd2a4c87d0c1a1d92baf1d80" name="gad9b661ecdd2a4c87d0c1a1d92baf1d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9b661ecdd2a4c87d0c1a1d92baf1d80">&#9670;&#160;</a></span>generateNonNestedPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::generateNonNestedPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1OneDimensionalWrapper.html">OneDimensionalWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a set of non-nested active <b>tensors</b> to the actual points, the <b>wrapper</b> gives mapping between level and point indexes. </p>
<p>For each index in <b>tensor</b>, generate a local set of points and then remap them to the global index using the <b>wrapper.getPointIndex()</b>. </p>

</div>
</div>
<a id="ga49d2c0a33763de3d92e055ef78b0fa2b" name="ga49d2c0a33763de3d92e055ef78b0fa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49d2c0a33763de3d92e055ef78b0fa2b">&#9670;&#160;</a></span>resortIndexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::MultiIndexManipulations::resortIndexes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>iset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a map with sorted indexes dimension by dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iset</td><td>is a non-empty set of indexes </td></tr>
    <tr><td class="paramname">map</td><td>(output) the i-th index in the order with d as the fastest changing (contiguous) dimension is map[d][i] </td></tr>
    <tr><td class="paramname">lines1d</td><td>for each dimension d the indexes that match in all but d-dimension will be between lines1d[d][i] and lines1d[d][i+1] (not including the last entry) This is similar to the pntr index of row-compressed sparse matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2b1c5fe80065668824c3832271c027a" name="gad2b1c5fe80065668824c3832271c027a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2b1c5fe80065668824c3832271c027a">&#9670;&#160;</a></span>referencePoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool nested&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; TasGrid::MultiIndexManipulations::referencePoints </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>levels</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1OneDimensionalWrapper.html">OneDimensionalWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the indexes of all points associated with the tensor with <b>levels</b> within the global <b>points</b> set. </p>
<p>The order in which the tensors are formed here must match the order in which they will be used, e.g., when computing interpolation and quadrature weights. </p>

</div>
</div>
<a id="ga10bd79cecd051f5b28ffbd1ea2834ff8" name="ga10bd79cecd051f5b28ffbd1ea2834ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10bd79cecd051f5b28ffbd1ea2834ff8">&#9670;&#160;</a></span>computeTensorWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; TasGrid::MultiIndexManipulations::computeTensorWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weights for the tensor linear combination, <b>mset</b> must be a lower complete set. </p>

</div>
</div>
<a id="ga4185c2c64e662e38201e6d7bc69de855" name="ga4185c2c64e662e38201e6d7bc69de855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4185c2c64e662e38201e6d7bc69de855">&#9670;&#160;</a></span>createActiveTensors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::createActiveTensors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a set containing only the entries of <b>mset</b> that have non-zero <b>weights</b>. </p>

</div>
</div>
<a id="gae8d43cc012c6faf7ad49d5d847f010b8" name="gae8d43cc012c6faf7ad49d5d847f010b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d43cc012c6faf7ad49d5d847f010b8">&#9670;&#160;</a></span>createPolynomialSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::createPolynomialSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(int)&gt;&#160;</td>
          <td class="paramname"><em>exactness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a set of <b>tensors</b> compute the corresponding polynomial space assuming the 1D rules have given <b>exactness()</b>. </p>

</div>
</div>
<a id="gaeb1d871cdfa81f64235607e04964951e" name="gaeb1d871cdfa81f64235607e04964951e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb1d871cdfa81f64235607e04964951e">&#9670;&#160;</a></span>isLowerComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TasGrid::MultiIndexManipulations::isLowerComplete </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that <b>mset</b> is lower complete, return <b>true</b> if adding the <b>point</b> will preserve completeness. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>is the new point to add to an existing set </td></tr>
    <tr><td class="paramname">mset</td><td>is an existing lower complete set </td></tr>
    <tr><td class="paramname">scratch</td><td>is scratch space, must have size equal to point.size() and will be used for temporary storage the scratch reduces allocations</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67c087c720ae04c6cc3e9ba2a1f15798" name="ga67c087c720ae04c6cc3e9ba2a1f15798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67c087c720ae04c6cc3e9ba2a1f15798">&#9670;&#160;</a></span>getLargestCompletion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::getLargestCompletion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the largest subset of <b>candidates</b> such that adding it to <b>current</b> will preserve lower completeness. </p>

</div>
</div>
<a id="ga8aff1894c942e6787ad49b616f9b931a" name="ga8aff1894c942e6787ad49b616f9b931a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aff1894c942e6787ad49b616f9b931a">&#9670;&#160;</a></span>addExclusiveChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool limited&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::addExclusiveChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>exclude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>level_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a set of <b>tensors</b> create an <b>mset</b> that contain the children of indexes in <b>tensors</b> that are missing from <b>exclude</b> and obey the <b>level_limits</b>. </p>
<p>If <b>limited</b> is <b>false</b>, then the <b>level_limits</b> are ignored. </p>

</div>
</div>
<a id="ga36bc18ce85c328997b40051292cd3966" name="ga36bc18ce85c328997b40051292cd3966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36bc18ce85c328997b40051292cd3966">&#9670;&#160;</a></span>indexesToNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexList , class RuleLike , class OutputIteratorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIteratorLike TasGrid::MultiIndexManipulations::indexesToNodes </td>
          <td>(</td>
          <td class="paramtype">IndexList const &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RuleLike const &amp;&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIteratorLike&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts int-indexes to double-valued abscissas using the provided rule. </p>
<p>Nodes of the sparse grid are stored as multi-indexes in either vectors or <a class="el" href="classTasGrid_1_1MultiIndexSet.html" title="Class that stores multi-indexes in sorted (lexicographical) order.">MultiIndexSet</a> classes. The nodes are converted to double precision numbers according to a specified one-dimensional rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexList</td><td>is either a <a class="el" href="classTasGrid_1_1MultiIndexSet.html" title="Class that stores multi-indexes in sorted (lexicographical) order.">MultiIndexSet</a> or a std::vector&lt;int&gt;, both of which have a begin and end methods, the begin and end must allow iteration over a range of integers. </td></tr>
    <tr><td class="paramname">RuleLike</td><td>is either a <a class="el" href="classTasGrid_1_1OneDimensionalWrapper.html" title="A class to cache one dimensional rules, nodes, weight, meta-data, etc.">OneDimensionalWrapper</a>, derived from BaseRuleLocalPolynomial, or RuleWavelet, or any other class with getNode method that converts an int to a double; GridSequence class provides the getNode() method too. </td></tr>
    <tr><td class="paramname">OutputIteratorLike</td><td>indicates where the write the output, e.g., an iterator or an array, the output matches with OutputIteratorLike as defined by std::transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>defines a range of integers to be converted to double precision numbers. </td></tr>
    <tr><td class="paramname">rule</td><td>is a class with getNode method that defines the conversion. </td></tr>
    <tr><td class="paramname">nodes</td><td>marks the beginning of the output range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OutputIteratorLike at the end of the range that has been written.</dd></dl>
<p>Overloads are provided that work with an <b>ibegin</b> iterator and a number of <b>entries</b> in place of the <b>list</b>, as well as returning the result in a std::vector&lt;double&gt; as opposed to writing to a <b>nodes</b> iterator. See the brief descriptions at the top of the page. </p>

</div>
</div>
<a id="gaa82b339b09d3f2f2af253beab14f1ba1" name="gaa82b339b09d3f2f2af253beab14f1ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa82b339b09d3f2f2af253beab14f1ba1">&#9670;&#160;</a></span>inferAnisotropicWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; TasGrid::MultiIndexManipulations::inferAnisotropicWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTasGrid_1_1AccelerationContext.html">AccelerationContext</a> const *&#160;</td>
          <td class="paramname"><em>acceleration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that returns the result in a vector. </p>
<p>Infers the weights that best describe the decay-rate of the normalized coefficients given the rule and depth. The points represent either the polynomial powers of the frequencies of the Fourier transform and tol is the cutoff tolerance, i.e., use only the coefficients with magnitude exceeding tol. </p>

</div>
</div>
<a id="gaa7b5fb19d931e9acfe597176070b1765" name="gaa7b5fb19d931e9acfe597176070b1765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7b5fb19d931e9acfe597176070b1765">&#9670;&#160;</a></span>repeatAddIndexes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_parents_direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::MultiIndexManipulations::repeatAddIndexes </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const std::vector&lt; int &gt; &amp;index)&gt;&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>level_sets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a series of <b>level_sets</b> where each set has the parents/children of the previous one that satisfy the <b>inside()</b> criteria. </p>
<p>On entry, <b>level_sets</b> must constain at least one set. The function takes the last set in <b>level_sets</b> and adds a new set of eithe the parents or children that also satisfy the <b>inside()</b> condition. The process is repeated until the new set is empty. </p>

</div>
</div>
<a id="ga0c95605911096e0153108491947613ea" name="ga0c95605911096e0153108491947613ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c95605911096e0153108491947613ea">&#9670;&#160;</a></span>unionSets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::unionSets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>level_sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retuns the union of all <b>level_sets</b>, all sets are destroyed in the process. </p>

</div>
</div>
<a id="gaf1f77e3c61fcfee9b070766d710f4f80" name="gaf1f77e3c61fcfee9b070766d710f4f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f77e3c61fcfee9b070766d710f4f80">&#9670;&#160;</a></span>generateGeneralMultiIndexSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::generateGeneralMultiIndexSet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const std::vector&lt; int &gt; &amp;index)&gt;&#160;</td>
          <td class="paramname"><em>criteria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the minimum lower complete multi-index set that includes the indexes satisfying <b>criteria()</b>, assumes <b>criteria()</b> defines a connected set. </p>

</div>
</div>
<a id="ga1136e06d031ce690d582505cef7ef5d7" name="ga1136e06d031ce690d582505cef7ef5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1136e06d031ce690d582505cef7ef5d7">&#9670;&#160;</a></span>selectGeneralSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool check_limits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::MultiIndexManipulations::selectGeneralSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTasGrid_1_1MultiIndexManipulations_1_1ProperWeights.html">ProperWeights</a> const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(int i)&gt;&#160;</td>
          <td class="paramname"><em>rule_exactness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normalized_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the minimum lower complete set that contains all indexes with weights less than <b>normalized_offset</b>. </p>
<p>The weight of an index uses the <b>weights</b> combined with the <b>rule_exactness()</b>. Called only for contour <b>type_curved</b> and caches values on-the-fly.</p>
<p>If <b>check_limits</b> is <b>false</b>, then <b>level_limits</b> are ignored for speedup. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
