<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: Interface Fortran 2003</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_Doxygen_2InterfaceFortran2003.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Interface Fortran 2003</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md57"></a> Tasmanian comes with Fortran 2003 interface generated by <a href="https://github.com/swig-fortran">Swig-Fortran</a>. The automatic generation makes the code easy to maintain and support, and the generation process is done off-line by the development team; hence, users are not required to install Swig and can use the interface with just a regular Fortran compiler. Furthermore, the 2003 standard support objects which allows for the OOP interface of Tasmanian C++ to be duplicated similar to Python and thus the on-line C++ Doxygen documentation is now relevant to Fortran as well.</p>
<p>The module is called <code>Tasmanian</code> and requires Fortran 2003 and a class <code>TasmanianSparseGrid</code> type is used. Currently, the Tasmanian Sparse Grid module has been implemented together with the MPI Addons; the Dream module and the remainder of the Addon templates are not supported (possibly in the future).</p>
<p>Simple example: </p><div class="fragment"><div class="line">program tasmanian_demo</div>
<div class="line">    use Tasmanian</div>
<div class="line">    use, intrinsic :: iso_c_binding</div>
<div class="line">    implicit none</div>
<div class="line">    type(TasmanianSparseGrid) :: grid</div>
<div class="line">    real(C_DOUBLE), dimension(:,:), allocatable :: points</div>
<div class="line">    integer :: i, j</div>
<div class="line"> </div>
<div class="line">    grid = TasmanianSparseGrid()</div>
<div class="line">    call grid%makeGlobalGrid(2, 1, 1, tsg_type_level, tsg_rule_clenshawcurtis)</div>
<div class="line"> </div>
<div class="line">    allocate(points(grid%getNumDimensions(), grid%getNumPoints()))</div>
<div class="line">    call grid%getPoints(points(:, 1))</div>
<div class="line"> </div>
<div class="line">    do i = 1, grid%getNumDimensions()</div>
<div class="line">        do j = 1, grid%getNumPoints()</div>
<div class="line">            write(*,*) points(i, j)</div>
<div class="line">        enddo</div>
<div class="line">    enddo</div>
<div class="line"> </div>
<div class="line">    deallocate(points)</div>
<div class="line">    call grid%release()</div>
<div class="line">end program tasmanian_demo</div>
</div><!-- fragment --><p>Line by line:</p><ul>
<li>The <code>TasmanianSparseGrid</code> object must be initialized and deleted with the commands <div class="fragment"><div class="line">grid = TasmanianSparseGrid()</div>
<div class="line">call grid%release()</div>
</div><!-- fragment --></li>
<li>The make-grid commands have the same syntax as C++ with the enumerate types replaced by integer constants with identical names and the <code>tsg_</code> prefix.</li>
<li>The double-precision type used in all calls is <code>real(C_DOUBLE)</code> but it could easily be the Fortran native <code>DOUBLE PRECISION</code> so long as the type is compatible with <code>C_DOUBLE</code>.</li>
<li>The organization of the points is in two dimensional matrix, where each column corresponds to the coordinates of a single point; however, the API accepts only single dimensional arrays (c-style), hence the conversion <div class="fragment"><div class="line">call grid%getPoints(points(:, 1))</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md58"></a>
See the Included Examples</h2>
<p>Several Fortran examples are provided that duplicate the functionality in C++ and Python, which makes it easy to compare and contrast.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Filenames and Strings</h2>
<p>Strings works differently between the Fortran, C and C++ languages. Tasmanian I/O methods accept C-style of null-terminated character arrays, but Fortran character arrays are often padded with white spaces. The Fortran <code>trim()</code> command can be used to remove trailing white spaces from the filenames and avoid confusion with C++. See the following example that assumes a file with the name "123" is holding a valid Tasmanian sparse grid and we want to read the grid into a Tasmanian object: </p><div class="fragment"><div class="line">character(len = 3), parameter :: filename = &quot;123&quot;</div>
<div class="line">character(len = 4), parameter :: padded = &quot;123&quot;</div>
<div class="line"> </div>
<div class="line">grid = TasmanianSparseGrid()</div>
<div class="line">grid%read(filename)     ! OK, reads from &quot;123&quot;</div>
<div class="line">! grid%read(padded)     ! Bad, tries to read from &quot;123 &quot;</div>
<div class="line">grid%read(trim(padded)) ! OK, removes the extra space</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md60"></a>
Row-vs-Column Format</h2>
<p>C and C++-14 standards do not have a native two dimensional data-structure and many of the inputs and outputs for Tasmanain are logically organized in strips of data with a fixed stride. When interfacing with a language that supports two dimensional data (e.g., matrix type) it is beneficial to make the translation, but without a copy or manual transposing of the data to avoid performance degradation. Therefore, the strips of data are aligned to the dimension of the fastest index, e.g., the rows for a row-major language (Python-numpy) and columns for a column-major one (Fortran). The Matlab interface uses row-major format due to the ascii file standard used in the background.</p>
<p>The five point Clenshaw-Curtis grid has 5 points, <code>(0,0)</code>, <code>(0,-1)</code>, <code>(0,1)</code>, <code>(-1,0)</code> and <code>(1,0)</code>. The matrix generated by Fortran will have the organization: </p><div class="fragment"><div class="line">0  0 0 -1 1</div>
<div class="line">0 -1 1  0 0</div>
</div><!-- fragment --><p> while the Python and Matlab equivalents would be: </p><div class="fragment"><div class="line"> 0  0</div>
<div class="line"> 0 -1</div>
<div class="line"> 0  1</div>
<div class="line">-1  0</div>
<div class="line"> 1  0</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
Factory and Helper Methods and Namespaces</h2>
<p>Fortran 2003 does not support namespaces and the wrapper API works directly with user allocated matrices. The <code>make***Grid()</code> factory methods have been replaced with: </p><div class="fragment"><div class="line">TasGrid::makeGlobalGrid          =&gt; TasmanianGlobalGrid</div>
<div class="line">TasGrid::makeSequenceGrid        =&gt; TasmanianSequenceGrid</div>
<div class="line">TasGrid::makeLocalPolynomialGrid =&gt; TasmanianLocalPolynomialGrid</div>
<div class="line">TasGrid::makeFourierGrid         =&gt; TasmanianFourierGrid</div>
<div class="line">TasGrid::makeWaveletGrid         =&gt; TasmanianWaveletGrid</div>
<div class="line">TasGrid::readGrid                =&gt; TasmanianReadGrid</div>
<div class="line">TasGrid::copyGrid                =&gt; TasmanianCopyGrid</div>
</div><!-- fragment --><p> Although the methods do not support array API and hence anisotropic weights and level limits still require the use of the member functions, e.g., <code>makeGlobalGrid()</code>.</p>
<p>The static array API works with allocatable variables but requires user allocation of memory and is not very expressive. Functions that return pointers to pre-allocated data are preferable; however, functions and subroutines cannot share names in generic overloads. Thus, the Fortran functions use alternative names that start with <code>return</code> as opposed to <code>get</code>, e.g., </p><div class="fragment"><div class="line">real(C_DOUBLE), dimension(:,:), pointer :: points</div>
<div class="line">...</div>
<div class="line">points =&gt; grid%returnPoints()</div>
<div class="line">...</div>
<div class="line">deallocate(points)</div>
</div><!-- fragment --><p> The helper function are: </p><div class="fragment"><div class="line">points =&gt; grid%returnLoadedPoints()</div>
<div class="line">points =&gt; grid%returnNeededPoints()</div>
<div class="line">points =&gt; grid%returnPoints()</div>
<div class="line">weight =&gt; grid%returnQuadratureWeights()</div>
<div class="line">coeffs =&gt; grid%returnHierarchicalCoefficients()</div>
<div class="line">coeffs =&gt; grid%returnComplexHierarchicalCoefficients()</div>
</div><!-- fragment --><p> See the next section for complex numbers.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
Complex numbers</h2>
<p>Tasmanian Fourier grids utilize complex numbers in the background which is usually opaque to the user. However, the methods to set and get hierarchical coefficients do use complex numbers, see the C++ API for details. The C++ API returns raw pointers which cannot be manipulated directly from within Fortran; hence the C++ methods are replaced with methods that accept and return copies of the data and utilize the complex format (similar to Python and MATLAB). The two methods are: </p><div class="fragment"><div class="line">complex(C_DOUBLE), dimension(:, :), pointer :: coeffs, new_coeffs</div>
<div class="line">...</div>
<div class="line">coeffs =&gt; grid%returnComplexHierarchicalCoefficients()</div>
<div class="line">grid%setComplexHierarchicalCoefficients(new_coeffs)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md63"></a>
MPI Fortran Capabilities</h2>
<p>If Tasmanian has been compiled with MPI support, a second Tasmanian module will be included that contains Fortran wrappers for the MPI C++ templates. The module is called <code>Tasmanian_mpi</code> and must be used in conjunction with <code>Tasmanian</code>, e.g., </p><div class="fragment"><div class="line">use Tasmanian</div>
<div class="line">use Tasmanian_mpi</div>
<div class="line">use mpi</div>
</div><!-- fragment --><p> The <code>Tasmanian_mpi</code> module instantiates the templates as Fortran functions and pre-pends <code>tsg</code> to the names to avoid possible namespace conflicts, e.g., </p><div class="fragment"><div class="line">ierr = tsgMPIGridSend(grid, destination, tag, comm)</div>
<div class="line">ierr = tsgMPIGridRecv(grid, source, tag, comm)</div>
<div class="line">ierr = tsgMPIGridBcast(grid, root, comm)</div>
<div class="line">ierr = tsgMPIGridScatterOutputs(grid, subgrid, root, tag, comm)</div>
</div><!-- fragment --><p> Note, each methods returns the MPI error code returned by C++ which is different from the way MPI usually works under Fortran, but that is due to the way Swig instantiates the templates and the fact that the error comes from MPI call in the C++ section of the code. The templates always work in binary communication mode, since the ASCII mode is mostly for debugging purposes on the C++ side. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
