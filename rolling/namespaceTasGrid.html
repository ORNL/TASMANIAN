<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: TasGrid Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceTasGrid.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">TasGrid Namespace Reference<div class="ingroups"><a class="el" href="group__TasmanianSG.html">Sparse Grids</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Encapsulates the Tasmanian Sparse Grid module.  
<a href="namespaceTasGrid.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceTasGrid_1_1AccelerationMeta" id="r_namespaceTasGrid_1_1AccelerationMeta"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1AccelerationMeta.html">AccelerationMeta</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1AccelerationMeta"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common methods for manipulating acceleration options and reading CUDA environment properties. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1AccHandle" id="r_namespaceTasGrid_1_1AccHandle"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1AccHandle.html">AccHandle</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1AccHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type tags for the different handle types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1HierarchyManipulations" id="r_namespaceTasGrid_1_1HierarchyManipulations"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1HierarchyManipulations.html">HierarchyManipulations</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1HierarchyManipulations"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of algorithm to manipulate multi-indexes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1IO" id="r_namespaceTasGrid_1_1IO"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1IO.html">IO</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1IO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of I/O handling templates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1Maths" id="r_namespaceTasGrid_1_1Maths"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1Maths.html">Maths</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1Maths"><td class="mdescLeft">&#160;</td><td class="mdescRight">Math functions and constants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1MultiIndexManipulations" id="r_namespaceTasGrid_1_1MultiIndexManipulations"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1MultiIndexManipulations.html">MultiIndexManipulations</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1MultiIndexManipulations"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of algorithm to manipulate multi-indexes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1OneDimensionalMeta" id="r_namespaceTasGrid_1_1OneDimensionalMeta"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1OneDimensionalMeta.html">OneDimensionalMeta</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1OneDimensionalMeta"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata for one dimensional rules, number of points, exactness, I/O, etc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1OneDimensionalNodes" id="r_namespaceTasGrid_1_1OneDimensionalNodes"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1OneDimensionalNodes.html">OneDimensionalNodes</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1OneDimensionalNodes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains algorithms for generating Gauss,Chebyshev, and Fourier nodes and weights. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1TasGpu" id="r_namespaceTasGrid_1_1TasGpu"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1TasGpu.html">TasGpu</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1TasGpu"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrappers around custom CUDA kernels to handle domain transforms and basis evaluations, the kernels are instantiated in tsgCudaKernels.cu. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1TasmanianDenseSolver" id="r_namespaceTasGrid_1_1TasmanianDenseSolver"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1TasmanianDenseSolver.html">TasmanianDenseSolver</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1TasmanianDenseSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for dense linear algebra. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1TasmanianFourierTransform" id="r_namespaceTasGrid_1_1TasmanianFourierTransform"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1TasmanianFourierTransform.html">TasmanianFourierTransform</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1TasmanianFourierTransform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for Fast-Fourier-Transform. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1TasmanianTridiagonalSolver" id="r_namespaceTasGrid_1_1TasmanianTridiagonalSolver"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1TasmanianTridiagonalSolver.html">TasmanianTridiagonalSolver</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1TasmanianTridiagonalSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for tridiagonal eigenvalue problems. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1TasSparse" id="r_namespaceTasGrid_1_1TasSparse"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1TasSparse.html">TasSparse</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1TasSparse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for sparse linear algebra. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1Utils" id="r_namespaceTasGrid_1_1Utils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1Utils.html">Utils</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1Utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Miscellaneous utility templates (internal use). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTasGrid_1_1AccelerationContext.html">AccelerationContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class around GPU device ID, acceleration type and <a class="el" href="structTasGrid_1_1GpuEngine.html" title="Wrapper class around calls GPU accelerated linear algebra libraries.">GpuEngine</a>.  <a href="structTasGrid_1_1AccelerationContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1AccelerationDomainTransform.html">AccelerationDomainTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the domain transform algorithms in case the user data is provided on the GPU.  <a href="classTasGrid_1_1AccelerationDomainTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1CacheLagrange.html">CacheLagrange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache that holds the values of 1D Lagrange polynomials.  <a href="classTasGrid_1_1CacheLagrange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1CacheLagrangeDerivative.html">CacheLagrangeDerivative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache that holds the derivatives of 1D Lagrange polynomials. Uses the same interface as <a class="el" href="classTasGrid_1_1CacheLagrange.html" title="Cache that holds the values of 1D Lagrange polynomials.">CacheLagrange</a>. .  <a href="classTasGrid_1_1CacheLagrangeDerivative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1CandidateManager.html">CandidateManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages candidate points.  <a href="classTasGrid_1_1CandidateManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1CompleteStorage.html">CompleteStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores complete set of points before adding to the sparse grid.  <a href="classTasGrid_1_1CompleteStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1CustomTabulated.html">CustomTabulated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class providing manipulation of custom tabulated rules, file I/O and structured access to the points, weights, and meta-data.  <a href="classTasGrid_1_1CustomTabulated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix).  <a href="classTasGrid_1_1Data2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1DynamicConstructorDataGlobal.html">DynamicConstructorDataGlobal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that stores data from dynamic construction of a Global grid.  <a href="classTasGrid_1_1DynamicConstructorDataGlobal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTasGrid_1_1GpuEngine.html">GpuEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class around calls GPU accelerated linear algebra libraries.  <a href="structTasGrid_1_1GpuEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1GpuVector.html">GpuVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class that wraps around a single GPU array, providing functionality that mimics std::vector.  <a href="classTasGrid_1_1GpuVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTasGrid_1_1HandleDeleter.html">HandleDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleter template for the GPU handles, e.g., cuBlas and rocBlas.  <a href="structTasGrid_1_1HandleDeleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores multi-indexes in sorted (lexicographical) order.  <a href="classTasGrid_1_1MultiIndexSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTasGrid_1_1NodeData.html">NodeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the pair of point index and model value, the struct is used in a <b>std::forward_list</b>.  <a href="structTasGrid_1_1NodeData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1OneDimensionalWrapper.html">OneDimensionalWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to cache one dimensional rules, nodes, weight, meta-data, etc.  <a href="classTasGrid_1_1OneDimensionalWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTasGrid_1_1SimpleConstructData.html">SimpleConstructData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a std::forward_list of pairs of points indexes and values, and a <a class="el" href="classTasGrid_1_1MultiIndexSet.html" title="Class that stores multi-indexes in sorted (lexicographical) order.">MultiIndexSet</a> of initial nodes.  <a href="structTasGrid_1_1SimpleConstructData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1StorageSet.html">StorageSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that stores values, i.e., model outputs, the order of the values is in sync with the order of some <b><a class="el" href="classTasGrid_1_1MultiIndexSet.html" title="Class that stores multi-indexes in sorted (lexicographical) order.">MultiIndexSet</a></b>.  <a href="classTasGrid_1_1StorageSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TableGaussPatterson.html">TableGaussPatterson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule with hard-corded tabulated points and weights.  <a href="classTasGrid_1_1TableGaussPatterson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The master-class that represents an instance of a Tasmanian sparse grid.  <a href="classTasGrid_1_1TasmanianSparseGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTasGrid_1_1TensorData.html">TensorData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the description of a single tensor candidate for inclusion into the grid.  <a href="structTasGrid_1_1TensorData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1VectorToStreamBuffer.html">VectorToStreamBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coverts a vector to basic stream-buffer.  <a href="classTasGrid_1_1VectorToStreamBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a271a88d1068857a757811821acad9062" id="r_a271a88d1068857a757811821acad9062"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid.html#a271a88d1068857a757811821acad9062">int_gpu_lapack</a> = int</td></tr>
<tr class="memdesc:a271a88d1068857a757811821acad9062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the integer used by the LAPACK methods, usually int but DPC++ uses int64_t.  <br /></td></tr>
<tr class="separator:a271a88d1068857a757811821acad9062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18daa9a18e54407f6dfd5909274de6c9" id="r_ga18daa9a18e54407f6dfd5909274de6c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a> = std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y, size_t thread_id)&gt;</td></tr>
<tr class="memdesc:ga18daa9a18e54407f6dfd5909274de6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of a model function to be used in the construction procedures.  <br /></td></tr>
<tr class="separator:ga18daa9a18e54407f6dfd5909274de6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e2b2fa104542946ae93656b2cfe698" id="r_ga35e2b2fa104542946ae93656b2cfe698"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> = std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y)&gt;</td></tr>
<tr class="memdesc:ga35e2b2fa104542946ae93656b2cfe698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of a model function to be used in the MPI construction procedures.  <br /></td></tr>
<tr class="separator:ga35e2b2fa104542946ae93656b2cfe698"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3fb5157c08df3be790274a1fd4797b03" id="r_ga3fb5157c08df3be790274a1fd4797b03"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga3fb5157c08df3be790274a1fd4797b03">TypeIndexRelation</a> { <a class="el" href="group__SGEnumerates.html#gga3fb5157c08df3be790274a1fd4797b03a3eb44e742249543476989540b62af5a3">type_abeforeb</a>
, <a class="el" href="group__SGEnumerates.html#gga3fb5157c08df3be790274a1fd4797b03a965f57668df761cbb1d607e6a47704de">type_bbeforea</a>
, <a class="el" href="group__SGEnumerates.html#gga3fb5157c08df3be790274a1fd4797b03a5dc486f1ab0a095e77e6a85e78734666">type_asameb</a>
 }</td></tr>
<tr class="memdesc:ga3fb5157c08df3be790274a1fd4797b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the relation between two multi-indexes when compared during sorting.  <a href="group__SGEnumerates.html#ga3fb5157c08df3be790274a1fd4797b03">More...</a><br /></td></tr>
<tr class="separator:ga3fb5157c08df3be790274a1fd4797b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94134756077eff395566c64e6426455f" id="r_ga94134756077eff395566c64e6426455f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> { <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa72fded97960f7e090b1403ed2d01b790">type_none</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa6feeea3001da5a72dcf3602b9e3cfb0c">type_level</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa069fe8d0a40c574481e4789b9669fb04">type_curved</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa8dcb7523e6a608823c0afd448ac2e21e">type_hyperbolic</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">type_iptotal</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa383f228695e32d25b6b4d298b5ee55c8">type_qptotal</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455faf73c4f175fa56147e2ce42c169f450e1">type_ipcurved</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa66ffa652c94f7b1949380972395294e0">type_qpcurved</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455faabd7440eb86c1ae28dfda4dacf4479a1">type_iphyperbolic</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa6ffee71d521ab15a983c92cad37060ee">type_qphyperbolic</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fadb7975fabba0d6f63b7d00509e596123">type_tensor</a>
, <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa215db093a13c1a5e2768d277dddd5778">type_iptensor</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa830de3e55afd3399509d5edf7e3a60a6">type_qptensor</a>
<br />
 }</td></tr>
<tr class="memdesc:ga94134756077eff395566c64e6426455f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by Global Sequence and Fourier grids, indicates the selection criteria.  <a href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">More...</a><br /></td></tr>
<tr class="separator:ga94134756077eff395566c64e6426455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga145e27d5ae92acdd5f74149c6d4f2ca2" id="r_ga145e27d5ae92acdd5f74149c6d4f2ca2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> { <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aafe5a9e98c5e60a1cf580e61e54f22db">rule_none</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a7979fed9357e95bf01dc3169051f9fcf">rule_clenshawcurtis</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aaf84ed914bf71f1bd57a1888d4abd00a">rule_clenshawcurtis0</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a11001d1417caa84b4946aa042e78d953">rule_fejer2</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab0538d89ae16fccbbd0c546d6148f913">rule_chebyshev</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a2cf9d51120ca7132669f100fc19f4cad">rule_chebyshevodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">rule_leja</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ad21417c53c20d8c7ed2781c7d778d626">rule_lejaodd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67">rule_rleja</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2add4c0da371b3328de2b5aa9c0d78f356">rule_rlejadouble2</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2abaf13f719d258617bd1db267f7d81090">rule_rlejadouble4</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ad9eb31cd2ddc3a5b807db9f4946cbe99">rule_rlejaodd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab25addae4849761fabd0648c409e4fe0">rule_rlejashifted</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ade9f8d67ad4ee3a10694746daae35a4e">rule_rlejashiftedeven</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1993c6374109c34a09aaabb151b45a30">rule_rlejashifteddouble</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aae014e63a109512fecddb1a0b1a6443f">rule_maxlebesgue</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aad90e60b60d10ece133d91672c2a6d40">rule_maxlebesgueodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a013fec186e156860f5c89b56c18be6ca">rule_minlebesgue</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a333f195780c87bff6573f432c6fc2f39">rule_minlebesgueodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4f62c63dee6ab4c61c62ea4b179bb92c">rule_mindelta</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab956a3457075ae3dac6a1b55e9f82b9b">rule_mindeltaodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a0ffdbf062c3c6e6f546b99719c153813">rule_gausslegendre</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a40ba886acb7924987021756e388864b6">rule_gausslegendreodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae0ddcd23738e332619bc84102647c14c">rule_gausspatterson</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a474a0012b25fb9615d91201eb9c3d813">rule_gausschebyshev1</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab065e2757800e8faf5f8104cc59b88ee">rule_gausschebyshev1odd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab36508ddee56313531d08a0b2f875361">rule_gausschebyshev2</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a88b316c918d22ef5ea9d2eead1b445c3">rule_gausschebyshev2odd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a016bbf5f9c46bedb8a2957a88c1affc2">rule_gaussgegenbauer</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a655191cb6dcb11ec04e417a3e95c81d6">rule_gaussgegenbauerodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae857a1ff20402a00c130cbb119f030aa">rule_gaussjacobi</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2acb6535ae2d81e83d1163087da86e6357">rule_gaussjacobiodd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4a9504cb0e82ac9edf4b010303cd7a64">rule_gausslaguerre</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1b0686c22526434ed94fceb92c125ac5">rule_gausslaguerreodd</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a043726272ee899f7ef10961e90698c3c">rule_gausshermite</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a775cee952a979f569572d2bfa3ec3ecc">rule_gausshermiteodd</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a7597d0c89be786bb966355bc34b4e0f0">rule_customtabulated</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f">rule_localp</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab53ef82abdf78847f8422f0a17d7c28d">rule_localp0</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae337b4afeab83445025e17c5b5c50a4a">rule_semilocalp</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a6ca48da916fa34d52f234d007218d982">rule_localpb</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4abdeb519cfe0de36b03f1d75bb875a0">rule_wavelet</a>
, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab88eab2577ab9d7f1c0eae056ea012ae">rule_fourier</a>
<br />
 }</td></tr>
<tr class="memdesc:ga145e27d5ae92acdd5f74149c6d4f2ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify the one dimensional family of rules that induces the sparse grid.  <a href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">More...</a><br /></td></tr>
<tr class="separator:ga145e27d5ae92acdd5f74149c6d4f2ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac709fc494353223f300235750f8b96ed" id="r_gac709fc494353223f300235750f8b96ed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> { <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd">refine_classic</a>
, <a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda004bf7a9a0d0e7ed8aadba8062c653f4">refine_parents_first</a>
, <a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda8528073ff3d46cee384d8b4fa2db72ed">refine_direction_selective</a>
, <a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda939fdaecc186a219034e156eb8ace917">refine_fds</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96edac00c2b6dda342ab4e3c7b22bcca3755a">refine_stable</a>
, <a class="el" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda9df1c5dae76a52a2993bed6a84f4e2bc">refine_none</a>
<br />
 }</td></tr>
<tr class="memdesc:gac709fc494353223f300235750f8b96ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement strategy for local polynomial and wavelet grids.  <a href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">More...</a><br /></td></tr>
<tr class="separator:gac709fc494353223f300235750f8b96ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344ee5be5b77f2ff8e7c98f97ab40581" id="r_ga344ee5be5b77f2ff8e7c98f97ab40581"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> { <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766">accel_none</a>
, <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a4e99f4378b49ba22efd866d1eff3e689">accel_cpu_blas</a>
, <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a52e9ac2d8d5cb478c18e8f91e3ebaf7e">accel_gpu_default</a>
, <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581abff34d0602911ef3a29a952b793413d3">accel_gpu_cublas</a>
, <br />
&#160;&#160;<a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622">accel_gpu_cuda</a>
, <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581aac3a98fcec9c100e5422a7cd89e37269">accel_gpu_magma</a>
<br />
 }</td></tr>
<tr class="memdesc:ga344ee5be5b77f2ff8e7c98f97ab40581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modes of acceleration.  <a href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">More...</a><br /></td></tr>
<tr class="separator:ga344ee5be5b77f2ff8e7c98f97ab40581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0269d4c5c5352ef1f92cdde67b6ffcd7" id="r_ga0269d4c5c5352ef1f92cdde67b6ffcd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#ga0269d4c5c5352ef1f92cdde67b6ffcd7">makeEmpty</a> ()</td></tr>
<tr class="memdesc:ga0269d4c5c5352ef1f92cdde67b6ffcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an empty sparse grid.  <br /></td></tr>
<tr class="separator:ga0269d4c5c5352ef1f92cdde67b6ffcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga734013b4f52c4d1d9a35d674b459e13a" id="r_ga734013b4f52c4d1d9a35d674b459e13a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#ga734013b4f52c4d1d9a35d674b459e13a">makeGlobalGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), double alpha=0.0, double beta=0.0, const char *custom_filename=nullptr, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:ga734013b4f52c4d1d9a35d674b459e13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method, creates a new grid and calls <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">TasmanianSparseGrid::makeGlobalGrid()</a>.  <br /></td></tr>
<tr class="separator:ga734013b4f52c4d1d9a35d674b459e13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40cde16ae94c02a23271df606918cfb9" id="r_ga40cde16ae94c02a23271df606918cfb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#ga40cde16ae94c02a23271df606918cfb9">makeSequenceGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:ga40cde16ae94c02a23271df606918cfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method, creates a new grid and calls <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#add5d51d4a5cddb0753f8a38dee15fb18" title="Make Sequence Grid using Newton polynomials with support over the entire domain.">TasmanianSparseGrid::makeSequenceGrid()</a>.  <br /></td></tr>
<tr class="separator:ga40cde16ae94c02a23271df606918cfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa84e44ca8145727564dbb57e7c939a3" id="r_gaaa84e44ca8145727564dbb57e7c939a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">makeLocalPolynomialGrid</a> (int dimensions, int outputs, int depth, int order=1, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule=<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f">rule_localp</a>, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:gaaa84e44ca8145727564dbb57e7c939a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method, creates a new grid and calls <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aed3b81ba818620f88f7885186ec240a2" title="Make Local Polynomial Grid using piece-wise polynomials with decreasing (compact) support.">TasmanianSparseGrid::makeLocalPolynomialGrid()</a>.  <br /></td></tr>
<tr class="separator:gaaa84e44ca8145727564dbb57e7c939a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d644b025ba40d9dcfa6af96a0c7dad" id="r_ga39d644b025ba40d9dcfa6af96a0c7dad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#ga39d644b025ba40d9dcfa6af96a0c7dad">makeWaveletGrid</a> (int dimensions, int outputs, int depth, int order=1, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:ga39d644b025ba40d9dcfa6af96a0c7dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method, creates a new grid and calls <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b09ba463727decb5c96e4040393641" title="Make a Wavelet grid using local hierarchical wavelet basis.">TasmanianSparseGrid::makeWaveletGrid()</a>.  <br /></td></tr>
<tr class="separator:ga39d644b025ba40d9dcfa6af96a0c7dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946aedd76d776e8669671026911755d1" id="r_ga946aedd76d776e8669671026911755d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#ga946aedd76d776e8669671026911755d1">makeFourierGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:ga946aedd76d776e8669671026911755d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method, creates a new grid and calls <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2277a336a8e37728a61b5f2932487de2" title="Make a Fourier grid using trigonometric basis with support over the entire domain.">TasmanianSparseGrid::makeFourierGrid()</a>.  <br /></td></tr>
<tr class="separator:ga946aedd76d776e8669671026911755d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e2d073ce7e53d9b995be9550e320eb9" id="r_ga7e2d073ce7e53d9b995be9550e320eb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#ga7e2d073ce7e53d9b995be9550e320eb9">readGrid</a> (const char *filename)</td></tr>
<tr class="memdesc:ga7e2d073ce7e53d9b995be9550e320eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method, creates a new grid and calls <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abc8d795d4c836035770fb4aab7d94fac" title="Read the grid from the given filename, automatically detect the format.">TasmanianSparseGrid::read()</a>.  <br /></td></tr>
<tr class="separator:ga7e2d073ce7e53d9b995be9550e320eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35006357632e3764f8b00eb8ad5f5daa" id="r_ga35006357632e3764f8b00eb8ad5f5daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#ga35006357632e3764f8b00eb8ad5f5daa">readGrid</a> (std::string const &amp;filename)</td></tr>
<tr class="memdesc:ga35006357632e3764f8b00eb8ad5f5daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using std::string.  <br /></td></tr>
<tr class="separator:ga35006357632e3764f8b00eb8ad5f5daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7dff1a79964aa775e372b615e07ef44" id="r_gae7dff1a79964aa775e372b615e07ef44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSG.html#gae7dff1a79964aa775e372b615e07ef44">copyGrid</a> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;source, int outputs_begin=0, int outputs_end=-1)</td></tr>
<tr class="memdesc:gae7dff1a79964aa775e372b615e07ef44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a grid that is a copy of the source.  <br /></td></tr>
<tr class="separator:gae7dff1a79964aa775e372b615e07ef44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a73bd8d204c43d43760e8983a91c838" id="r_ga6a73bd8d204c43d43760e8983a91c838"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6a73bd8d204c43d43760e8983a91c838"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianSets.html#ga6a73bd8d204c43d43760e8983a91c838">spltVector2D</a> (std::vector&lt; T &gt; const &amp;x, size_t stride, int ibegin, int iend)</td></tr>
<tr class="memdesc:ga6a73bd8d204c43d43760e8983a91c838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a vector logically organized into stips and strides and extract a sub-strip from every strip.  <br /></td></tr>
<tr class="separator:ga6a73bd8d204c43d43760e8983a91c838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7fc50157cfb3edd7fa9bd3bee442e85" id="r_gaf7fc50157cfb3edd7fa9bd3bee442e85"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:gaf7fc50157cfb3edd7fa9bd3bee442e85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#gaf7fc50157cfb3edd7fa9bd3bee442e85">deleteHandle</a> (int *)</td></tr>
<tr class="memdesc:gaf7fc50157cfb3edd7fa9bd3bee442e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the handle, specialized for each TPL backend and tag in <a class="el" href="namespaceTasGrid_1_1AccHandle.html" title="Type tags for the different handle types.">TasGrid::AccHandle</a> namepace.  <br /></td></tr>
<tr class="separator:gaf7fc50157cfb3edd7fa9bd3bee442e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a31c7d2ea2d3262ccdd3a24d3516f9" id="r_ga44a31c7d2ea2d3262ccdd3a24d3516f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1CustomTabulated.html">CustomTabulated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianCoreOneDimensional.html#ga44a31c7d2ea2d3262ccdd3a24d3516f9">getSubrules</a> (<a class="el" href="classTasGrid_1_1CustomTabulated.html">CustomTabulated</a> &amp;ct, int start_index, int stride, std::string description)</td></tr>
<tr class="memdesc:ga44a31c7d2ea2d3262ccdd3a24d3516f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a subset of rules as a <a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">CustomTabulated</a> object. The subset has a short description string given by <b>description</b> and takes the levels of the input <b>ct</b> starting from level <b>start_index</b> with distance <b>stride</b> between consecutive levels.  <br /></td></tr>
<tr class="separator:ga44a31c7d2ea2d3262ccdd3a24d3516f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3cde70f95ccf0e314d6e0a9cf916b3" id="r_ga0d3cde70f95ccf0e314d6e0a9cf916b3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0d3cde70f95ccf0e314d6e0a9cf916b3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianRefinement.html#ga0d3cde70f95ccf0e314d6e0a9cf916b3">makeReverseReferenceVector</a> (const std::forward_list&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:ga0d3cde70f95ccf0e314d6e0a9cf916b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a list and creates a vector of references in reversed order, needed for I/O so that read can be followed by push_front. .  <br /></td></tr>
<tr class="separator:ga0d3cde70f95ccf0e314d6e0a9cf916b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e552089ea0d45ea0f49964a0712b29" id="r_gac4e552089ea0d45ea0f49964a0712b29"><td class="memTemplParams" colspan="2">template&lt;bool use_ascii&gt; </td></tr>
<tr class="memitem:gac4e552089ea0d45ea0f49964a0712b29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianRefinement.html#gac4e552089ea0d45ea0f49964a0712b29">writeNodeDataList</a> (const std::forward_list&lt; <a class="el" href="structTasGrid_1_1NodeData.html">NodeData</a> &gt; &amp;data, std::ostream &amp;os)</td></tr>
<tr class="memdesc:gac4e552089ea0d45ea0f49964a0712b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="structTasGrid_1_1NodeData.html" title="Holds the pair of point index and model value, the struct is used in a std::forward_list.">NodeData</a> std::forward_list to a file using either binary or ascii format. .  <br /></td></tr>
<tr class="separator:gac4e552089ea0d45ea0f49964a0712b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bebde03c4c3d4db72e977fd19b2b328" id="r_ga1bebde03c4c3d4db72e977fd19b2b328"><td class="memTemplParams" colspan="2">template&lt;typename iomode &gt; </td></tr>
<tr class="memitem:ga1bebde03c4c3d4db72e977fd19b2b328"><td class="memTemplItemLeft" align="right" valign="top">std::forward_list&lt; <a class="el" href="structTasGrid_1_1NodeData.html">NodeData</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianRefinement.html#ga1bebde03c4c3d4db72e977fd19b2b328">readNodeDataList</a> (std::istream &amp;is, size_t num_dimensions, size_t num_outputs)</td></tr>
<tr class="memdesc:ga1bebde03c4c3d4db72e977fd19b2b328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="structTasGrid_1_1NodeData.html" title="Holds the pair of point index and model value, the struct is used in a std::forward_list.">NodeData</a> std::forward_list from a file using either binary or ascii format. .  <br /></td></tr>
<tr class="separator:ga1bebde03c4c3d4db72e977fd19b2b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2fb8e9c5fc6adbac291d05918ee6f30" id="r_gaf2fb8e9c5fc6adbac291d05918ee6f30"><td class="memTemplParams" colspan="2">template&lt;typename iomode &gt; </td></tr>
<tr class="memitem:gaf2fb8e9c5fc6adbac291d05918ee6f30"><td class="memTemplItemLeft" align="right" valign="top">std::forward_list&lt; <a class="el" href="structTasGrid_1_1TensorData.html">TensorData</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianRefinement.html#gaf2fb8e9c5fc6adbac291d05918ee6f30">readTensorDataList</a> (std::istream &amp;is, size_t num_dimensions)</td></tr>
<tr class="memdesc:gaf2fb8e9c5fc6adbac291d05918ee6f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="structTasGrid_1_1TensorData.html" title="Holds the description of a single tensor candidate for inclusion into the grid.">TensorData</a> std::forward_list from a file using either binary or ascii format.  <br /></td></tr>
<tr class="separator:gaf2fb8e9c5fc6adbac291d05918ee6f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdc31d93cae539cd0db0fa42717771e" id="r_ga7fdc31d93cae539cd0db0fa42717771e"><td class="memTemplParams" colspan="2">template&lt;class RuleLike &gt; </td></tr>
<tr class="memitem:ga7fdc31d93cae539cd0db0fa42717771e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianRefinement.html#ga7fdc31d93cae539cd0db0fa42717771e">listToNodes</a> (std::forward_list&lt; <a class="el" href="structTasGrid_1_1NodeData.html">NodeData</a> &gt; const &amp;node_list, size_t num_dimensions, RuleLike const &amp;rule)</td></tr>
<tr class="memdesc:ga7fdc31d93cae539cd0db0fa42717771e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using <a class="el" href="group__TasmanianMultiIndexManipulations.html#ga36bc18ce85c328997b40051292cd3966" title="Converts int-indexes to double-valued abscissas using the provided rule.">MultiIndexManipulations::indexesToNodes()</a> convert the <b>node_list</b> to actual points according to the rule.  <br /></td></tr>
<tr class="separator:ga7fdc31d93cae539cd0db0fa42717771e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1098f3a10a395577fa28a18d69dfab4" id="r_gae1098f3a10a395577fa28a18d69dfab4"><td class="memTemplParams" colspan="2">template&lt;typename callable_method &gt; </td></tr>
<tr class="memitem:gae1098f3a10a395577fa28a18d69dfab4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianRefinement.html#gae1098f3a10a395577fa28a18d69dfab4">listToLocalNodes</a> (std::forward_list&lt; <a class="el" href="structTasGrid_1_1NodeData.html">NodeData</a> &gt; const &amp;node_list, size_t num_dimensions, callable_method rule)</td></tr>
<tr class="memdesc:gae1098f3a10a395577fa28a18d69dfab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using <a class="el" href="group__TasmanianMultiIndexManipulations.html#ga36bc18ce85c328997b40051292cd3966" title="Converts int-indexes to double-valued abscissas using the provided rule.">MultiIndexManipulations::indexesToNodes()</a> convert the <b>node_list</b> to actual points according to the rule.  <br /></td></tr>
<tr class="separator:gae1098f3a10a395577fa28a18d69dfab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f15829a6b9b13a62e90cbc6ca8740f" id="r_gad9f15829a6b9b13a62e90cbc6ca8740f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#gad9f15829a6b9b13a62e90cbc6ca8740f">poly_eval</a> (const std::vector&lt; double &gt; &amp;roots, double x)</td></tr>
<tr class="memdesc:gad9f15829a6b9b13a62e90cbc6ca8740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a polynomial with roots given by <b>roots</b> at the point <b>x</b>.  <br /></td></tr>
<tr class="separator:gad9f15829a6b9b13a62e90cbc6ca8740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3102cd0928f73082d0c1cbf533ca5cfc" id="r_ga3102cd0928f73082d0c1cbf533ca5cfc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga3102cd0928f73082d0c1cbf533ca5cfc">lagrange_eval</a> (size_t idx, const std::vector&lt; double &gt; &amp;roots, double x)</td></tr>
<tr class="memdesc:ga3102cd0928f73082d0c1cbf533ca5cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a Lagrange basis polynomial at a point <b>x</b>.  <br /></td></tr>
<tr class="separator:ga3102cd0928f73082d0c1cbf533ca5cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4591280048835a763f665137aefad5" id="r_gabf4591280048835a763f665137aefad5"><td class="memTemplParams" colspan="2">template&lt;bool is_symmetric&gt; </td></tr>
<tr class="memitem:gabf4591280048835a763f665137aefad5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#gabf4591280048835a763f665137aefad5">getGaussNodesAndWeights</a> (const int n, const std::vector&lt; double &gt; &amp;ref_points, const std::vector&lt; double &gt; &amp;ref_weights, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;points_cache, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;weights_cache)</td></tr>
<tr class="memdesc:gabf4591280048835a763f665137aefad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates n levels of points and weights using orthogonal polynomials with respect to ref_points and ref_weights.  <br /></td></tr>
<tr class="separator:gabf4591280048835a763f665137aefad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9baa7cec8f4096683e6f17b2c4aa1f88" id="r_ga9baa7cec8f4096683e6f17b2c4aa1f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga9baa7cec8f4096683e6f17b2c4aa1f88">getShiftedExoticQuadrature</a> (const int n, const double shift, const std::vector&lt; double &gt; &amp;shifted_weights, const std::vector&lt; double &gt; &amp;ref_points, const char *description, const bool is_symmetric=false)</td></tr>
<tr class="memdesc:ga9baa7cec8f4096683e6f17b2c4aa1f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the exotic quadrature points and weights and load them into a <a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">TasGrid::CustomTabulated</a> object.  <br /></td></tr>
<tr class="separator:ga9baa7cec8f4096683e6f17b2c4aa1f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5740bba8e7517b684377786bad6a4bff" id="r_ga5740bba8e7517b684377786bad6a4bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga5740bba8e7517b684377786bad6a4bff">shiftReferenceWeights</a> (std::vector&lt; double &gt; const &amp;vals, double shift, std::vector&lt; double &gt; &amp;ref_weights)</td></tr>
<tr class="memdesc:ga5740bba8e7517b684377786bad6a4bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the reference quadrature weights by the shifted values of the weight function.  <br /></td></tr>
<tr class="separator:ga5740bba8e7517b684377786bad6a4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cfd0f3dda72fcacc6288ddae24e2d19" id="r_ga2cfd0f3dda72fcacc6288ddae24e2d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga2cfd0f3dda72fcacc6288ddae24e2d19">getExoticQuadrature</a> (const int num_levels, const double shift, const <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a> &amp;grid, const char *description, const bool is_symmetric=false)</td></tr>
<tr class="memdesc:ga2cfd0f3dda72fcacc6288ddae24e2d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an exotic quadrature from a sparse grid object.  <br /></td></tr>
<tr class="separator:ga2cfd0f3dda72fcacc6288ddae24e2d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61aaac9fcfbb38c259453c3029f20cc0" id="r_ga61aaac9fcfbb38c259453c3029f20cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1CustomTabulated.html">TasGrid::CustomTabulated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsExoticQuad.html#ga61aaac9fcfbb38c259453c3029f20cc0">getExoticQuadrature</a> (const int num_levels, const double shift, std::function&lt; double(double)&gt; weight_fn, const int num_ref_points, const char *description, const bool is_symmetric=false)</td></tr>
<tr class="memdesc:ga61aaac9fcfbb38c259453c3029f20cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__TasmanianAddonsExoticQuad.html#ga2cfd0f3dda72fcacc6288ddae24e2d19" title="Constructs an exotic quadrature from a sparse grid object.">getExoticQuadrature()</a> but the weight function is defined by a lambda expression.  <br /></td></tr>
<tr class="separator:ga61aaac9fcfbb38c259453c3029f20cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5eb5ddb0221bfa1bc22450767be16d" id="r_ga6a5eb5ddb0221bfa1bc22450767be16d"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction, bool use_initial_guess&gt; </td></tr>
<tr class="memitem:ga6a5eb5ddb0221bfa1bc22450767be16d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#ga6a5eb5ddb0221bfa1bc22450767be16d">constructCommon</a> (<a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a> model, size_t max_num_points, size_t num_parallel_jobs, size_t max_samples_per_job, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, std::function&lt; std::vector&lt; double &gt;(<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;)&gt; candidates, std::string const &amp;checkpoint_filename)</td></tr>
<tr class="memdesc:ga6a5eb5ddb0221bfa1bc22450767be16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction algorithm using generic candidates procedure.  <br /></td></tr>
<tr class="separator:ga6a5eb5ddb0221bfa1bc22450767be16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868eb3d17df0eefb438376c92002b8de" id="r_ga868eb3d17df0eefb438376c92002b8de"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga868eb3d17df0eefb438376c92002b8de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de">constructSurrogate</a> (<a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a> model, size_t max_num_points, size_t num_parallel_jobs, size_t max_samples_per_job, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, double tolerance, <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> criteria, int output=-1, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:ga868eb3d17df0eefb438376c92002b8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda.  <br /></td></tr>
<tr class="separator:ga868eb3d17df0eefb438376c92002b8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0788f48fb2593d686d3b2173f5821f0" id="r_gac0788f48fb2593d686d3b2173f5821f0"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:gac0788f48fb2593d686d3b2173f5821f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#gac0788f48fb2593d686d3b2173f5821f0">constructSurrogate</a> (<a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a> model, size_t max_num_points, size_t num_parallel_jobs, size_t max_samples_per_job, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:gac0788f48fb2593d686d3b2173f5821f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda.  <br /></td></tr>
<tr class="separator:gac0788f48fb2593d686d3b2173f5821f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ed57c25a9f903ce06604091bd1fe500" id="r_ga4ed57c25a9f903ce06604091bd1fe500"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga4ed57c25a9f903ce06604091bd1fe500"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#ga4ed57c25a9f903ce06604091bd1fe500">constructSurrogate</a> (<a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a> model, size_t max_num_points, size_t num_parallel_jobs, size_t max_samples_per_job, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int output, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:ga4ed57c25a9f903ce06604091bd1fe500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda.  <br /></td></tr>
<tr class="separator:ga4ed57c25a9f903ce06604091bd1fe500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe0495b6cefaafd2df73884ddd4f406e" id="r_gabe0495b6cefaafd2df73884ddd4f406e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#gabe0495b6cefaafd2df73884ddd4f406e">hasGPUBasis</a> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;grid)</td></tr>
<tr class="memdesc:gabe0495b6cefaafd2df73884ddd4f406e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the grid has a GPU algorithm for computing the hierarchical basis.  <br /></td></tr>
<tr class="separator:gabe0495b6cefaafd2df73884ddd4f406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0005385aef9c60db6f3aef3128d20acf" id="r_ga0005385aef9c60db6f3aef3128d20acf"><td class="memTemplParams" colspan="2">template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:ga0005385aef9c60db6f3aef3128d20acf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#ga0005385aef9c60db6f3aef3128d20acf">generateCoefficientsGPU</a> (double const data_points[], int num_data, scalar_type model_values[], double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:ga0005385aef9c60db6f3aef3128d20acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the coefficients and solves the least-squares problem.  <br /></td></tr>
<tr class="separator:ga0005385aef9c60db6f3aef3128d20acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f54cda879b13547eb8bafe9454a4d0e" id="r_ga8f54cda879b13547eb8bafe9454a4d0e"><td class="memTemplParams" colspan="2">template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:ga8f54cda879b13547eb8bafe9454a4d0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#ga8f54cda879b13547eb8bafe9454a4d0e">generateCoefficients</a> (double const data_points[], int num_data, double const model_values[], double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:ga8f54cda879b13547eb8bafe9454a4d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the coefficients and solves the least-squares problem.  <br /></td></tr>
<tr class="separator:ga8f54cda879b13547eb8bafe9454a4d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478a4f8551e93cb64540567b50e03a02" id="r_ga478a4f8551e93cb64540567b50e03a02"><td class="memTemplParams" colspan="2">template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:ga478a4f8551e93cb64540567b50e03a02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#ga478a4f8551e93cb64540567b50e03a02">loadUnstructuredDataL2tmpl</a> (double const data_points[], int num_data, double const model_values[], double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:ga478a4f8551e93cb64540567b50e03a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template implementation that handles the case of Fourier grids vs. all other types.  <br /></td></tr>
<tr class="separator:ga478a4f8551e93cb64540567b50e03a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cc3abfc7b72c6258932ea149f11adf" id="r_gaf6cc3abfc7b72c6258932ea149f11adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#gaf6cc3abfc7b72c6258932ea149f11adf">loadUnstructuredDataL2</a> (double const data_points[], int num_data, double const model_values[], double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:gaf6cc3abfc7b72c6258932ea149f11adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate using a least-squares fit.  <br /></td></tr>
<tr class="separator:gaf6cc3abfc7b72c6258932ea149f11adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103f434b565f3f81a7d750d9fc57a1eb" id="r_ga103f434b565f3f81a7d750d9fc57a1eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadUnstructured.html#ga103f434b565f3f81a7d750d9fc57a1eb">loadUnstructuredDataL2</a> (std::vector&lt; double &gt; const &amp;data_points, std::vector&lt; double &gt; const &amp;model_values, double tolerance, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid)</td></tr>
<tr class="memdesc:ga103f434b565f3f81a7d750d9fc57a1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that used vectors and infers the number of data points from the size of the vectors.  <br /></td></tr>
<tr class="separator:ga103f434b565f3f81a7d750d9fc57a1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab21892689b6328817e2196142c38027" id="r_gaab21892689b6328817e2196142c38027"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess&gt; </td></tr>
<tr class="memitem:gaab21892689b6328817e2196142c38027"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#gaab21892689b6328817e2196142c38027">mpiConstructCommon</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_num_points, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, std::function&lt; std::vector&lt; double &gt;(<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;)&gt; candidates, std::string const &amp;checkpoint_filename)</td></tr>
<tr class="memdesc:gaab21892689b6328817e2196142c38027"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI construction algorithm using generic candidates procedure.  <br /></td></tr>
<tr class="separator:gaab21892689b6328817e2196142c38027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga959c5c21a2c9bffd485ac75f7098eafb" id="r_ga959c5c21a2c9bffd485ac75f7098eafb"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga959c5c21a2c9bffd485ac75f7098eafb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb">mpiConstructSurrogate</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_num_points, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, double tolerance, <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> criteria, int output=-1, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::vector&lt; double &gt; const &amp;scale_correction=std::vector&lt; double &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:ga959c5c21a2c9bffd485ac75f7098eafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda, MPI version.  <br /></td></tr>
<tr class="separator:ga959c5c21a2c9bffd485ac75f7098eafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec04bf28521616e8082a73bb6c6baa2" id="r_gaeec04bf28521616e8082a73bb6c6baa2"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:gaeec04bf28521616e8082a73bb6c6baa2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#gaeec04bf28521616e8082a73bb6c6baa2">mpiConstructSurrogate</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_num_points, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:gaeec04bf28521616e8082a73bb6c6baa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda, MPI version.  <br /></td></tr>
<tr class="separator:gaeec04bf28521616e8082a73bb6c6baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bef49fcf53bfe96df8fb433e3cf4cc7" id="r_ga8bef49fcf53bfe96df8fb433e3cf4cc7"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga8bef49fcf53bfe96df8fb433e3cf4cc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga8bef49fcf53bfe96df8fb433e3cf4cc7">mpiConstructSurrogate</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_num_points, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int output, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:ga8bef49fcf53bfe96df8fb433e3cf4cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda, MPI version.  <br /></td></tr>
<tr class="separator:ga8bef49fcf53bfe96df8fb433e3cf4cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0472ab32a5ad7ee714ba5539db592932" id="r_ga0472ab32a5ad7ee714ba5539db592932"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga0472ab32a5ad7ee714ba5539db592932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga0472ab32a5ad7ee714ba5539db592932">mpiConstructWorker</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm)</td></tr>
<tr class="memdesc:ga0472ab32a5ad7ee714ba5539db592932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the worker (i.e., non-root) portion of the MPI sampling.  <br /></td></tr>
<tr class="separator:ga0472ab32a5ad7ee714ba5539db592932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e863853775678e8268c203e1856e187" id="r_ga8e863853775678e8268c203e1856e187"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIGridSend.html#ga8e863853775678e8268c203e1856e187">getMPIRank</a> (MPI_Comm comm)</td></tr>
<tr class="memdesc:ga8e863853775678e8268c203e1856e187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to return the rank within the given comm.  <br /></td></tr>
<tr class="separator:ga8e863853775678e8268c203e1856e187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81fed6fbf2fd899aca4922646d2566d1" id="r_ga81fed6fbf2fd899aca4922646d2566d1"><td class="memTemplParams" colspan="2">template&lt;bool binary = TasGrid::mode_binary&gt; </td></tr>
<tr class="memitem:ga81fed6fbf2fd899aca4922646d2566d1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIGridSend.html#ga81fed6fbf2fd899aca4922646d2566d1">MPIGridSend</a> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;grid, int destination, int tag, MPI_Comm comm)</td></tr>
<tr class="memdesc:ga81fed6fbf2fd899aca4922646d2566d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a grid to another process in the MPI comm.  <br /></td></tr>
<tr class="separator:ga81fed6fbf2fd899aca4922646d2566d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5edceb66897460e5b9e104b624877cfc" id="r_ga5edceb66897460e5b9e104b624877cfc"><td class="memTemplParams" colspan="2">template&lt;bool binary = TasGrid::mode_binary&gt; </td></tr>
<tr class="memitem:ga5edceb66897460e5b9e104b624877cfc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIGridSend.html#ga5edceb66897460e5b9e104b624877cfc">MPIGridRecv</a> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, int source, int tag, MPI_Comm comm, MPI_Status *status=MPI_STATUS_IGNORE)</td></tr>
<tr class="memdesc:ga5edceb66897460e5b9e104b624877cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a grid from another process in the MPI comm.  <br /></td></tr>
<tr class="separator:ga5edceb66897460e5b9e104b624877cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d57c01914cb9fc7b4b4719e242430b" id="r_gab9d57c01914cb9fc7b4b4719e242430b"><td class="memTemplParams" colspan="2">template&lt;bool binary = TasGrid::mode_binary&gt; </td></tr>
<tr class="memitem:gab9d57c01914cb9fc7b4b4719e242430b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIGridSend.html#gab9d57c01914cb9fc7b4b4719e242430b">MPIGridBcast</a> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, int root, MPI_Comm comm)</td></tr>
<tr class="memdesc:gab9d57c01914cb9fc7b4b4719e242430b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a grid to all processes in an MPI comm.  <br /></td></tr>
<tr class="separator:gab9d57c01914cb9fc7b4b4719e242430b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ebaf3d88e250fb6a08f8659e8b2a91" id="r_ga11ebaf3d88e250fb6a08f8659e8b2a91"><td class="memTemplParams" colspan="2">template&lt;bool binary = TasGrid::mode_binary&gt; </td></tr>
<tr class="memitem:ga11ebaf3d88e250fb6a08f8659e8b2a91"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIGridSend.html#ga11ebaf3d88e250fb6a08f8659e8b2a91">MPIGridScatterOutputs</a> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;source, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;destination, int root, int tag, MPI_Comm comm)</td></tr>
<tr class="memdesc:ga11ebaf3d88e250fb6a08f8659e8b2a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the grid across the comm where each rank receives an equal portion of the total outputs.  <br /></td></tr>
<tr class="separator:ga11ebaf3d88e250fb6a08f8659e8b2a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad239942d20e99244061b4886f96dea4a" id="r_gad239942d20e99244061b4886f96dea4a"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </td></tr>
<tr class="memitem:gad239942d20e99244061b4886f96dea4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a">loadNeededValues</a> (std::function&lt; void(double const x[], double y[], size_t thread_id)&gt; model, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, size_t num_threads)</td></tr>
<tr class="memdesc:gad239942d20e99244061b4886f96dea4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the current grid with model values, does not perform any refinement.  <br /></td></tr>
<tr class="separator:gad239942d20e99244061b4886f96dea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91382894cb86187d4a043af2f0d3c5c0" id="r_ga91382894cb86187d4a043af2f0d3c5c0"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </td></tr>
<tr class="memitem:ga91382894cb86187d4a043af2f0d3c5c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsLoadNeededVals.html#ga91382894cb86187d4a043af2f0d3c5c0">loadNeededValues</a> (std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y, size_t thread_id)&gt; model, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, size_t num_threads)</td></tr>
<tr class="memdesc:ga91382894cb86187d4a043af2f0d3c5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses vectors for the model inputs and outputs.  <br /></td></tr>
<tr class="separator:ga91382894cb86187d4a043af2f0d3c5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49a95d0766243ba2d5d1a8f10dedb15" id="r_gad49a95d0766243ba2d5d1a8f10dedb15"><td class="memTemplParams" colspan="2">
template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </td></tr>
<tr class="memitem:gad49a95d0766243ba2d5d1a8f10dedb15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>loadNeededPoints</b> (std::function&lt; void(double const x[], double y[], size_t thread_id)&gt; model, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, size_t num_threads)</td></tr>
<tr class="memdesc:gad49a95d0766243ba2d5d1a8f10dedb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a" title="Loads the current grid with model values, does not perform any refinement.">loadNeededValues()</a>, array variant. <br /></td></tr>
<tr class="separator:gad49a95d0766243ba2d5d1a8f10dedb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765e36b8991244a94e3e57f48dcce874" id="r_ga765e36b8991244a94e3e57f48dcce874"><td class="memTemplParams" colspan="2">
template&lt;bool parallel_construction = true, bool overwrite_loaded = false&gt; </td></tr>
<tr class="memitem:ga765e36b8991244a94e3e57f48dcce874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>loadNeededPoints</b> (std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y, size_t thread_id)&gt; model, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, size_t num_threads)</td></tr>
<tr class="memdesc:ga765e36b8991244a94e3e57f48dcce874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a" title="Loads the current grid with model values, does not perform any refinement.">loadNeededValues()</a>, vector variant. <br /></td></tr>
<tr class="separator:ga765e36b8991244a94e3e57f48dcce874"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2cf8d40703b53868f4bfa0ad89fe3e30" id="r_ga2cf8d40703b53868f4bfa0ad89fe3e30"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>accel_gpu_hip</b> = <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622">accel_gpu_cuda</a></td></tr>
<tr class="memdesc:ga2cf8d40703b53868f4bfa0ad89fe3e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">At the front API, the HIP and CUDA options are equivalent, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a>. <br /></td></tr>
<tr class="separator:ga2cf8d40703b53868f4bfa0ad89fe3e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1505678eb06b0396c979ac4b77d82857" id="r_ga1505678eb06b0396c979ac4b77d82857"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>accel_gpu_rocblas</b> = <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581abff34d0602911ef3a29a952b793413d3">accel_gpu_cublas</a></td></tr>
<tr class="memdesc:ga1505678eb06b0396c979ac4b77d82857"><td class="mdescLeft">&#160;</td><td class="mdescRight">At the front API, the HIP and CUDA options are equivalent, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a>. <br /></td></tr>
<tr class="separator:ga1505678eb06b0396c979ac4b77d82857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade99cdabcb4650a230ac1ef8c9ae1e22" id="r_gade99cdabcb4650a230ac1ef8c9ae1e22"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>mode_ascii</b> = false</td></tr>
<tr class="memdesc:gade99cdabcb4650a230ac1ef8c9ae1e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant allowing for more expressive selection of ascii and binary mode in <a class="el" href="namespaceTasGrid_1_1IO.html" title="Collection of I/O handling templates.">IO</a> methods. <br /></td></tr>
<tr class="separator:gade99cdabcb4650a230ac1ef8c9ae1e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25913c6e0ddb0f1ef4a70c9c8cddc5b" id="r_gab25913c6e0ddb0f1ef4a70c9c8cddc5b"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>mode_binary</b> = true</td></tr>
<tr class="memdesc:gab25913c6e0ddb0f1ef4a70c9c8cddc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant allowing for more expressive selection of ascii and binary mode in <a class="el" href="namespaceTasGrid_1_1IO.html" title="Collection of I/O handling templates.">IO</a> methods. <br /></td></tr>
<tr class="separator:gab25913c6e0ddb0f1ef4a70c9c8cddc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8066806409c50730ab7c7843643912" id="r_ga3c8066806409c50730ab7c7843643912"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>mode_parallel</b> = true</td></tr>
<tr class="memdesc:ga3c8066806409c50730ab7c7843643912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. <br /></td></tr>
<tr class="separator:ga3c8066806409c50730ab7c7843643912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3bad3a625ef67b3daacad075f9ef730" id="r_gab3bad3a625ef67b3daacad075f9ef730"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>mode_sequential</b> = false</td></tr>
<tr class="memdesc:gab3bad3a625ef67b3daacad075f9ef730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. <br /></td></tr>
<tr class="separator:gab3bad3a625ef67b3daacad075f9ef730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59a05cea9ff38590c1c81e3c05a06dc2" id="r_ga59a05cea9ff38590c1c81e3c05a06dc2"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>with_initial_guess</b> = true</td></tr>
<tr class="memdesc:ga59a05cea9ff38590c1c81e3c05a06dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. <br /></td></tr>
<tr class="separator:ga59a05cea9ff38590c1c81e3c05a06dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24a8f8d52cd2c6fb54f6f21c4389a7f" id="r_gae24a8f8d52cd2c6fb54f6f21c4389a7f"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>no_initial_guess</b> = false</td></tr>
<tr class="memdesc:gae24a8f8d52cd2c6fb54f6f21c4389a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. <br /></td></tr>
<tr class="separator:gae24a8f8d52cd2c6fb54f6f21c4389a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates the Tasmanian Sparse Grid module. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a271a88d1068857a757811821acad9062" name="a271a88d1068857a757811821acad9062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271a88d1068857a757811821acad9062">&#9670;&#160;</a></span>int_gpu_lapack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceTasGrid.html#a271a88d1068857a757811821acad9062">TasGrid::int_gpu_lapack</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the integer used by the LAPACK methods, usually int but DPC++ uses int64_t. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="navelem"><a class="el" href="namespaceTasGrid.html">TasGrid</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
