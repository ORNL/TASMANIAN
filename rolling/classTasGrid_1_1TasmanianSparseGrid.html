<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: TasGrid::TasmanianSparseGrid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classTasGrid_1_1TasmanianSparseGrid.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classTasGrid_1_1TasmanianSparseGrid-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TasGrid::TasmanianSparseGrid Class Reference<div class="ingroups"><a class="el" href="group__TasmanianSG.html">Sparse Grids</a> &raquo; <a class="el" href="group__TasmanianSGClass.html">Sparse Grid Class</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The master-class that represents an instance of a Tasmanian sparse grid.  
 <a href="classTasGrid_1_1TasmanianSparseGrid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TasmanianSparseGrid_8hpp_source.html">TasmanianSparseGrid.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a75802ac3fa6495ad9ca2f8063c0d7464" id="r_a75802ac3fa6495ad9ca2f8063c0d7464"><td class="memItemLeft" align="right" valign="top"><a id="a75802ac3fa6495ad9ca2f8063c0d7464" name="a75802ac3fa6495ad9ca2f8063c0d7464"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EvaluateCallable</b> = std::function&lt; void(std::vector&lt; double &gt; const  &amp;, std::vector&lt; double &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:a75802ac3fa6495ad9ca2f8063c0d7464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature compatible with <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90" title="Generic probability distribution used by Tasmanian.">TasDREAM::DreamPDF</a>, <a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d" title="Generic model signature used by Tasmanian.">TasDREAM::DreamModel</a> amd <a class="el" href="group__DREAMSampleCore.html#ga1aaf27a3d3639c0f0cdf270af1f45c22" title="Generic signature for a combination of a likelihood and a model.">TasDREAM::DreamMergedLikelyModel</a>. <br /></td></tr>
<tr class="separator:a75802ac3fa6495ad9ca2f8063c0d7464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f55726763394dda700d6efa5f9f68b" id="r_ae7f55726763394dda700d6efa5f9f68b"><td class="memItemLeft" align="right" valign="top"><a id="ae7f55726763394dda700d6efa5f9f68b" name="ae7f55726763394dda700d6efa5f9f68b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DomainInsideSignature</b> = std::function&lt; bool(std::vector&lt; double &gt; const &amp;)&gt;</td></tr>
<tr class="memdesc:ae7f55726763394dda700d6efa5f9f68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of the domain inside lambda, identical to <a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f" title="Generic test function whether a sample belongs in the domain.">TasDREAM::DreamDomain</a>. <br /></td></tr>
<tr class="separator:ae7f55726763394dda700d6efa5f9f68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbcd3b1ae00aadc8107afd7d7c1bb1ac" id="r_adbcd3b1ae00aadc8107afd7d7c1bb1ac"><td class="memItemLeft" align="right" valign="top"><a id="adbcd3b1ae00aadc8107afd7d7c1bb1ac" name="adbcd3b1ae00aadc8107afd7d7c1bb1ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TasmanianSparseGrid</b> ()</td></tr>
<tr class="memdesc:adbcd3b1ae00aadc8107afd7d7c1bb1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, creates and empty grid. <br /></td></tr>
<tr class="separator:adbcd3b1ae00aadc8107afd7d7c1bb1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839076e97103cf3b785d34ed89c1cece" id="r_a839076e97103cf3b785d34ed89c1cece"><td class="memItemLeft" align="right" valign="top"><a id="a839076e97103cf3b785d34ed89c1cece" name="a839076e97103cf3b785d34ed89c1cece"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TasmanianSparseGrid</b> (const <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;source)</td></tr>
<tr class="memdesc:a839076e97103cf3b785d34ed89c1cece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, note that the selected acceleration mode is not copied, acceleration is reset to the default. <br /></td></tr>
<tr class="separator:a839076e97103cf3b785d34ed89c1cece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48aac8e64807219e6268f905180e89f" id="r_ae48aac8e64807219e6268f905180e89f"><td class="memItemLeft" align="right" valign="top"><a id="ae48aac8e64807219e6268f905180e89f" name="ae48aac8e64807219e6268f905180e89f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TasmanianSparseGrid</b> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&amp;source)=default</td></tr>
<tr class="memdesc:ae48aac8e64807219e6268f905180e89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor, the selected acceleration mode is also carried over. <br /></td></tr>
<tr class="separator:ae48aac8e64807219e6268f905180e89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db3e53f157c60878052dc920dc98d3f" id="r_a4db3e53f157c60878052dc920dc98d3f"><td class="memItemLeft" align="right" valign="top"><a id="a4db3e53f157c60878052dc920dc98d3f" name="a4db3e53f157c60878052dc920dc98d3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~TasmanianSparseGrid</b> ()=default</td></tr>
<tr class="memdesc:a4db3e53f157c60878052dc920dc98d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, releases all resources. <br /></td></tr>
<tr class="separator:a4db3e53f157c60878052dc920dc98d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9c61e2659b2d67194cf200214a84cf" id="r_a3f9c61e2659b2d67194cf200214a84cf"><td class="memItemLeft" align="right" valign="top"><a id="a3f9c61e2659b2d67194cf200214a84cf" name="a3f9c61e2659b2d67194cf200214a84cf"></a>
<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;source)</td></tr>
<tr class="memdesc:a3f9c61e2659b2d67194cf200214a84cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment, note that the selected acceleration mode is not copied, acceleration is reset to the default. <br /></td></tr>
<tr class="separator:a3f9c61e2659b2d67194cf200214a84cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89d3aecd02df8719dcb2f3ddadc675e" id="r_aa89d3aecd02df8719dcb2f3ddadc675e"><td class="memItemLeft" align="right" valign="top"><a id="aa89d3aecd02df8719dcb2f3ddadc675e" name="aa89d3aecd02df8719dcb2f3ddadc675e"></a>
<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&amp;source)=default</td></tr>
<tr class="memdesc:aa89d3aecd02df8719dcb2f3ddadc675e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment, the selected acceleration mode is also carried over. <br /></td></tr>
<tr class="separator:aa89d3aecd02df8719dcb2f3ddadc675e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5d8e0de41a193dfa2b9e358feff6af" id="r_a1f5d8e0de41a193dfa2b9e358feff6af"><td class="memItemLeft" align="right" valign="top"><a id="a1f5d8e0de41a193dfa2b9e358feff6af" name="a1f5d8e0de41a193dfa2b9e358feff6af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (const char *filename, bool binary=<a class="el" href="group__TasmanianSG.html#gab25913c6e0ddb0f1ef4a70c9c8cddc5b">mode_binary</a>) const</td></tr>
<tr class="memdesc:a1f5d8e0de41a193dfa2b9e358feff6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the grid to the given <b>filename</b> using either <b>binary</b> or ASCII format. <br /></td></tr>
<tr class="separator:a1f5d8e0de41a193dfa2b9e358feff6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8d795d4c836035770fb4aab7d94fac" id="r_abc8d795d4c836035770fb4aab7d94fac"><td class="memItemLeft" align="right" valign="top"><a id="abc8d795d4c836035770fb4aab7d94fac" name="abc8d795d4c836035770fb4aab7d94fac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (const char *filename)</td></tr>
<tr class="memdesc:abc8d795d4c836035770fb4aab7d94fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the grid from the given <b>filename</b>, automatically detect the format. <br /></td></tr>
<tr class="separator:abc8d795d4c836035770fb4aab7d94fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e169e30d5ecdcdaaa6848f5d22fa389" id="r_a4e169e30d5ecdcdaaa6848f5d22fa389"><td class="memItemLeft" align="right" valign="top"><a id="a4e169e30d5ecdcdaaa6848f5d22fa389" name="a4e169e30d5ecdcdaaa6848f5d22fa389"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (std::ostream &amp;ofs, bool binary=<a class="el" href="group__TasmanianSG.html#gab25913c6e0ddb0f1ef4a70c9c8cddc5b">mode_binary</a>) const</td></tr>
<tr class="memdesc:a4e169e30d5ecdcdaaa6848f5d22fa389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the grid to the given stream <b>ofs</b> using either <b>binary</b> or ASCII format. <br /></td></tr>
<tr class="separator:a4e169e30d5ecdcdaaa6848f5d22fa389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94da9b920e9fed020881162537a95893" id="r_a94da9b920e9fed020881162537a95893"><td class="memItemLeft" align="right" valign="top"><a id="a94da9b920e9fed020881162537a95893" name="a94da9b920e9fed020881162537a95893"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (std::istream &amp;ifs, bool binary=<a class="el" href="group__TasmanianSG.html#gab25913c6e0ddb0f1ef4a70c9c8cddc5b">mode_binary</a>)</td></tr>
<tr class="memdesc:a94da9b920e9fed020881162537a95893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the grid from the given stream <b>ifs</b> using either <b>binary</b> or ASCII format. <br /></td></tr>
<tr class="separator:a94da9b920e9fed020881162537a95893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f532374530a7dec906712cd8b7985fb" id="r_a4f532374530a7dec906712cd8b7985fb"><td class="memItemLeft" align="right" valign="top"><a id="a4f532374530a7dec906712cd8b7985fb" name="a4f532374530a7dec906712cd8b7985fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (std::string const &amp;fname, bool binary=<a class="el" href="group__TasmanianSG.html#gab25913c6e0ddb0f1ef4a70c9c8cddc5b">mode_binary</a>) const</td></tr>
<tr class="memdesc:a4f532374530a7dec906712cd8b7985fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that works directly with std::string. <br /></td></tr>
<tr class="separator:a4f532374530a7dec906712cd8b7985fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8db1f3654ba95c5170f9745c08e669" id="r_a6b8db1f3654ba95c5170f9745c08e669"><td class="memItemLeft" align="right" valign="top"><a id="a6b8db1f3654ba95c5170f9745c08e669" name="a6b8db1f3654ba95c5170f9745c08e669"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (std::string const &amp;fname)</td></tr>
<tr class="memdesc:a6b8db1f3654ba95c5170f9745c08e669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that works directly with std::string. <br /></td></tr>
<tr class="separator:a6b8db1f3654ba95c5170f9745c08e669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9790fc9925342d9416dbddb2342637d5" id="r_a9790fc9925342d9416dbddb2342637d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5">makeGlobalGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, std::vector&lt; int &gt; const &amp;anisotropic_weights, double alpha=0.0, double beta=0.0, const char *custom_filename=nullptr, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:a9790fc9925342d9416dbddb2342637d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Global Grid using Lagrange polynomials with support over the entire domain.  <br /></td></tr>
<tr class="separator:a9790fc9925342d9416dbddb2342637d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7714d84d823d00e8f4fbdcda34ed9a3d" id="r_a7714d84d823d00e8f4fbdcda34ed9a3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7714d84d823d00e8f4fbdcda34ed9a3d">makeGlobalGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, const int *anisotropic_weights=nullptr, double alpha=0.0, double beta=0.0, const char *custom_filename=nullptr, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:a7714d84d823d00e8f4fbdcda34ed9a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:a7714d84d823d00e8f4fbdcda34ed9a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522a181d924f4427cb7c36421507090b" id="r_a522a181d924f4427cb7c36421507090b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a522a181d924f4427cb7c36421507090b">makeGlobalGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, <a class="el" href="classTasGrid_1_1CustomTabulated.html">CustomTabulated</a> &amp;&amp;crule, std::vector&lt; int &gt; const &amp;anisotropic_weights, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:a522a181d924f4427cb7c36421507090b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload make a Global Grid using the provided custom rule.  <br /></td></tr>
<tr class="separator:a522a181d924f4427cb7c36421507090b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1085ad2ff79ef2df0cf16cf31f54b451" id="r_a1085ad2ff79ef2df0cf16cf31f54b451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1085ad2ff79ef2df0cf16cf31f54b451">makeGlobalGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, <a class="el" href="classTasGrid_1_1CustomTabulated.html">CustomTabulated</a> &amp;&amp;crule, const int *anisotropic_weights=nullptr, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:a1085ad2ff79ef2df0cf16cf31f54b451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:a1085ad2ff79ef2df0cf16cf31f54b451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5d51d4a5cddb0753f8a38dee15fb18" id="r_add5d51d4a5cddb0753f8a38dee15fb18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#add5d51d4a5cddb0753f8a38dee15fb18">makeSequenceGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, std::vector&lt; int &gt; const &amp;anisotropic_weights, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:add5d51d4a5cddb0753f8a38dee15fb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make Sequence Grid using Newton polynomials with support over the entire domain.  <br /></td></tr>
<tr class="separator:add5d51d4a5cddb0753f8a38dee15fb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f541f68b1e4b13fbc7dd31b1efd3fce" id="r_a1f541f68b1e4b13fbc7dd31b1efd3fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1f541f68b1e4b13fbc7dd31b1efd3fce">makeSequenceGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, const int *anisotropic_weights=nullptr, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:a1f541f68b1e4b13fbc7dd31b1efd3fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:a1f541f68b1e4b13fbc7dd31b1efd3fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3b81ba818620f88f7885186ec240a2" id="r_aed3b81ba818620f88f7885186ec240a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aed3b81ba818620f88f7885186ec240a2">makeLocalPolynomialGrid</a> (int dimensions, int outputs, int depth, int order, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, std::vector&lt; int &gt; const &amp;level_limits)</td></tr>
<tr class="memdesc:aed3b81ba818620f88f7885186ec240a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make Local Polynomial Grid using piece-wise polynomials with decreasing (compact) support.  <br /></td></tr>
<tr class="separator:aed3b81ba818620f88f7885186ec240a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46de747af60e89360aae074d00161c0f" id="r_a46de747af60e89360aae074d00161c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a46de747af60e89360aae074d00161c0f">makeLocalPolynomialGrid</a> (int dimensions, int outputs, int depth, int order=1, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule=<a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f">rule_localp</a>, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:a46de747af60e89360aae074d00161c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:a46de747af60e89360aae074d00161c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b09ba463727decb5c96e4040393641" id="r_a35b09ba463727decb5c96e4040393641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b09ba463727decb5c96e4040393641">makeWaveletGrid</a> (int dimensions, int outputs, int depth, int order, std::vector&lt; int &gt; const &amp;level_limits)</td></tr>
<tr class="memdesc:a35b09ba463727decb5c96e4040393641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Wavelet grid using local hierarchical wavelet basis.  <br /></td></tr>
<tr class="separator:a35b09ba463727decb5c96e4040393641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8036abf3c59fe31212c21c700a4aeb" id="r_adc8036abf3c59fe31212c21c700a4aeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adc8036abf3c59fe31212c21c700a4aeb">makeWaveletGrid</a> (int dimensions, int outputs, int depth, int order=1, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:adc8036abf3c59fe31212c21c700a4aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:adc8036abf3c59fe31212c21c700a4aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2277a336a8e37728a61b5f2932487de2" id="r_a2277a336a8e37728a61b5f2932487de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2277a336a8e37728a61b5f2932487de2">makeFourierGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:a2277a336a8e37728a61b5f2932487de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Fourier grid using trigonometric basis with support over the entire domain.  <br /></td></tr>
<tr class="separator:a2277a336a8e37728a61b5f2932487de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd80e501848d329413cd02d28ad29c59" id="r_abd80e501848d329413cd02d28ad29c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abd80e501848d329413cd02d28ad29c59">makeFourierGrid</a> (int dimensions, int outputs, int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, const int *anisotropic_weights=nullptr, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:abd80e501848d329413cd02d28ad29c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:abd80e501848d329413cd02d28ad29c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fef46babb671c68ed6375da9d96a61" id="r_a57fef46babb671c68ed6375da9d96a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a57fef46babb671c68ed6375da9d96a61">copyGrid</a> (const <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> *source, int outputs_begin=0, int outputs_end=-1)</td></tr>
<tr class="memdesc:a57fef46babb671c68ed6375da9d96a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the grid with a copy of the <b>source</b>, does not copy the acceleration options.  <br /></td></tr>
<tr class="separator:a57fef46babb671c68ed6375da9d96a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad72b8b49644b0cd6a2e7acf6b51875b" id="r_aad72b8b49644b0cd6a2e7acf6b51875b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aad72b8b49644b0cd6a2e7acf6b51875b">copyGrid</a> (<a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;source, int outputs_begin=0, int outputs_end=-1)</td></tr>
<tr class="memdesc:aad72b8b49644b0cd6a2e7acf6b51875b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using pass-by-reference as opposed to a pointer.  <br /></td></tr>
<tr class="separator:aad72b8b49644b0cd6a2e7acf6b51875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3844fa4877ed768db7a25c70b207899" id="r_aa3844fa4877ed768db7a25c70b207899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa3844fa4877ed768db7a25c70b207899">updateGlobalGrid</a> (int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:aa3844fa4877ed768db7a25c70b207899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new grid and merge it with the current one.  <br /></td></tr>
<tr class="separator:aa3844fa4877ed768db7a25c70b207899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a5e7d613d3101b31c2101c55d8f8f9" id="r_ae2a5e7d613d3101b31c2101c55d8f8f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae2a5e7d613d3101b31c2101c55d8f8f9">updateGlobalGrid</a> (int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, const int *anisotropic_weights=nullptr, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:ae2a5e7d613d3101b31c2101c55d8f8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:ae2a5e7d613d3101b31c2101c55d8f8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad3a5f9304cb39236f1bde2177a71ba" id="r_aaad3a5f9304cb39236f1bde2177a71ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aaad3a5f9304cb39236f1bde2177a71ba">updateSequenceGrid</a> (int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:aaad3a5f9304cb39236f1bde2177a71ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new grid and merge it with the current one.  <br /></td></tr>
<tr class="separator:aaad3a5f9304cb39236f1bde2177a71ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c25461dd243b59abd771b6ebb7c630" id="r_a13c25461dd243b59abd771b6ebb7c630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a13c25461dd243b59abd771b6ebb7c630">updateSequenceGrid</a> (int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, const int *anisotropic_weights=nullptr, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:a13c25461dd243b59abd771b6ebb7c630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:a13c25461dd243b59abd771b6ebb7c630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f090d1f36da85a708a0998bf30a188" id="r_a67f090d1f36da85a708a0998bf30a188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a67f090d1f36da85a708a0998bf30a188">updateFourierGrid</a> (int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:a67f090d1f36da85a708a0998bf30a188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new grid and merge it with the current one.  <br /></td></tr>
<tr class="separator:a67f090d1f36da85a708a0998bf30a188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e02a1708164d2f42ef319575f513d" id="r_aae0e02a1708164d2f42ef319575f513d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aae0e02a1708164d2f42ef319575f513d">updateFourierGrid</a> (int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, const int *anisotropic_weights=nullptr, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:aae0e02a1708164d2f42ef319575f513d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:aae0e02a1708164d2f42ef319575f513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54ac6202ec15150fd22f9c68bc9c920" id="r_ac54ac6202ec15150fd22f9c68bc9c920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac54ac6202ec15150fd22f9c68bc9c920">updateGrid</a> (int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:ac54ac6202ec15150fd22f9c68bc9c920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on the grid type, calls <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa3844fa4877ed768db7a25c70b207899" title="Construct a new grid and merge it with the current one.">updateGlobalGrid()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aaad3a5f9304cb39236f1bde2177a71ba" title="Construct a new grid and merge it with the current one.">updateSequenceGrid()</a> or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a67f090d1f36da85a708a0998bf30a188" title="Construct a new grid and merge it with the current one.">updateFourierGrid()</a>.  <br /></td></tr>
<tr class="separator:ac54ac6202ec15150fd22f9c68bc9c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a396b74c826a3cc6590ae41b740722d" id="r_a4a396b74c826a3cc6590ae41b740722d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a4a396b74c826a3cc6590ae41b740722d">updateGrid</a> (int depth, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, const int *anisotropic_weights=nullptr, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:a4a396b74c826a3cc6590ae41b740722d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:a4a396b74c826a3cc6590ae41b740722d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53865dbacb405d11b957fd233d85d7e" id="r_ac53865dbacb405d11b957fd233d85d7e"><td class="memItemLeft" align="right" valign="top"><a id="ac53865dbacb405d11b957fd233d85d7e" name="ac53865dbacb405d11b957fd233d85d7e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getAlpha</b> () const</td></tr>
<tr class="memdesc:ac53865dbacb405d11b957fd233d85d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <b>alpha</b> parameter in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>, or return 0 if the grid is not Global. <br /></td></tr>
<tr class="separator:ac53865dbacb405d11b957fd233d85d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2182ff1c269cdd5d442024ba678096cc" id="r_a2182ff1c269cdd5d442024ba678096cc"><td class="memItemLeft" align="right" valign="top"><a id="a2182ff1c269cdd5d442024ba678096cc" name="a2182ff1c269cdd5d442024ba678096cc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getBeta</b> () const</td></tr>
<tr class="memdesc:a2182ff1c269cdd5d442024ba678096cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <b>beta</b> parameter in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>, or return 0 if the grid is not Global. <br /></td></tr>
<tr class="separator:a2182ff1c269cdd5d442024ba678096cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd84d394dc8d95b5ec434e297f52f2c3" id="r_afd84d394dc8d95b5ec434e297f52f2c3"><td class="memItemLeft" align="right" valign="top"><a id="afd84d394dc8d95b5ec434e297f52f2c3" name="afd84d394dc8d95b5ec434e297f52f2c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getOrder</b> () const</td></tr>
<tr class="memdesc:afd84d394dc8d95b5ec434e297f52f2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <b>order</b> parameter in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aed3b81ba818620f88f7885186ec240a2" title="Make Local Polynomial Grid using piece-wise polynomials with decreasing (compact) support.">makeLocalPolynomialGrid()</a> or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b09ba463727decb5c96e4040393641" title="Make a Wavelet grid using local hierarchical wavelet basis.">makeWaveletGrid()</a>, or return -1 for all other grid types. <br /></td></tr>
<tr class="separator:afd84d394dc8d95b5ec434e297f52f2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaed15359b94d960c8970c1d10178925" id="r_aeaed15359b94d960c8970c1d10178925"><td class="memItemLeft" align="right" valign="top"><a id="aeaed15359b94d960c8970c1d10178925" name="aeaed15359b94d960c8970c1d10178925"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumDimensions</b> () const</td></tr>
<tr class="memdesc:aeaed15359b94d960c8970c1d10178925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <b>dimensions</b> of the grid, i.e., number of model inputs. <br /></td></tr>
<tr class="separator:aeaed15359b94d960c8970c1d10178925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ea595ac9b4b963f874544124aea62d" id="r_a15ea595ac9b4b963f874544124aea62d"><td class="memItemLeft" align="right" valign="top"><a id="a15ea595ac9b4b963f874544124aea62d" name="a15ea595ac9b4b963f874544124aea62d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumOutputs</b> () const</td></tr>
<tr class="memdesc:a15ea595ac9b4b963f874544124aea62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <b>outputs</b> of the grid, i.e., number of model outputs. <br /></td></tr>
<tr class="separator:a15ea595ac9b4b963f874544124aea62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bedd0855aa792cbb615b0da2879358" id="r_a14bedd0855aa792cbb615b0da2879358"><td class="memItemLeft" align="right" valign="top"><a id="a14bedd0855aa792cbb615b0da2879358" name="a14bedd0855aa792cbb615b0da2879358"></a>
<a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getRule</b> () const</td></tr>
<tr class="memdesc:a14bedd0855aa792cbb615b0da2879358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the underlying <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2" title="Used to specify the one dimensional family of rules that induces the sparse grid.">TasGrid::TypeOneDRule</a> that gives the points and basis functions. <br /></td></tr>
<tr class="separator:a14bedd0855aa792cbb615b0da2879358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e0227c26396eb530ac8f6b0f2a2ae9" id="r_a99e0227c26396eb530ac8f6b0f2a2ae9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a99e0227c26396eb530ac8f6b0f2a2ae9">getCustomRuleDescription</a> () const</td></tr>
<tr class="memdesc:a99e0227c26396eb530ac8f6b0f2a2ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the character string that is the description of the user-provided tabulated rule.  <br /></td></tr>
<tr class="separator:a99e0227c26396eb530ac8f6b0f2a2ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74773f696fb6383f6c5caa2647519719" id="r_a74773f696fb6383f6c5caa2647519719"><td class="memItemLeft" align="right" valign="top"><a id="a74773f696fb6383f6c5caa2647519719" name="a74773f696fb6383f6c5caa2647519719"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumLoaded</b> () const</td></tr>
<tr class="memdesc:a74773f696fb6383f6c5caa2647519719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of points already associated with model values via <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a>. <br /></td></tr>
<tr class="separator:a74773f696fb6383f6c5caa2647519719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee5d2252c87b9d7cba380694243c41" id="r_a6aee5d2252c87b9d7cba380694243c41"><td class="memItemLeft" align="right" valign="top"><a id="a6aee5d2252c87b9d7cba380694243c41" name="a6aee5d2252c87b9d7cba380694243c41"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumNeeded</b> () const</td></tr>
<tr class="memdesc:a6aee5d2252c87b9d7cba380694243c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of points that should be provided to the next call of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a>. <br /></td></tr>
<tr class="separator:a6aee5d2252c87b9d7cba380694243c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a99fb1f72eb914a37dc92278e0c133" id="r_a09a99fb1f72eb914a37dc92278e0c133"><td class="memItemLeft" align="right" valign="top"><a id="a09a99fb1f72eb914a37dc92278e0c133" name="a09a99fb1f72eb914a37dc92278e0c133"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumPoints</b> () const</td></tr>
<tr class="memdesc:a09a99fb1f72eb914a37dc92278e0c133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> if positive, otherwise returns <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a>, see <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a>. <br /></td></tr>
<tr class="separator:a09a99fb1f72eb914a37dc92278e0c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f6ca18129b711842eae96e29c955e4" id="r_ae5f6ca18129b711842eae96e29c955e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae5f6ca18129b711842eae96e29c955e4">getLoadedPoints</a> () const</td></tr>
<tr class="memdesc:ae5f6ca18129b711842eae96e29c955e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the points already associated with model values.  <br /></td></tr>
<tr class="separator:ae5f6ca18129b711842eae96e29c955e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14908b6de77f777723ef0b1a4c26142d" id="r_a14908b6de77f777723ef0b1a4c26142d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a14908b6de77f777723ef0b1a4c26142d">getLoadedPoints</a> (std::vector&lt; double &gt; &amp;x) const</td></tr>
<tr class="memdesc:a14908b6de77f777723ef0b1a4c26142d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that accepts the vector as a parameter.  <br /></td></tr>
<tr class="separator:a14908b6de77f777723ef0b1a4c26142d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206fd0d5bdbaa86637f0e931f7748012" id="r_a206fd0d5bdbaa86637f0e931f7748012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a206fd0d5bdbaa86637f0e931f7748012">getLoadedPoints</a> (double x[]) const</td></tr>
<tr class="memdesc:a206fd0d5bdbaa86637f0e931f7748012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-array, writes the loaded points to the first <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> entries of the array.  <br /></td></tr>
<tr class="separator:a206fd0d5bdbaa86637f0e931f7748012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cb7e7175784ab10c1e6267dc718ebb" id="r_a06cb7e7175784ab10c1e6267dc718ebb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb">getNeededPoints</a> () const</td></tr>
<tr class="memdesc:a06cb7e7175784ab10c1e6267dc718ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the points that require model values.  <br /></td></tr>
<tr class="separator:a06cb7e7175784ab10c1e6267dc718ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21852e90b2f7542bd0743ec232a2468c" id="r_a21852e90b2f7542bd0743ec232a2468c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a21852e90b2f7542bd0743ec232a2468c">getNeededPoints</a> (std::vector&lt; double &gt; &amp;x) const</td></tr>
<tr class="memdesc:a21852e90b2f7542bd0743ec232a2468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that accepts the vector as a parameter.  <br /></td></tr>
<tr class="separator:a21852e90b2f7542bd0743ec232a2468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43614bf94e7d7a2b44c8e1ee9ac40a72" id="r_a43614bf94e7d7a2b44c8e1ee9ac40a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a43614bf94e7d7a2b44c8e1ee9ac40a72">getNeededPoints</a> (double *x) const</td></tr>
<tr class="memdesc:a43614bf94e7d7a2b44c8e1ee9ac40a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-array, writes the loaded points to the first <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> entries of the array.  <br /></td></tr>
<tr class="separator:a43614bf94e7d7a2b44c8e1ee9ac40a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c92561d8654d227e341438d92b3a2be" id="r_a6c92561d8654d227e341438d92b3a2be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be">getPoints</a> () const</td></tr>
<tr class="memdesc:a6c92561d8654d227e341438d92b3a2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loaded points if any, otherwise returns the needed points.  <br /></td></tr>
<tr class="separator:a6c92561d8654d227e341438d92b3a2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f17ec6ba8cb8507a0aab2af8782236" id="r_a57f17ec6ba8cb8507a0aab2af8782236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a57f17ec6ba8cb8507a0aab2af8782236">getPoints</a> (std::vector&lt; double &gt; &amp;x) const</td></tr>
<tr class="memdesc:a57f17ec6ba8cb8507a0aab2af8782236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that accepts the vector as a parameter.  <br /></td></tr>
<tr class="separator:a57f17ec6ba8cb8507a0aab2af8782236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9f338c4594431e83c904133360f69b" id="r_aaf9f338c4594431e83c904133360f69b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aaf9f338c4594431e83c904133360f69b">getPoints</a> (double x[]) const</td></tr>
<tr class="memdesc:aaf9f338c4594431e83c904133360f69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that accepts the raw array as an input.  <br /></td></tr>
<tr class="separator:aaf9f338c4594431e83c904133360f69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1c5a9c46ed61a61b36d96b1f6b9be3" id="r_a3b1c5a9c46ed61a61b36d96b1f6b9be3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3b1c5a9c46ed61a61b36d96b1f6b9be3">getQuadratureWeights</a> () const</td></tr>
<tr class="memdesc:a3b1c5a9c46ed61a61b36d96b1f6b9be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> of the quadrature weights of the grid.  <br /></td></tr>
<tr class="separator:a3b1c5a9c46ed61a61b36d96b1f6b9be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b4ddf376167977a4ebc4733a1048e5" id="r_a49b4ddf376167977a4ebc4733a1048e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a49b4ddf376167977a4ebc4733a1048e5">getQuadratureWeights</a> (std::vector&lt; double &gt; &amp;weights) const</td></tr>
<tr class="memdesc:a49b4ddf376167977a4ebc4733a1048e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that accepts the vector as a parameter.  <br /></td></tr>
<tr class="separator:a49b4ddf376167977a4ebc4733a1048e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f05fa86976ca28513c2d0fd3f4f1236" id="r_a8f05fa86976ca28513c2d0fd3f4f1236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8f05fa86976ca28513c2d0fd3f4f1236">getQuadratureWeights</a> (double weights[]) const</td></tr>
<tr class="memdesc:a8f05fa86976ca28513c2d0fd3f4f1236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that accepts the raw array as an input.  <br /></td></tr>
<tr class="separator:a8f05fa86976ca28513c2d0fd3f4f1236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab448a4aa17ef3eee59f8e8dcb55dd769" id="r_ab448a4aa17ef3eee59f8e8dcb55dd769"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab448a4aa17ef3eee59f8e8dcb55dd769">getInterpolationWeights</a> (std::vector&lt; double &gt; const &amp;x) const</td></tr>
<tr class="memdesc:ab448a4aa17ef3eee59f8e8dcb55dd769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights of the model outputs that combine to construct the approximation value at <b>x</b>.  <br /></td></tr>
<tr class="separator:ab448a4aa17ef3eee59f8e8dcb55dd769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34bad439633fc4ec836d3c7a6d6624e" id="r_ab34bad439633fc4ec836d3c7a6d6624e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab34bad439633fc4ec836d3c7a6d6624e">getInterpolationWeights</a> (double const x[]) const</td></tr>
<tr class="memdesc:ab34bad439633fc4ec836d3c7a6d6624e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses raw-array, does not check the array size.  <br /></td></tr>
<tr class="separator:ab34bad439633fc4ec836d3c7a6d6624e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969d557cf43d6b749e0fa3c3656ea861" id="r_a969d557cf43d6b749e0fa3c3656ea861"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a969d557cf43d6b749e0fa3c3656ea861">getInterpolationWeights</a> (const std::vector&lt; double &gt; &amp;x, std::vector&lt; double &gt; &amp;weights) const</td></tr>
<tr class="memdesc:a969d557cf43d6b749e0fa3c3656ea861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses the vector as a parameter.  <br /></td></tr>
<tr class="separator:a969d557cf43d6b749e0fa3c3656ea861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3736b94b245231de100df06c7987df" id="r_aed3736b94b245231de100df06c7987df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aed3736b94b245231de100df06c7987df">getInterpolationWeights</a> (const double x[], double weights[]) const</td></tr>
<tr class="memdesc:aed3736b94b245231de100df06c7987df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses raw-array, does not check the array size.  <br /></td></tr>
<tr class="separator:aed3736b94b245231de100df06c7987df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08e2fff2eeed94ff10fea6b8a81b93d" id="r_ab08e2fff2eeed94ff10fea6b8a81b93d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab08e2fff2eeed94ff10fea6b8a81b93d">getDifferentiationWeights</a> (std::vector&lt; double &gt; const &amp;x) const</td></tr>
<tr class="memdesc:ab08e2fff2eeed94ff10fea6b8a81b93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights of the model outputs that combine to construct the approximate Jacobian matrix (derivative) at <b>x</b>.  <br /></td></tr>
<tr class="separator:ab08e2fff2eeed94ff10fea6b8a81b93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab64a5bcdd3379d221cd7dcfee55aaa8" id="r_aab64a5bcdd3379d221cd7dcfee55aaa8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aab64a5bcdd3379d221cd7dcfee55aaa8">getDifferentiationWeights</a> (double const x[]) const</td></tr>
<tr class="memdesc:aab64a5bcdd3379d221cd7dcfee55aaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses raw-array, does not check the array size.  <br /></td></tr>
<tr class="separator:aab64a5bcdd3379d221cd7dcfee55aaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05082fdbd002099dc0999757bd76814f" id="r_a05082fdbd002099dc0999757bd76814f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a05082fdbd002099dc0999757bd76814f">getDifferentiationWeights</a> (const std::vector&lt; double &gt; &amp;x, std::vector&lt; double &gt; &amp;weights) const</td></tr>
<tr class="memdesc:a05082fdbd002099dc0999757bd76814f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses the vector as a parameter.  <br /></td></tr>
<tr class="separator:a05082fdbd002099dc0999757bd76814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2140bd3867ada4e0828e22824d6e68d5" id="r_a2140bd3867ada4e0828e22824d6e68d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2140bd3867ada4e0828e22824d6e68d5">getDifferentiationWeights</a> (const double x[], double weights[]) const</td></tr>
<tr class="memdesc:a2140bd3867ada4e0828e22824d6e68d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses raw-array, does not check the array size.  <br /></td></tr>
<tr class="separator:a2140bd3867ada4e0828e22824d6e68d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a9e720271b111893fdcd7e70a4ff3e" id="r_af9a9e720271b111893fdcd7e70a4ff3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e">loadNeededValues</a> (std::vector&lt; double &gt; const &amp;vals)</td></tr>
<tr class="memdesc:af9a9e720271b111893fdcd7e70a4ff3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the values of the model outputs at the needed points, or overwrites the currently loaded points.  <br /></td></tr>
<tr class="separator:af9a9e720271b111893fdcd7e70a4ff3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3217125cade60ca65e476f5a22531551" id="r_a3217125cade60ca65e476f5a22531551"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3217125cade60ca65e476f5a22531551">loadNeededValues</a> (const double *vals)</td></tr>
<tr class="memdesc:a3217125cade60ca65e476f5a22531551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses a raw-array, does not check the array size.  <br /></td></tr>
<tr class="separator:a3217125cade60ca65e476f5a22531551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb888a2375dcbb51775b3a894eb32df" id="r_adcb888a2375dcbb51775b3a894eb32df"><td class="memItemLeft" align="right" valign="top"><a id="adcb888a2375dcbb51775b3a894eb32df" name="adcb888a2375dcbb51775b3a894eb32df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadNeededPoints</b> (std::vector&lt; double &gt; const &amp;vals)</td></tr>
<tr class="memdesc:adcb888a2375dcbb51775b3a894eb32df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a>. <br /></td></tr>
<tr class="separator:adcb888a2375dcbb51775b3a894eb32df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7567a695e37d9c4188933653e35bf30" id="r_aa7567a695e37d9c4188933653e35bf30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa7567a695e37d9c4188933653e35bf30">loadNeededPoints</a> (const double *vals)</td></tr>
<tr class="memdesc:aa7567a695e37d9c4188933653e35bf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses a raw-array, does not check the array size.  <br /></td></tr>
<tr class="separator:aa7567a695e37d9c4188933653e35bf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21324f2dd05df67569024b3e87f48bb5" id="r_a21324f2dd05df67569024b3e87f48bb5"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a21324f2dd05df67569024b3e87f48bb5">getLoadedValues</a> () const</td></tr>
<tr class="memdesc:a21324f2dd05df67569024b3e87f48bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the model values that have been loaded in the gird.  <br /></td></tr>
<tr class="separator:a21324f2dd05df67569024b3e87f48bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cbf78f4e11a953ee964576a3a70840" id="r_a30cbf78f4e11a953ee964576a3a70840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840">evaluate</a> (std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y) const</td></tr>
<tr class="memdesc:a30cbf78f4e11a953ee964576a3a70840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the interpolant (or point-wise approximation) at the given point <b>x</b>.  <br /></td></tr>
<tr class="separator:a30cbf78f4e11a953ee964576a3a70840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c4d8007bd527ec37fc6c6fe7b71ffa" id="r_a32c4d8007bd527ec37fc6c6fe7b71ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a32c4d8007bd527ec37fc6c6fe7b71ffa">evaluate</a> (const double x[], double y[]) const</td></tr>
<tr class="memdesc:a32c4d8007bd527ec37fc6c6fe7b71ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses raw-arrays, does not check the array size.  <br /></td></tr>
<tr class="separator:a32c4d8007bd527ec37fc6c6fe7b71ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e35f5abc8315c4af97b1abb7e191d85" id="r_a7e35f5abc8315c4af97b1abb7e191d85"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a7e35f5abc8315c4af97b1abb7e191d85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85">evaluateBatch</a> (std::vector&lt; FloatType &gt; const &amp;x, std::vector&lt; FloatType &gt; &amp;y) const</td></tr>
<tr class="memdesc:a7e35f5abc8315c4af97b1abb7e191d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the interpolant (or point-wise approximation) for a batch of points.  <br /></td></tr>
<tr class="separator:a7e35f5abc8315c4af97b1abb7e191d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8c743f9205db5cd8c69d0a7a45c84f" id="r_aba8c743f9205db5cd8c69d0a7a45c84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aba8c743f9205db5cd8c69d0a7a45c84f">evaluateBatch</a> (const double x[], int num_x, double y[]) const</td></tr>
<tr class="memdesc:aba8c743f9205db5cd8c69d0a7a45c84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses raw-arrays.  <br /></td></tr>
<tr class="separator:aba8c743f9205db5cd8c69d0a7a45c84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44de3a7c92c8b7d0abf4db4917377816" id="r_a44de3a7c92c8b7d0abf4db4917377816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a44de3a7c92c8b7d0abf4db4917377816">evaluateBatch</a> (const float x[], int num_x, float y[]) const</td></tr>
<tr class="memdesc:a44de3a7c92c8b7d0abf4db4917377816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using single precision and GPU/CUDA acceleration.  <br /></td></tr>
<tr class="separator:a44de3a7c92c8b7d0abf4db4917377816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf49fb81aeb1886bf82b2e6e0b92f31d" id="r_adf49fb81aeb1886bf82b2e6e0b92f31d"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:adf49fb81aeb1886bf82b2e6e0b92f31d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adf49fb81aeb1886bf82b2e6e0b92f31d">evaluateBatchGPU</a> (const FloatType gpu_x[], int cpu_num_x, FloatType gpu_y[]) const</td></tr>
<tr class="memdesc:adf49fb81aeb1886bf82b2e6e0b92f31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses GPU raw-arrays.  <br /></td></tr>
<tr class="separator:adf49fb81aeb1886bf82b2e6e0b92f31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c041f02cec68b17258be4f41f18010" id="r_a29c041f02cec68b17258be4f41f18010"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a29c041f02cec68b17258be4f41f18010"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a29c041f02cec68b17258be4f41f18010">evaluateFast</a> (const FloatType x[], FloatType y[]) const</td></tr>
<tr class="memdesc:a29c041f02cec68b17258be4f41f18010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> with enabled acceleration or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a> with a batch of one point.  <br /></td></tr>
<tr class="separator:a29c041f02cec68b17258be4f41f18010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a3e006e0b97eb7ad8e2f7c5fa769b8" id="r_a74a3e006e0b97eb7ad8e2f7c5fa769b8"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a74a3e006e0b97eb7ad8e2f7c5fa769b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74a3e006e0b97eb7ad8e2f7c5fa769b8">evaluateFast</a> (std::vector&lt; FloatType &gt; const &amp;x, std::vector&lt; FloatType &gt; &amp;y) const</td></tr>
<tr class="memdesc:a74a3e006e0b97eb7ad8e2f7c5fa769b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a>.  <br /></td></tr>
<tr class="separator:a74a3e006e0b97eb7ad8e2f7c5fa769b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939ee80c26cd714518107a6718f97e95" id="r_a939ee80c26cd714518107a6718f97e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a939ee80c26cd714518107a6718f97e95">integrate</a> (std::vector&lt; double &gt; &amp;q) const</td></tr>
<tr class="memdesc:a939ee80c26cd714518107a6718f97e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integral of each model output over the sparse grid domain.  <br /></td></tr>
<tr class="separator:a939ee80c26cd714518107a6718f97e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe014455d9517ae1517fdb9a92c0bbba" id="r_afe014455d9517ae1517fdb9a92c0bbba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afe014455d9517ae1517fdb9a92c0bbba">integrate</a> (double q[]) const</td></tr>
<tr class="memdesc:afe014455d9517ae1517fdb9a92c0bbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses a raw-array.  <br /></td></tr>
<tr class="separator:afe014455d9517ae1517fdb9a92c0bbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0574dcaa0a03d68f583fbf9bf34d2a" id="r_a6a0574dcaa0a03d68f583fbf9bf34d2a"><td class="memItemLeft" align="right" valign="top"><a id="a6a0574dcaa0a03d68f583fbf9bf34d2a" name="a6a0574dcaa0a03d68f583fbf9bf34d2a"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>integrate</b> () const</td></tr>
<tr class="memdesc:a6a0574dcaa0a03d68f583fbf9bf34d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that returns a vector. <br /></td></tr>
<tr class="separator:a6a0574dcaa0a03d68f583fbf9bf34d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b06e4357796cdf4bbcf0294f895130" id="r_a35b06e4357796cdf4bbcf0294f895130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b06e4357796cdf4bbcf0294f895130">differentiate</a> (std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;jacobian) const</td></tr>
<tr class="memdesc:a35b06e4357796cdf4bbcf0294f895130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative (if available) of the surrogate model at an input point.  <br /></td></tr>
<tr class="separator:a35b06e4357796cdf4bbcf0294f895130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a4c7b664063d069b6ce2e4385fb35b" id="r_a78a4c7b664063d069b6ce2e4385fb35b"><td class="memItemLeft" align="right" valign="top"><a id="a78a4c7b664063d069b6ce2e4385fb35b" name="a78a4c7b664063d069b6ce2e4385fb35b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>differentiate</b> (std::vector&lt; double &gt; const &amp;x) const</td></tr>
<tr class="memdesc:a78a4c7b664063d069b6ce2e4385fb35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b06e4357796cdf4bbcf0294f895130" title="Computes the derivative (if available) of the surrogate model at an input point.">TasmanianSparseGrid::differentiate()</a> but returns the <b>jacobian</b>. <br /></td></tr>
<tr class="separator:a78a4c7b664063d069b6ce2e4385fb35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c191937fa931777bf5f1ab332038177" id="r_a2c191937fa931777bf5f1ab332038177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2c191937fa931777bf5f1ab332038177">differentiate</a> (const double x[], double jacobian[]) const</td></tr>
<tr class="memdesc:a2c191937fa931777bf5f1ab332038177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses a raw-array.  <br /></td></tr>
<tr class="separator:a2c191937fa931777bf5f1ab332038177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003a8f8b508c4b272526a7108d203583" id="r_a003a8f8b508c4b272526a7108d203583"><td class="memItemLeft" align="right" valign="top"><a id="a003a8f8b508c4b272526a7108d203583" name="a003a8f8b508c4b272526a7108d203583"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isGlobal</b> () const</td></tr>
<tr class="memdesc:a003a8f8b508c4b272526a7108d203583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the grid is of type global, <b>false</b> otherwise. <br /></td></tr>
<tr class="separator:a003a8f8b508c4b272526a7108d203583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef98af9659a28489f5e30e44264e20e" id="r_a8ef98af9659a28489f5e30e44264e20e"><td class="memItemLeft" align="right" valign="top"><a id="a8ef98af9659a28489f5e30e44264e20e" name="a8ef98af9659a28489f5e30e44264e20e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSequence</b> () const</td></tr>
<tr class="memdesc:a8ef98af9659a28489f5e30e44264e20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the grid is of type sequence, <b>false</b> otherwise. <br /></td></tr>
<tr class="separator:a8ef98af9659a28489f5e30e44264e20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4ec32ff286e5411af40dceb480772d" id="r_aeb4ec32ff286e5411af40dceb480772d"><td class="memItemLeft" align="right" valign="top"><a id="aeb4ec32ff286e5411af40dceb480772d" name="aeb4ec32ff286e5411af40dceb480772d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isLocalPolynomial</b> () const</td></tr>
<tr class="memdesc:aeb4ec32ff286e5411af40dceb480772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the grid is of type local polynomial, <b>false</b> otherwise. <br /></td></tr>
<tr class="separator:aeb4ec32ff286e5411af40dceb480772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd2120f00a4d73d8a255f4870c2eaf6" id="r_aedd2120f00a4d73d8a255f4870c2eaf6"><td class="memItemLeft" align="right" valign="top"><a id="aedd2120f00a4d73d8a255f4870c2eaf6" name="aedd2120f00a4d73d8a255f4870c2eaf6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isWavelet</b> () const</td></tr>
<tr class="memdesc:aedd2120f00a4d73d8a255f4870c2eaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the grid is of type wavelet, <b>false</b> otherwise. <br /></td></tr>
<tr class="separator:aedd2120f00a4d73d8a255f4870c2eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f3d6de822ba2eed99ad060dd88dace" id="r_a93f3d6de822ba2eed99ad060dd88dace"><td class="memItemLeft" align="right" valign="top"><a id="a93f3d6de822ba2eed99ad060dd88dace" name="a93f3d6de822ba2eed99ad060dd88dace"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFourier</b> () const</td></tr>
<tr class="memdesc:a93f3d6de822ba2eed99ad060dd88dace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the grid is of type Fourier, <b>false</b> otherwise. <br /></td></tr>
<tr class="separator:a93f3d6de822ba2eed99ad060dd88dace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed40212a1689e6fdf4a197650128e886" id="r_aed40212a1689e6fdf4a197650128e886"><td class="memItemLeft" align="right" valign="top"><a id="aed40212a1689e6fdf4a197650128e886" name="aed40212a1689e6fdf4a197650128e886"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEmpty</b> () const</td></tr>
<tr class="memdesc:aed40212a1689e6fdf4a197650128e886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the grid is empty (no type), <b>false</b> otherwise. <br /></td></tr>
<tr class="separator:aed40212a1689e6fdf4a197650128e886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad714e9e2ca10e99cda523bd353781b78" id="r_ad714e9e2ca10e99cda523bd353781b78"><td class="memItemLeft" align="right" valign="top"><a id="ad714e9e2ca10e99cda523bd353781b78" name="ad714e9e2ca10e99cda523bd353781b78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:ad714e9e2ca10e99cda523bd353781b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the grid is empty (no type), <b>false</b> otherwise. <br /></td></tr>
<tr class="separator:ad714e9e2ca10e99cda523bd353781b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05292623b53a824962fe1edb716704f" id="r_ad05292623b53a824962fe1edb716704f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f">setDomainTransform</a> (std::vector&lt; double &gt; const &amp;a, std::vector&lt; double &gt; const &amp;b)</td></tr>
<tr class="memdesc:ad05292623b53a824962fe1edb716704f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a linear domain transformation.  <br /></td></tr>
<tr class="separator:ad05292623b53a824962fe1edb716704f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35a4e4b8369a29145933ec9cf695862" id="r_ae35a4e4b8369a29145933ec9cf695862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae35a4e4b8369a29145933ec9cf695862">setDomainTransform</a> (const double a[], const double b[])</td></tr>
<tr class="memdesc:ae35a4e4b8369a29145933ec9cf695862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:ae35a4e4b8369a29145933ec9cf695862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c43417f57606e0390db95514878bede" id="r_a5c43417f57606e0390db95514878bede"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a5c43417f57606e0390db95514878bede">isSetDomainTransfrom</a> () const</td></tr>
<tr class="memdesc:a5c43417f57606e0390db95514878bede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if a linear domain transformation has been set, <b>false</b> otherwise.  <br /></td></tr>
<tr class="separator:a5c43417f57606e0390db95514878bede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9056f3c6e2b19d85863c81b8c41aea" id="r_a6c9056f3c6e2b19d85863c81b8c41aea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c9056f3c6e2b19d85863c81b8c41aea">clearDomainTransform</a> ()</td></tr>
<tr class="memdesc:a6c9056f3c6e2b19d85863c81b8c41aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the domain transformation.  <br /></td></tr>
<tr class="separator:a6c9056f3c6e2b19d85863c81b8c41aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7268590a793656253d54970f8bedd3" id="r_a5f7268590a793656253d54970f8bedd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a5f7268590a793656253d54970f8bedd3">getDomainTransform</a> (std::vector&lt; double &gt; &amp;a, std::vector&lt; double &gt; &amp;b) const</td></tr>
<tr class="memdesc:a5f7268590a793656253d54970f8bedd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the two vectors used to call <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a>.  <br /></td></tr>
<tr class="separator:a5f7268590a793656253d54970f8bedd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcdfd6fa7a5489b106c2c83213f7251" id="r_a0bcdfd6fa7a5489b106c2c83213f7251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a0bcdfd6fa7a5489b106c2c83213f7251">getDomainTransform</a> (double a[], double b[]) const</td></tr>
<tr class="memdesc:a0bcdfd6fa7a5489b106c2c83213f7251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values of the two vectors used to call <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a>.  <br /></td></tr>
<tr class="separator:a0bcdfd6fa7a5489b106c2c83213f7251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17142448ed4f55a78b8d9d0a9dec3450" id="r_a17142448ed4f55a78b8d9d0a9dec3450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a17142448ed4f55a78b8d9d0a9dec3450">setConformalTransformASIN</a> (std::vector&lt; int &gt; const &amp;truncation)</td></tr>
<tr class="memdesc:a17142448ed4f55a78b8d9d0a9dec3450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set conformal transformation using truncated Maclaurin series of the arcsin() function.  <br /></td></tr>
<tr class="separator:a17142448ed4f55a78b8d9d0a9dec3450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92edb9d36e7602f4bfc16b139589ec1" id="r_ab92edb9d36e7602f4bfc16b139589ec1"><td class="memItemLeft" align="right" valign="top"><a id="ab92edb9d36e7602f4bfc16b139589ec1" name="ab92edb9d36e7602f4bfc16b139589ec1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSetConformalTransformASIN</b> () const</td></tr>
<tr class="memdesc:ab92edb9d36e7602f4bfc16b139589ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if conformal transformation has been set. <br /></td></tr>
<tr class="separator:ab92edb9d36e7602f4bfc16b139589ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a93ed0f926ddcde829809ec21cbeb3" id="r_a77a93ed0f926ddcde829809ec21cbeb3"><td class="memItemLeft" align="right" valign="top"><a id="a77a93ed0f926ddcde829809ec21cbeb3" name="a77a93ed0f926ddcde829809ec21cbeb3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearConformalTransform</b> ()</td></tr>
<tr class="memdesc:a77a93ed0f926ddcde829809ec21cbeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any currently set transformation. <br /></td></tr>
<tr class="separator:a77a93ed0f926ddcde829809ec21cbeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c9b19d04f3e4d6d0e808e6b627045e" id="r_a76c9b19d04f3e4d6d0e808e6b627045e"><td class="memItemLeft" align="right" valign="top"><a id="a76c9b19d04f3e4d6d0e808e6b627045e" name="a76c9b19d04f3e4d6d0e808e6b627045e"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getConformalTransformASIN</b> () const</td></tr>
<tr class="memdesc:a76c9b19d04f3e4d6d0e808e6b627045e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the array with the values of the set transformation. <br /></td></tr>
<tr class="separator:a76c9b19d04f3e4d6d0e808e6b627045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724e63b8ccccdf44169a6433cb2fa97c" id="r_a724e63b8ccccdf44169a6433cb2fa97c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a724e63b8ccccdf44169a6433cb2fa97c">clearLevelLimits</a> ()</td></tr>
<tr class="memdesc:a724e63b8ccccdf44169a6433cb2fa97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the currently set level limits.  <br /></td></tr>
<tr class="separator:a724e63b8ccccdf44169a6433cb2fa97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2b507fe96772d2060e4b383587a3b1" id="r_a2a2b507fe96772d2060e4b383587a3b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2a2b507fe96772d2060e4b383587a3b1">getLevelLimits</a> () const</td></tr>
<tr class="memdesc:a2a2b507fe96772d2060e4b383587a3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently set level limits.  <br /></td></tr>
<tr class="separator:a2a2b507fe96772d2060e4b383587a3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeedfde8e084afd6db031faf7d81a482" id="r_abeedfde8e084afd6db031faf7d81a482"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abeedfde8e084afd6db031faf7d81a482">setAnisotropicRefinement</a> (<a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int min_growth, int output, const std::vector&lt; int &gt; &amp;level_limits)</td></tr>
<tr class="memdesc:abeedfde8e084afd6db031faf7d81a482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set refinement using anisotropic estimate for the optimal points.  <br /></td></tr>
<tr class="separator:abeedfde8e084afd6db031faf7d81a482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aa114128218c225e4fcfdbb89e8e8c" id="r_a00aa114128218c225e4fcfdbb89e8e8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a00aa114128218c225e4fcfdbb89e8e8c">setAnisotropicRefinement</a> (<a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int min_growth, int output, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:a00aa114128218c225e4fcfdbb89e8e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-array.  <br /></td></tr>
<tr class="separator:a00aa114128218c225e4fcfdbb89e8e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48053e1f3b95f0a84a41f48ad6b56220" id="r_a48053e1f3b95f0a84a41f48ad6b56220"><td class="memItemLeft" align="right" valign="top"><a id="a48053e1f3b95f0a84a41f48ad6b56220" name="a48053e1f3b95f0a84a41f48ad6b56220"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAnisotropicRefinement</b> (<a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int min_growth, int output, const std::vector&lt; int &gt; &amp;level_limits)</td></tr>
<tr class="memdesc:a48053e1f3b95f0a84a41f48ad6b56220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abeedfde8e084afd6db031faf7d81a482" title="Set refinement using anisotropic estimate for the optimal points.">setAnisotropicRefinement()</a> and then <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a>. <br /></td></tr>
<tr class="separator:a48053e1f3b95f0a84a41f48ad6b56220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d6976c4e8f488349192a1fd716ab92" id="r_a01d6976c4e8f488349192a1fd716ab92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a01d6976c4e8f488349192a1fd716ab92">estimateAnisotropicCoefficients</a> (<a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int output) const</td></tr>
<tr class="memdesc:a01d6976c4e8f488349192a1fd716ab92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the anisotropic rates of coefficient decay for different direction.  <br /></td></tr>
<tr class="separator:a01d6976c4e8f488349192a1fd716ab92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7653bf5f847592504bddb2edda7a0bdf" id="r_a7653bf5f847592504bddb2edda7a0bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7653bf5f847592504bddb2edda7a0bdf">estimateAnisotropicCoefficients</a> (<a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int output, std::vector&lt; int &gt; &amp;weights) const</td></tr>
<tr class="memdesc:a7653bf5f847592504bddb2edda7a0bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that writes the result to a parameter.  <br /></td></tr>
<tr class="separator:a7653bf5f847592504bddb2edda7a0bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555ded26e1a839b210eb21ac7b488d37" id="r_a555ded26e1a839b210eb21ac7b488d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37">setSurplusRefinement</a> (double tolerance, int output, std::vector&lt; int &gt; const &amp;level_limits)</td></tr>
<tr class="memdesc:a555ded26e1a839b210eb21ac7b488d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence rule.  <br /></td></tr>
<tr class="separator:a555ded26e1a839b210eb21ac7b488d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd0cd7b59ed6bc80d27a18afb8de8a8" id="r_acbd0cd7b59ed6bc80d27a18afb8de8a8"><td class="memItemLeft" align="right" valign="top"><a id="acbd0cd7b59ed6bc80d27a18afb8de8a8" name="acbd0cd7b59ed6bc80d27a18afb8de8a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSurplusRefinement</b> (double tolerance, int output, const int *level_limits=nullptr)</td></tr>
<tr class="memdesc:acbd0cd7b59ed6bc80d27a18afb8de8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses array for the level limits. <br /></td></tr>
<tr class="separator:acbd0cd7b59ed6bc80d27a18afb8de8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddc00da3fbba0147bdbbf142aec4d14" id="r_a8ddc00da3fbba0147bdbbf142aec4d14"><td class="memItemLeft" align="right" valign="top"><a id="a8ddc00da3fbba0147bdbbf142aec4d14" name="a8ddc00da3fbba0147bdbbf142aec4d14"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSurplusRefinement</b> (double tolerance, int output, std::vector&lt; int &gt; const &amp;level_limits)</td></tr>
<tr class="memdesc:a8ddc00da3fbba0147bdbbf142aec4d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a> for Sequence and Global grids with a sequence rule and then <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a>. <br /></td></tr>
<tr class="separator:a8ddc00da3fbba0147bdbbf142aec4d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de67683567d3fbd6a712a01fc50e309" id="r_a3de67683567d3fbd6a712a01fc50e309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3de67683567d3fbd6a712a01fc50e309">setSurplusRefinement</a> (double tolerance, <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> criteria, int output, std::vector&lt; int &gt; const &amp;level_limits, std::vector&lt; double &gt; const &amp;scale_correction=std::vector&lt; double &gt;())</td></tr>
<tr class="memdesc:a3de67683567d3fbd6a712a01fc50e309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine the grid based on the surplus coefficients, Local-Polynomial and Wavelet grids.  <br /></td></tr>
<tr class="separator:a3de67683567d3fbd6a712a01fc50e309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d180dca4c7e04857551ecd2538a229" id="r_ac8d180dca4c7e04857551ecd2538a229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac8d180dca4c7e04857551ecd2538a229">setSurplusRefinement</a> (double tolerance, <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> criteria, int output=-1, const int *level_limits=nullptr, const double *scale_correction=nullptr)</td></tr>
<tr class="memdesc:ac8d180dca4c7e04857551ecd2538a229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses raw-arrays.  <br /></td></tr>
<tr class="separator:ac8d180dca4c7e04857551ecd2538a229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba3171fa2382842528f0896e8e81507" id="r_a6ba3171fa2382842528f0896e8e81507"><td class="memItemLeft" align="right" valign="top"><a id="a6ba3171fa2382842528f0896e8e81507" name="a6ba3171fa2382842528f0896e8e81507"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSurplusRefinement</b> (double tolerance, <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> criteria, int output, std::vector&lt; int &gt; const &amp;level_limits, std::vector&lt; double &gt; const &amp;scale_correction=std::vector&lt; double &gt;())</td></tr>
<tr class="memdesc:a6ba3171fa2382842528f0896e8e81507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a> for Local-Polynomial and Wavelet grids and then <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a>. <br /></td></tr>
<tr class="separator:a6ba3171fa2382842528f0896e8e81507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c461cb4699df8844812e6bf9f23872" id="r_aa2c461cb4699df8844812e6bf9f23872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa2c461cb4699df8844812e6bf9f23872">clearRefinement</a> ()</td></tr>
<tr class="memdesc:aa2c461cb4699df8844812e6bf9f23872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all needed points from the grid.  <br /></td></tr>
<tr class="separator:aa2c461cb4699df8844812e6bf9f23872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b56474f1ce23a77b0f62a7bd8c9ee3" id="r_aa5b56474f1ce23a77b0f62a7bd8c9ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa5b56474f1ce23a77b0f62a7bd8c9ee3">mergeRefinement</a> ()</td></tr>
<tr class="memdesc:aa5b56474f1ce23a77b0f62a7bd8c9ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the loaded and needed points into a single grid, resets all loaded values to zero.  <br /></td></tr>
<tr class="separator:aa5b56474f1ce23a77b0f62a7bd8c9ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886e52d4b9180c468c80d9f2339e7608" id="r_a886e52d4b9180c468c80d9f2339e7608"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a886e52d4b9180c468c80d9f2339e7608">beginConstruction</a> ()</td></tr>
<tr class="memdesc:a886e52d4b9180c468c80d9f2339e7608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a dynamic construction procedure.  <br /></td></tr>
<tr class="separator:a886e52d4b9180c468c80d9f2339e7608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a1ad3fb58fa1e7ced8cbb59a051440" id="r_ad0a1ad3fb58fa1e7ced8cbb59a051440"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad0a1ad3fb58fa1e7ced8cbb59a051440">isUsingConstruction</a> () const</td></tr>
<tr class="memdesc:ad0a1ad3fb58fa1e7ced8cbb59a051440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the dynamic construction procedure has been initialized, <b>false</b> otherwise.  <br /></td></tr>
<tr class="separator:ad0a1ad3fb58fa1e7ced8cbb59a051440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7121e196e2f8e7bd5a1cc6a698231789" id="r_a7121e196e2f8e7bd5a1cc6a698231789"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789">getCandidateConstructionPoints</a> (<a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:a7121e196e2f8e7bd5a1cc6a698231789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a sorted list of points weighted by descending importance.  <br /></td></tr>
<tr class="separator:a7121e196e2f8e7bd5a1cc6a698231789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7b9bf4ac3448c84662c2e17547f8bb" id="r_aaf7b9bf4ac3448c84662c2e17547f8bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aaf7b9bf4ac3448c84662c2e17547f8bb">getCandidateConstructionPoints</a> (<a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int output, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:aaf7b9bf4ac3448c84662c2e17547f8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Essentially the same as <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">getCandidateConstructionPoints()</a></b> but the weights are obtained from a call to <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a01d6976c4e8f488349192a1fd716ab92" title="Estimate the anisotropic rates of coefficient decay for different direction.">estimateAnisotropicCoefficients()</a></b>.  <br /></td></tr>
<tr class="separator:aaf7b9bf4ac3448c84662c2e17547f8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc91b2f0cecb419ec314dc2812482a3" id="r_afcc91b2f0cecb419ec314dc2812482a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afcc91b2f0cecb419ec314dc2812482a3">getCandidateConstructionPoints</a> (double tolerance, <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> criteria, int output=-1, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::vector&lt; double &gt; const &amp;scale_correction=std::vector&lt; double &gt;())</td></tr>
<tr class="memdesc:afcc91b2f0cecb419ec314dc2812482a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sorted list of points weighted by descending importance using the hierarchical surpluses.  <br /></td></tr>
<tr class="separator:afcc91b2f0cecb419ec314dc2812482a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1f2b9ae8a96023bbf529a78173daee" id="r_afa1f2b9ae8a96023bbf529a78173daee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afa1f2b9ae8a96023bbf529a78173daee">loadConstructedPoints</a> (std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; const &amp;y)</td></tr>
<tr class="memdesc:afa1f2b9ae8a96023bbf529a78173daee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add pairs of points with associated model values.  <br /></td></tr>
<tr class="separator:afa1f2b9ae8a96023bbf529a78173daee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6df5aee38e3e41ecb01a19a0e0e5b3" id="r_acc6df5aee38e3e41ecb01a19a0e0e5b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#acc6df5aee38e3e41ecb01a19a0e0e5b3">loadConstructedPoints</a> (const double x[], int numx, const double y[])</td></tr>
<tr class="memdesc:acc6df5aee38e3e41ecb01a19a0e0e5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <b>loadConstructedPoint()</b> but using arrays in place of vectors (array size is not checked)  <br /></td></tr>
<tr class="separator:acc6df5aee38e3e41ecb01a19a0e0e5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b233fa0fb01f435e9a9c1aa2dfec420" id="r_a1b233fa0fb01f435e9a9c1aa2dfec420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1b233fa0fb01f435e9a9c1aa2dfec420">finishConstruction</a> ()</td></tr>
<tr class="memdesc:a1b233fa0fb01f435e9a9c1aa2dfec420"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the procedure, clears flags and unused constructed points, can go back to using regular refinement.  <br /></td></tr>
<tr class="separator:a1b233fa0fb01f435e9a9c1aa2dfec420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b1e21762c8798d4185dbce18980095" id="r_ae3b1e21762c8798d4185dbce18980095"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae3b1e21762c8798d4185dbce18980095">getHierarchicalCoefficients</a> () const</td></tr>
<tr class="memdesc:ae3b1e21762c8798d4185dbce18980095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the internal data-structure that stores the hierarchical coefficients.  <br /></td></tr>
<tr class="separator:ae3b1e21762c8798d4185dbce18980095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4235ca9c02fb8e032c9498d707efd32" id="r_ab4235ca9c02fb8e032c9498d707efd32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab4235ca9c02fb8e032c9498d707efd32">getHierarchicalCoefficientsStatic</a> (double *coeff) const</td></tr>
<tr class="memdesc:ab4235ca9c02fb8e032c9498d707efd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the coefficients to the pre-allocated array, intended for internal use. .  <br /></td></tr>
<tr class="separator:ab4235ca9c02fb8e032c9498d707efd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25d400a7e8a28693f32a49959fe1833" id="r_ae25d400a7e8a28693f32a49959fe1833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae25d400a7e8a28693f32a49959fe1833">setHierarchicalCoefficients</a> (const std::vector&lt; double &gt; &amp;c)</td></tr>
<tr class="memdesc:ae25d400a7e8a28693f32a49959fe1833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the current set of coefficients (and loaded values) with the ones provided.  <br /></td></tr>
<tr class="separator:ae25d400a7e8a28693f32a49959fe1833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3534103dc8be7a328210e46d263bd4ad" id="r_a3534103dc8be7a328210e46d263bd4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3534103dc8be7a328210e46d263bd4ad">setHierarchicalCoefficients</a> (const double c[])</td></tr>
<tr class="memdesc:a3534103dc8be7a328210e46d263bd4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that uses raw-arrays.  <br /></td></tr>
<tr class="separator:a3534103dc8be7a328210e46d263bd4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68205bdd245e6f6f234a5c72435b14d" id="r_ad68205bdd245e6f6f234a5c72435b14d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad68205bdd245e6f6f234a5c72435b14d">evaluateHierarchicalFunctions</a> (std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y) const</td></tr>
<tr class="memdesc:ad68205bdd245e6f6f234a5c72435b14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the values of the hierarchical function basis at the specified points.  <br /></td></tr>
<tr class="separator:ad68205bdd245e6f6f234a5c72435b14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaf60b58f57dac66ee29de4c1929d84" id="r_afcaf60b58f57dac66ee29de4c1929d84"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afcaf60b58f57dac66ee29de4c1929d84">evaluateHierarchicalFunctions</a> (std::vector&lt; double &gt; const &amp;x) const</td></tr>
<tr class="memdesc:afcaf60b58f57dac66ee29de4c1929d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that returns the result.  <br /></td></tr>
<tr class="separator:afcaf60b58f57dac66ee29de4c1929d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6ebdcbe46af9138bd0ca71f790224b" id="r_a6e6ebdcbe46af9138bd0ca71f790224b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6e6ebdcbe46af9138bd0ca71f790224b">evaluateHierarchicalFunctions</a> (const double x[], int num_x, double y[]) const</td></tr>
<tr class="memdesc:a6e6ebdcbe46af9138bd0ca71f790224b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array overload, the inputs must have pre-allocated and correct size.  <br /></td></tr>
<tr class="separator:a6e6ebdcbe46af9138bd0ca71f790224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f2fec64329b04aaf97fd7f02e83b64" id="r_a30f2fec64329b04aaf97fd7f02e83b64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30f2fec64329b04aaf97fd7f02e83b64">evaluateSparseHierarchicalFunctions</a> (const std::vector&lt; double &gt; &amp;x, std::vector&lt; int &gt; &amp;pntr, std::vector&lt; int &gt; &amp;indx, std::vector&lt; double &gt; &amp;vals) const</td></tr>
<tr class="memdesc:a30f2fec64329b04aaf97fd7f02e83b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse matrix with the values of the hierarchical basis functions.  <br /></td></tr>
<tr class="separator:a30f2fec64329b04aaf97fd7f02e83b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3317411286e1f00cc0a0d752da389017" id="r_a3317411286e1f00cc0a0d752da389017"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3317411286e1f00cc0a0d752da389017">getHierarchicalSupport</a> () const</td></tr>
<tr class="memdesc:a3317411286e1f00cc0a0d752da389017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the support of the hierarchical functions.  <br /></td></tr>
<tr class="separator:a3317411286e1f00cc0a0d752da389017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0784cd2d4edce9fa02e9d6bfcfe2b54" id="r_aa0784cd2d4edce9fa02e9d6bfcfe2b54"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa0784cd2d4edce9fa02e9d6bfcfe2b54">integrateHierarchicalFunctions</a> () const</td></tr>
<tr class="memdesc:aa0784cd2d4edce9fa02e9d6bfcfe2b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integrals of the hierarchical basis functions.  <br /></td></tr>
<tr class="separator:aa0784cd2d4edce9fa02e9d6bfcfe2b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618283470b5211a0baa9d9f05bc5adaf" id="r_a618283470b5211a0baa9d9f05bc5adaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a618283470b5211a0baa9d9f05bc5adaf">integrateHierarchicalFunctions</a> (std::vector&lt; double &gt; &amp;integrals) const</td></tr>
<tr class="memdesc:a618283470b5211a0baa9d9f05bc5adaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload where the vector is passes as a parameter.  <br /></td></tr>
<tr class="separator:a618283470b5211a0baa9d9f05bc5adaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4c879a6844b0c0406075dd532c89bb" id="r_a4b4c879a6844b0c0406075dd532c89bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a4b4c879a6844b0c0406075dd532c89bb">integrateHierarchicalFunctions</a> (double integrals[]) const</td></tr>
<tr class="memdesc:a4b4c879a6844b0c0406075dd532c89bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using raw-arrays.  <br /></td></tr>
<tr class="separator:a4b4c879a6844b0c0406075dd532c89bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ef79ca52084002348df6a07c3f82a8" id="r_a90ef79ca52084002348df6a07c3f82a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a90ef79ca52084002348df6a07c3f82a8">getGlobalPolynomialSpace</a> (bool interpolation) const</td></tr>
<tr class="memdesc:a90ef79ca52084002348df6a07c3f82a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the powers of the polynomial that span the effective basis, Global and Sequence grids only.  <br /></td></tr>
<tr class="separator:a90ef79ca52084002348df6a07c3f82a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e393d27f07b24e9c8d348210ff6bd3" id="r_aa1e393d27f07b24e9c8d348210ff6bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa1e393d27f07b24e9c8d348210ff6bd3">printStats</a> (std::ostream &amp;os=std::cout) const</td></tr>
<tr class="memdesc:aa1e393d27f07b24e9c8d348210ff6bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints short human-readable text describing the grid properties.  <br /></td></tr>
<tr class="separator:aa1e393d27f07b24e9c8d348210ff6bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab351871503d4cb7a8287f655eefed974" id="r_ab351871503d4cb7a8287f655eefed974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974">enableAcceleration</a> (<a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> acc)</td></tr>
<tr class="memdesc:ab351871503d4cb7a8287f655eefed974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current acceleration mode to the one specified.  <br /></td></tr>
<tr class="separator:ab351871503d4cb7a8287f655eefed974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2d9bcbc406f656cb780ff9bf11bf2f" id="r_aeb2d9bcbc406f656cb780ff9bf11bf2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeb2d9bcbc406f656cb780ff9bf11bf2f">enableAcceleration</a> (<a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> acc, int new_gpu_id)</td></tr>
<tr class="memdesc:aeb2d9bcbc406f656cb780ff9bf11bf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines calls the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a037284049ec188a606d1b41ce3d2c92f" title="Returns the currently set CUDA device.">getGPUID()</a> and allows for user provided handles.  <br /></td></tr>
<tr class="separator:aeb2d9bcbc406f656cb780ff9bf11bf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ef3f5b8d4a0f34ca6466cc6e79c08c" id="r_ac5ef3f5b8d4a0f34ca6466cc6e79c08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac5ef3f5b8d4a0f34ca6466cc6e79c08c">favorSparseAcceleration</a> (bool favor)</td></tr>
<tr class="memdesc:ac5ef3f5b8d4a0f34ca6466cc6e79c08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the preferred back-end algorithm for Local Polynomial grids.  <br /></td></tr>
<tr class="separator:ac5ef3f5b8d4a0f34ca6466cc6e79c08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad223c8c4ac1dfbe2720d06533951d0a4" id="r_ad223c8c4ac1dfbe2720d06533951d0a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad223c8c4ac1dfbe2720d06533951d0a4">setCuBlasHandle</a> (void *handle)</td></tr>
<tr class="memdesc:ad223c8c4ac1dfbe2720d06533951d0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a user provided cuBlas handle.  <br /></td></tr>
<tr class="separator:ad223c8c4ac1dfbe2720d06533951d0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8bad0a246c6c8c2d94f55c61fcca39" id="r_add8bad0a246c6c8c2d94f55c61fcca39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#add8bad0a246c6c8c2d94f55c61fcca39">setCuSparseHandle</a> (void *handle)</td></tr>
<tr class="memdesc:add8bad0a246c6c8c2d94f55c61fcca39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a user provided cuSparse handle.  <br /></td></tr>
<tr class="separator:add8bad0a246c6c8c2d94f55c61fcca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902ec72e75b078788777ee63dfb2050e" id="r_a902ec72e75b078788777ee63dfb2050e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a902ec72e75b078788777ee63dfb2050e">setCuSolverHandle</a> (void *handle)</td></tr>
<tr class="memdesc:a902ec72e75b078788777ee63dfb2050e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a user provided cuSparse handle.  <br /></td></tr>
<tr class="separator:a902ec72e75b078788777ee63dfb2050e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af402274302c748e4332c917fb8f4620b" id="r_af402274302c748e4332c917fb8f4620b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af402274302c748e4332c917fb8f4620b">setRocBlasHandle</a> (void *handle)</td></tr>
<tr class="memdesc:af402274302c748e4332c917fb8f4620b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a user provided cuBlas handle.  <br /></td></tr>
<tr class="separator:af402274302c748e4332c917fb8f4620b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715043598d7c248c82b8be4f688cd30c" id="r_a715043598d7c248c82b8be4f688cd30c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a715043598d7c248c82b8be4f688cd30c">setRocSparseHandle</a> (void *handle)</td></tr>
<tr class="memdesc:a715043598d7c248c82b8be4f688cd30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a user provided cuSparse handle.  <br /></td></tr>
<tr class="separator:a715043598d7c248c82b8be4f688cd30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1a393ad59aa8e7948719798eab9e72" id="r_aca1a393ad59aa8e7948719798eab9e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aca1a393ad59aa8e7948719798eab9e72">setSycleQueue</a> (void *queue)</td></tr>
<tr class="memdesc:aca1a393ad59aa8e7948719798eab9e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a user provided sycl::queue handle.  <br /></td></tr>
<tr class="separator:aca1a393ad59aa8e7948719798eab9e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8b7e76b93d48dc14ebe264bafcaff6" id="r_a6f8b7e76b93d48dc14ebe264bafcaff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6f8b7e76b93d48dc14ebe264bafcaff6">getAccelerationType</a> () const</td></tr>
<tr class="memdesc:a6f8b7e76b93d48dc14ebe264bafcaff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current effective acceleration mode.  <br /></td></tr>
<tr class="separator:a6f8b7e76b93d48dc14ebe264bafcaff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba3b52348459273432a95e29627ba99" id="r_afba3b52348459273432a95e29627ba99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afba3b52348459273432a95e29627ba99">setGPUID</a> (int new_gpu_id)</td></tr>
<tr class="memdesc:afba3b52348459273432a95e29627ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the current CUDA device.  <br /></td></tr>
<tr class="separator:afba3b52348459273432a95e29627ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037284049ec188a606d1b41ce3d2c92f" id="r_a037284049ec188a606d1b41ce3d2c92f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a037284049ec188a606d1b41ce3d2c92f">getGPUID</a> () const</td></tr>
<tr class="memdesc:a037284049ec188a606d1b41ce3d2c92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently set CUDA device.  <br /></td></tr>
<tr class="separator:a037284049ec188a606d1b41ce3d2c92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab521b88c5efcfe07a6630623f5aa1fdf" id="r_ab521b88c5efcfe07a6630623f5aa1fdf"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:ab521b88c5efcfe07a6630623f5aa1fdf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab521b88c5efcfe07a6630623f5aa1fdf">evaluateHierarchicalFunctionsGPU</a> (const FloatType gpu_x[], int cpu_num_x, FloatType gpu_y[]) const</td></tr>
<tr class="memdesc:ab521b88c5efcfe07a6630623f5aa1fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the values of the hierarchical function basis at the specified points (CUDA version).  <br /></td></tr>
<tr class="separator:ab521b88c5efcfe07a6630623f5aa1fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1a16961eb8fe73d96c69d969d1f874" id="r_a3c1a16961eb8fe73d96c69d969d1f874"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a3c1a16961eb8fe73d96c69d969d1f874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3c1a16961eb8fe73d96c69d969d1f874">evaluateSparseHierarchicalFunctionsGPU</a> (const FloatType gpu_x[], int cpu_num_x, int *&amp;gpu_pntr, int *&amp;gpu_indx, FloatType *&amp;gpu_vals, int &amp;num_nz) const</td></tr>
<tr class="memdesc:a3c1a16961eb8fe73d96c69d969d1f874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the values of the hierarchical function basis at the specified points (sparse/CUDA version).  <br /></td></tr>
<tr class="separator:a3c1a16961eb8fe73d96c69d969d1f874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9f656b9220bd652e73930ace2694b6" id="r_aee9f656b9220bd652e73930ace2694b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aee9f656b9220bd652e73930ace2694b6">operator EvaluateCallable</a> () const</td></tr>
<tr class="memdesc:aee9f656b9220bd652e73930ace2694b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom conversion to a callable method using the <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90" title="Generic probability distribution used by Tasmanian.">TasDREAM::DreamPDF</a> signature.  <br /></td></tr>
<tr class="separator:aee9f656b9220bd652e73930ace2694b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb78af481464eb3878d43ee44b487f4" id="r_aceb78af481464eb3878d43ee44b487f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae7f55726763394dda700d6efa5f9f68b">DomainInsideSignature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aceb78af481464eb3878d43ee44b487f4">getDomainInside</a> () const</td></tr>
<tr class="memdesc:aceb78af481464eb3878d43ee44b487f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lambda object that satisfies the <a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f" title="Generic test function whether a sample belongs in the domain.">TasDREAM::DreamDomain</a> signature.  <br /></td></tr>
<tr class="separator:aceb78af481464eb3878d43ee44b487f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5d84e3fa2f9e9fd70eeaedae5d51c3" id="r_a8f5d84e3fa2f9e9fd70eeaedae5d51c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8f5d84e3fa2f9e9fd70eeaedae5d51c3">removePointsByHierarchicalCoefficient</a> (double tolerance, int output=-1, const double *scale_correction=nullptr)</td></tr>
<tr class="memdesc:a8f5d84e3fa2f9e9fd70eeaedae5d51c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all points from the grid that have relative surplus less than the <b>tolerance</b>.  <br /></td></tr>
<tr class="separator:a8f5d84e3fa2f9e9fd70eeaedae5d51c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3306c2d1852f283f74d46944da298ead" id="r_a3306c2d1852f283f74d46944da298ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3306c2d1852f283f74d46944da298ead">removePointsByHierarchicalCoefficient</a> (int num_new_points, int output=-1, const double *scale_correction=nullptr)</td></tr>
<tr class="memdesc:a3306c2d1852f283f74d46944da298ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps only the given number of points with largest scaled surpluses.  <br /></td></tr>
<tr class="separator:a3306c2d1852f283f74d46944da298ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb91720427ae70b4e099aac92da10ea7" id="r_aeb91720427ae70b4e099aac92da10ea7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeb91720427ae70b4e099aac92da10ea7">evaluateSparseHierarchicalFunctionsGetNZ</a> (const double x[], int num_x) const</td></tr>
<tr class="memdesc:aeb91720427ae70b4e099aac92da10ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of non-zeros in a call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30f2fec64329b04aaf97fd7f02e83b64" title="Constructs a sparse matrix with the values of the hierarchical basis functions.">evaluateSparseHierarchicalFunctions()</a>.  <br /></td></tr>
<tr class="separator:aeb91720427ae70b4e099aac92da10ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3104baab26653ece767f11807b58856" id="r_aa3104baab26653ece767f11807b58856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa3104baab26653ece767f11807b58856">evaluateSparseHierarchicalFunctionsStatic</a> (const double x[], int num_x, int pntr[], int indx[], double vals[]) const</td></tr>
<tr class="memdesc:aa3104baab26653ece767f11807b58856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assumes pre-allocated arrays, otherwise identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30f2fec64329b04aaf97fd7f02e83b64" title="Constructs a sparse matrix with the values of the hierarchical basis functions.">evaluateSparseHierarchicalFunctions()</a>  <br /></td></tr>
<tr class="separator:aa3104baab26653ece767f11807b58856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3081eecec78373f57dfc42a94472bfc" id="r_ac3081eecec78373f57dfc42a94472bfc"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac3081eecec78373f57dfc42a94472bfc">getPointsIndexes</a> () const</td></tr>
<tr class="memdesc:ac3081eecec78373f57dfc42a94472bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the multi-indexes of the loaded points.  <br /></td></tr>
<tr class="separator:ac3081eecec78373f57dfc42a94472bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5066f9228a98b3a226e3a6fa8502baf" id="r_ad5066f9228a98b3a226e3a6fa8502baf"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad5066f9228a98b3a226e3a6fa8502baf">getNeededIndexes</a> () const</td></tr>
<tr class="memdesc:ad5066f9228a98b3a226e3a6fa8502baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the multi-indexes of the needed points.  <br /></td></tr>
<tr class="separator:ad5066f9228a98b3a226e3a6fa8502baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051c467f6ab62ca7e6e8970de24cdb51" id="r_a051c467f6ab62ca7e6e8970de24cdb51"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a051c467f6ab62ca7e6e8970de24cdb51"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a051c467f6ab62ca7e6e8970de24cdb51">get</a> ()</td></tr>
<tr class="memdesc:a051c467f6ab62ca7e6e8970de24cdb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the internal grid.  <br /></td></tr>
<tr class="separator:a051c467f6ab62ca7e6e8970de24cdb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be2a2bf4e9bdd16fb5cd858eeedc14a" id="r_a1be2a2bf4e9bdd16fb5cd858eeedc14a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1be2a2bf4e9bdd16fb5cd858eeedc14a"><td class="memTemplItemLeft" align="right" valign="top">T const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1be2a2bf4e9bdd16fb5cd858eeedc14a">get</a> () const</td></tr>
<tr class="memdesc:a1be2a2bf4e9bdd16fb5cd858eeedc14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using const.  <br /></td></tr>
<tr class="separator:a1be2a2bf4e9bdd16fb5cd858eeedc14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7fde3a74e6c17b1f6eeb596c42fc90" id="r_acf7fde3a74e6c17b1f6eeb596c42fc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTasGrid_1_1AccelerationContext.html">AccelerationContext</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#acf7fde3a74e6c17b1f6eeb596c42fc90">getAccelerationContext</a> () const</td></tr>
<tr class="memdesc:acf7fde3a74e6c17b1f6eeb596c42fc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the addon methods to use the acceleration context.  <br /></td></tr>
<tr class="separator:acf7fde3a74e6c17b1f6eeb596c42fc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab40d28fdd0d4a3d959b44d75d01e3638" id="r_ab40d28fdd0d4a3d959b44d75d01e3638"><td class="memItemLeft" align="right" valign="top"><a id="ab40d28fdd0d4a3d959b44d75d01e3638" name="ab40d28fdd0d4a3d959b44d75d01e3638"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getVersion</b> ()</td></tr>
<tr class="memdesc:ab40d28fdd0d4a3d959b44d75d01e3638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hard-coded character string with the version in format "Major.Minor". <br /></td></tr>
<tr class="separator:ab40d28fdd0d4a3d959b44d75d01e3638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94da3260d3f479f4c791fcb60e953418" id="r_a94da3260d3f479f4c791fcb60e953418"><td class="memItemLeft" align="right" valign="top"><a id="a94da3260d3f479f4c791fcb60e953418" name="a94da3260d3f479f4c791fcb60e953418"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>getVersionMajor</b> ()</td></tr>
<tr class="memdesc:a94da3260d3f479f4c791fcb60e953418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the library major version. <br /></td></tr>
<tr class="separator:a94da3260d3f479f4c791fcb60e953418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed9447f1700a41c191e3dcc0f6f744a" id="r_a1ed9447f1700a41c191e3dcc0f6f744a"><td class="memItemLeft" align="right" valign="top"><a id="a1ed9447f1700a41c191e3dcc0f6f744a" name="a1ed9447f1700a41c191e3dcc0f6f744a"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>getVersionMinor</b> ()</td></tr>
<tr class="memdesc:a1ed9447f1700a41c191e3dcc0f6f744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the library minor version. <br /></td></tr>
<tr class="separator:a1ed9447f1700a41c191e3dcc0f6f744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a78c7b7bfdf5d095d404275d353ba1" id="r_a45a78c7b7bfdf5d095d404275d353ba1"><td class="memItemLeft" align="right" valign="top"><a id="a45a78c7b7bfdf5d095d404275d353ba1" name="a45a78c7b7bfdf5d095d404275d353ba1"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getLicense</b> ()</td></tr>
<tr class="memdesc:a45a78c7b7bfdf5d095d404275d353ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hard-coded character string with a brief statement of the license. <br /></td></tr>
<tr class="separator:a45a78c7b7bfdf5d095d404275d353ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cbc4077c1b5b534d44f6c7fb3f0392" id="r_ab0cbc4077c1b5b534d44f6c7fb3f0392"><td class="memItemLeft" align="right" valign="top"><a id="ab0cbc4077c1b5b534d44f6c7fb3f0392" name="ab0cbc4077c1b5b534d44f6c7fb3f0392"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getGitCommitHash</b> ()</td></tr>
<tr class="memdesc:ab0cbc4077c1b5b534d44f6c7fb3f0392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the git hash string, will use a placeholder if the git command was not found on compile time or if building from an official release. <br /></td></tr>
<tr class="separator:ab0cbc4077c1b5b534d44f6c7fb3f0392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce0f3e2c6adc03f0a810818eff2867b" id="r_acce0f3e2c6adc03f0a810818eff2867b"><td class="memItemLeft" align="right" valign="top"><a id="acce0f3e2c6adc03f0a810818eff2867b" name="acce0f3e2c6adc03f0a810818eff2867b"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getCmakeCxxFlags</b> ()</td></tr>
<tr class="memdesc:acce0f3e2c6adc03f0a810818eff2867b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CMAKE_BUILD_TYPE and CMAKE_CXX_FLAGS used in the configuration. <br /></td></tr>
<tr class="separator:acce0f3e2c6adc03f0a810818eff2867b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85e798fc76c4013b609616d0eece115" id="r_ac85e798fc76c4013b609616d0eece115"><td class="memItemLeft" align="right" valign="top"><a id="ac85e798fc76c4013b609616d0eece115" name="ac85e798fc76c4013b609616d0eece115"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOpenMPEnabled</b> ()</td></tr>
<tr class="memdesc:ac85e798fc76c4013b609616d0eece115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if compiled with OpenMP support, e.g., Tasmanian_ENABLE_OPENMP=ON. <br /></td></tr>
<tr class="separator:ac85e798fc76c4013b609616d0eece115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d53cb610a8c1f83ab6b1b8ccbc0f37" id="r_a49d53cb610a8c1f83ab6b1b8ccbc0f37"><td class="memItemLeft" align="right" valign="top"><a id="a49d53cb610a8c1f83ab6b1b8ccbc0f37" name="a49d53cb610a8c1f83ab6b1b8ccbc0f37"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isCudaEnabled</b> ()</td></tr>
<tr class="memdesc:a49d53cb610a8c1f83ab6b1b8ccbc0f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if compiled with CUDA support, e.g., Tasmanian_ENABLE_CUDA=ON. <br /></td></tr>
<tr class="separator:a49d53cb610a8c1f83ab6b1b8ccbc0f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279a072ec32922e47de9e8c62344ac48" id="r_a279a072ec32922e47de9e8c62344ac48"><td class="memItemLeft" align="right" valign="top"><a id="a279a072ec32922e47de9e8c62344ac48" name="a279a072ec32922e47de9e8c62344ac48"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isHipEnabled</b> ()</td></tr>
<tr class="memdesc:a279a072ec32922e47de9e8c62344ac48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if compiled with HIP support, e.g., Tasmanian_ENABLE_HIP=ON. <br /></td></tr>
<tr class="separator:a279a072ec32922e47de9e8c62344ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307d07f2437398925db0a9f87fca7473" id="r_a307d07f2437398925db0a9f87fca7473"><td class="memItemLeft" align="right" valign="top"><a id="a307d07f2437398925db0a9f87fca7473" name="a307d07f2437398925db0a9f87fca7473"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDpcppEnabled</b> ()</td></tr>
<tr class="memdesc:a307d07f2437398925db0a9f87fca7473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if compiled with DPC++ support, e.g., Tasmanian_ENABLE_DPCPP=ON. <br /></td></tr>
<tr class="separator:a307d07f2437398925db0a9f87fca7473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26da7f37c10ef476605881ebc44ccb3d" id="r_a26da7f37c10ef476605881ebc44ccb3d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a26da7f37c10ef476605881ebc44ccb3d">isAccelerationAvailable</a> (<a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> acc)</td></tr>
<tr class="memdesc:a26da7f37c10ef476605881ebc44ccb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a specific mode can be enabled.  <br /></td></tr>
<tr class="separator:a26da7f37c10ef476605881ebc44ccb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8267890d88dcae6942723ac87eb90c83" id="r_a8267890d88dcae6942723ac87eb90c83"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8267890d88dcae6942723ac87eb90c83">getNumGPUs</a> ()</td></tr>
<tr class="memdesc:a8267890d88dcae6942723ac87eb90c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of visible CUDA devices.  <br /></td></tr>
<tr class="separator:a8267890d88dcae6942723ac87eb90c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd38cf26a489b54861e993eec2e7c39" id="r_a9fd38cf26a489b54861e993eec2e7c39"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9fd38cf26a489b54861e993eec2e7c39">getGPUMemory</a> (int gpu)</td></tr>
<tr class="memdesc:a9fd38cf26a489b54861e993eec2e7c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the available device memory, in units of MB.  <br /></td></tr>
<tr class="separator:a9fd38cf26a489b54861e993eec2e7c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6eba530b513cd4d8ba56591816fa1f" id="r_a8a6eba530b513cd4d8ba56591816fa1f"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8a6eba530b513cd4d8ba56591816fa1f">getGPUName</a> (int gpu)</td></tr>
<tr class="memdesc:a8a6eba530b513cd4d8ba56591816fa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CUDA device name.  <br /></td></tr>
<tr class="separator:a8a6eba530b513cd4d8ba56591816fa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7058fe43f56c7219dc8f22f62101a606" id="r_a7058fe43f56c7219dc8f22f62101a606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7058fe43f56c7219dc8f22f62101a606">clear</a> ()</td></tr>
<tr class="memdesc:a7058fe43f56c7219dc8f22f62101a606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the grid to empty.  <br /></td></tr>
<tr class="separator:a7058fe43f56c7219dc8f22f62101a606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa9a50e15df89678c5b02815942dc09" id="r_adfa9a50e15df89678c5b02815942dc09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adfa9a50e15df89678c5b02815942dc09">mapCanonicalToTransformed</a> (int num_dimensions, int num_points, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, double x[]) const</td></tr>
<tr class="memdesc:adfa9a50e15df89678c5b02815942dc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps canonical points to the transformed equivalent.  <br /></td></tr>
<tr class="separator:adfa9a50e15df89678c5b02815942dc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077b5c5c1fc01729b97a06d02368c784" id="r_a077b5c5c1fc01729b97a06d02368c784"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a077b5c5c1fc01729b97a06d02368c784"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a077b5c5c1fc01729b97a06d02368c784">mapTransformedToCanonical</a> (int num_dimensions, int num_points, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, FloatType x[]) const</td></tr>
<tr class="memdesc:a077b5c5c1fc01729b97a06d02368c784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse map from transformed to canonical points.  <br /></td></tr>
<tr class="separator:a077b5c5c1fc01729b97a06d02368c784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ac9f41dfa4528da24472065826888a" id="r_a55ac9f41dfa4528da24472065826888a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a55ac9f41dfa4528da24472065826888a">getQuadratureScale</a> (int num_dimensions, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule) const</td></tr>
<tr class="memdesc:a55ac9f41dfa4528da24472065826888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quadrature scale factor associated with the linear transform.  <br /></td></tr>
<tr class="separator:a55ac9f41dfa4528da24472065826888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bb7e7919294b59929f5b0c43b54ff2" id="r_a91bb7e7919294b59929f5b0c43b54ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a91bb7e7919294b59929f5b0c43b54ff2">mapConformalCanonicalToTransformed</a> (int num_dimensions, int num_points, double x[]) const</td></tr>
<tr class="memdesc:a91bb7e7919294b59929f5b0c43b54ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the non-linear transformation to the points.  <br /></td></tr>
<tr class="separator:a91bb7e7919294b59929f5b0c43b54ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f893c1558d5495ffe3decb4dbcac065" id="r_a2f893c1558d5495ffe3decb4dbcac065"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a2f893c1558d5495ffe3decb4dbcac065"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2f893c1558d5495ffe3decb4dbcac065">mapConformalTransformedToCanonical</a> (int num_dimensions, int num_points, <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; FloatType &gt; &amp;x) const</td></tr>
<tr class="memdesc:a2f893c1558d5495ffe3decb4dbcac065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the inverse non-linear transformation to the points.  <br /></td></tr>
<tr class="separator:a2f893c1558d5495ffe3decb4dbcac065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53bfbd4785998b377b03c53f8af63f3" id="r_af53bfbd4785998b377b03c53f8af63f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af53bfbd4785998b377b03c53f8af63f3">mapConformalWeights</a> (int num_dimensions, int num_points, double weights[]) const</td></tr>
<tr class="memdesc:af53bfbd4785998b377b03c53f8af63f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quadrature weight correction for the conformal map.  <br /></td></tr>
<tr class="separator:af53bfbd4785998b377b03c53f8af63f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daf055cf0cd2a590ca27482dc901a05" id="r_a3daf055cf0cd2a590ca27482dc901a05"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a3daf055cf0cd2a590ca27482dc901a05"><td class="memTemplItemLeft" align="right" valign="top">const FloatType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3daf055cf0cd2a590ca27482dc901a05">formCanonicalPoints</a> (const FloatType *x, <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; FloatType &gt; &amp;x_temp, int num_x) const</td></tr>
<tr class="memdesc:a3daf055cf0cd2a590ca27482dc901a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw-array with the canonical points, combines both transformations.  <br /></td></tr>
<tr class="separator:a3daf055cf0cd2a590ca27482dc901a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0956195dcad90888e70c19976fe3beb1" id="r_a0956195dcad90888e70c19976fe3beb1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0956195dcad90888e70c19976fe3beb1"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a0956195dcad90888e70c19976fe3beb1">formCanonicalPointsGPU</a> (const T *gpu_x, int num_x, <a class="el" href="classTasGrid_1_1GpuVector.html">GpuVector</a>&lt; T &gt; &amp;gpu_x_temp) const</td></tr>
<tr class="memdesc:a0956195dcad90888e70c19976fe3beb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CUDA raw-array with the canonical points, linear transform only.  <br /></td></tr>
<tr class="separator:a0956195dcad90888e70c19976fe3beb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563ec046da76e6607f556a129701c4f6" id="r_a563ec046da76e6607f556a129701c4f6"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a563ec046da76e6607f556a129701c4f6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a563ec046da76e6607f556a129701c4f6">diffCanonicalTransform</a> () const</td></tr>
<tr class="memdesc:a563ec046da76e6607f556a129701c4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Jacobian matrix (derivative) of the transform defined by <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3daf055cf0cd2a590ca27482dc901a05" title="Returns a raw-array with the canonical points, combines both transformations.">formCanonicalPoints()</a>. Since this matrix is diagonal, we only return the diagonal vector.  <br /></td></tr>
<tr class="separator:a563ec046da76e6607f556a129701c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1931d6c8c6a5542f362ac7babda015d8" id="r_a1931d6c8c6a5542f362ac7babda015d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1931d6c8c6a5542f362ac7babda015d8">formTransformedPoints</a> (int num_points, double x[]) const</td></tr>
<tr class="memdesc:a1931d6c8c6a5542f362ac7babda015d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies both linear and non-linear transformation to the canonical points.  <br /></td></tr>
<tr class="separator:a1931d6c8c6a5542f362ac7babda015d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683cdd8328a55fc1811dadc6fe844586" id="r_a683cdd8328a55fc1811dadc6fe844586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a683cdd8328a55fc1811dadc6fe844586">writeAscii</a> (std::ostream &amp;ofs) const</td></tr>
<tr class="memdesc:a683cdd8328a55fc1811dadc6fe844586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the grid to a stream using ASCII format.  <br /></td></tr>
<tr class="separator:a683cdd8328a55fc1811dadc6fe844586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c682f9b3350c5ba3b307b47c96865f9" id="r_a3c682f9b3350c5ba3b307b47c96865f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3c682f9b3350c5ba3b307b47c96865f9">readAscii</a> (std::istream &amp;ifs)</td></tr>
<tr class="memdesc:a3c682f9b3350c5ba3b307b47c96865f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the grid from a stream using ASCII format.  <br /></td></tr>
<tr class="separator:a3c682f9b3350c5ba3b307b47c96865f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15219f68a8eab0bc78ad9924af5c815" id="r_ac15219f68a8eab0bc78ad9924af5c815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac15219f68a8eab0bc78ad9924af5c815">writeBinary</a> (std::ostream &amp;ofs) const</td></tr>
<tr class="memdesc:ac15219f68a8eab0bc78ad9924af5c815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the grid to a stream using binary format.  <br /></td></tr>
<tr class="separator:ac15219f68a8eab0bc78ad9924af5c815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7e59e76904e35bac5448cf699b75a5" id="r_a1f7e59e76904e35bac5448cf699b75a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1f7e59e76904e35bac5448cf699b75a5">readBinary</a> (std::istream &amp;ifs)</td></tr>
<tr class="memdesc:a1f7e59e76904e35bac5448cf699b75a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the grid from a stream using binary format.  <br /></td></tr>
<tr class="separator:a1f7e59e76904e35bac5448cf699b75a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The master-class that represents an instance of a Tasmanian sparse grid. </p>
<dl class="section user"><dt>class TasmanianSparseGrid</dt><dd>An object of this class represents a sparse grid, all aspects of the grid can be accessed through member methods. Each object operates independently to the extend allowed by third-party libraries, e.g., making concurrent calls to OpenBLAS will result in a race condition unless OpenBLAS is compiled with a special flag. The available member methods are split into groups that deal with different aspects of the grid. The object itself wraps around one of five different types of grids, Global, Sequence, Local Polynomial, Wavelet, and Fourier, each using different back-end data structures. The class itself handles the domain transformations, e.g., the translation between the canonical [-1, 1] and a user provided [a, b], as well as mechanisms to select acceleration back-end, common meta I/O, and error checking.</dd></dl>
<dl class="section user"><dt>Error Handling</dt><dd><b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html" title="The master-class that represents an instance of a Tasmanian sparse grid.">TasmanianSparseGrid</a></b> throws <b>std::invalid_argument</b> and <b>std::runtime_error</b> exceptions with simple human-readable messages. The <b>std::invalid_argument</b> exception indicates method call arguments of insufficient or incompatible data, e.g., vectors have insufficient size or negative number was given in place of a positive one. The <b>std::runtime_error</b> indicates problems with missing files, incorrect file format, or out-of-order function calls, e.g., adaptive refinement strategies require model values in order to infer the optimal structure of the grid, therefore calling a refinement method before model values are provided will result in a <b>std::runtime_error</b>. Similarly, <b>std::runtime_error</b> will be thrown if a method is called with the wrong grid type, e.g., global anisotropic coefficients cannot be computed for local polynomial grids.</dd></dl>
<p>If CUDA acceleration is used, CUDA error may be encountered, e.g., incorrect driver initialization, out-of-memory, etc. Tasmanian will translate CUDA error codes and messages into <b>std::runtime_error</b> exceptions and such exceptions can be raised by any method that uses acceleration.</p>
<dl class="section user"><dt>Constructors and Copy/Move assignment</dt><dd><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html" title="The master-class that represents an instance of a Tasmanian sparse grid.">TasGrid::TasmanianSparseGrid</a> includes move and copy constructors and assignment operator= overloads. There is also a default constructor that creates an empty grid. Note that move will preserve the enabled acceleration mode and the internal cache data-structures, while copy will reset the acceleration to the default.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adbcd3b1ae00aadc8107afd7d7c1bb1ac" title="Default constructor, creates and empty grid.">TasmanianSparseGrid()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a57fef46babb671c68ed6375da9d96a61" title="Replace the grid with a copy of the source, does not copy the acceleration options.">copyGrid()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Make Grid Methods</dt><dd>Each of the five grid types comes with a separate make command. The first three parameters are always the number of inputs (dimensions), the number of outputs, and the initial depth or level of the grid. The remaining parameters are specific to the type of grid.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#add5d51d4a5cddb0753f8a38dee15fb18" title="Make Sequence Grid using Newton polynomials with support over the entire domain.">makeSequenceGrid()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aed3b81ba818620f88f7885186ec240a2" title="Make Local Polynomial Grid using piece-wise polynomials with decreasing (compact) support.">makeLocalPolynomialGrid()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b09ba463727decb5c96e4040393641" title="Make a Wavelet grid using local hierarchical wavelet basis.">makeWaveletGrid()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2277a336a8e37728a61b5f2932487de2" title="Make a Fourier grid using trigonometric basis with support over the entire domain.">makeFourierGrid()</a></li>
<li>see also the factory methods, e.g., <a class="el" href="group__TasmanianSG.html#ga734013b4f52c4d1d9a35d674b459e13a" title="Factory method, creates a new grid and calls TasmanianSparseGrid::makeGlobalGrid().">TasGrid::makeGlobalGrid()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Domain Transformations</dt><dd>In most cases, sparse grids are constructed on a canonical domain [-1, 1]. The exceptions are the Fourier grids with domain [0, 1], and the Gauss-Hermite and Gauss-Laguerre rules with unbounded domain, see <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a043726272ee899f7ef10961e90698c3c" title="Non-nested rule optimized for integral of the form .">TasGrid::rule_gausshermite</a> and <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4a9504cb0e82ac9edf4b010303cd7a64" title="Non-nested rule optimized for integral of the form .">TasGrid::rule_gausslaguerre</a> for details. Tasmanian can automatically apply a linear domain transformations shifting the canonical interval to an arbitrary [a, b] or a non-linear (conformal) transformation that may accelerate convergence for some models. Each dimension of the grid can have a different linear and/or non-linear transform.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a5f7268590a793656253d54970f8bedd3" title="Returns the two vectors used to call setDomainTransform().">getDomainTransform()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a5c43417f57606e0390db95514878bede" title="Returns true if a linear domain transformation has been set, false otherwise.">isSetDomainTransfrom()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c9056f3c6e2b19d85863c81b8c41aea" title="Removes the domain transformation.">clearDomainTransform()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a17142448ed4f55a78b8d9d0a9dec3450" title="Set conformal transformation using truncated Maclaurin series of the arcsin() function.">setConformalTransformASIN()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a76c9b19d04f3e4d6d0e808e6b627045e" title="Fills the array with the values of the set transformation.">getConformalTransformASIN()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab92edb9d36e7602f4bfc16b139589ec1" title="Returns true if conformal transformation has been set.">isSetConformalTransformASIN()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a77a93ed0f926ddcde829809ec21cbeb3" title="Removes any currently set transformation.">clearConformalTransform()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Stream and File I/O</dt><dd>Sparse grid objects can be written to and from files and <b>std::ostream</b> objects. Tasmanian supports both binary and ASCII formats; the binary format has lower overhead in both file size and operations required to read/write, the ASCII format is portable without considerations of endians and for small grids the files are human-readable which helps debugging.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abc8d795d4c836035770fb4aab7d94fac" title="Read the grid from the given filename, automatically detect the format.">read()</a>, <a class="el" href="group__TasmanianSG.html#ga7e2d073ce7e53d9b995be9550e320eb9" title="Factory method, creates a new grid and calls TasmanianSparseGrid::read().">TasGrid::readGrid()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1f5d8e0de41a193dfa2b9e358feff6af" title="Write the grid to the given filename using either binary or ASCII format.">write()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Get Points and Weights</dt><dd>The points on the grid are labeled as "loaded" or "needed" based on whether the associated model values are already provided by the user. The grid points are also associated with quadrature, interpolation, and differentiation weights, where the computed weights correspond to the loaded points unless all points are labeled as needed. If the grid is set to work with zero model outputs, then the distinction is meaningless and the points will be accessed through the generic <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a> methods.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae5f6ca18129b711842eae96e29c955e4" title="Return the points already associated with model values.">getLoadedPoints()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a21324f2dd05df67569024b3e87f48bb5" title="Returns the model values that have been loaded in the gird.">getLoadedValues()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3b1c5a9c46ed61a61b36d96b1f6b9be3" title="Returns a vector of size getNumPoints() of the quadrature weights of the grid.">getQuadratureWeights()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab448a4aa17ef3eee59f8e8dcb55dd769" title="Returns the weights of the model outputs that combine to construct the approximation value at x.">getInterpolationWeights()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab08e2fff2eeed94ff10fea6b8a81b93d" title="Returns the weights of the model outputs that combine to construct the approximate Jacobian matrix (d...">getDifferentiationWeights()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Load Model Values or Hierarchical Coefficients</dt><dd>In order to construct an interpolant, Tasmanian needed to compute the coefficients of the basis functions. The user can directly provide the coefficients, e.g., computed externally with a regression method using an unstructured set of samples, or the user can provide the model values at the needed points and let Tasmanian do the computations.<ul>
<li><a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a" title="Loads the current grid with model values, does not perform any refinement.">TasGrid::loadNeededValues()</a>, <a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad49a95d0766243ba2d5d1a8f10dedb15" title="Alias to loadNeededValues(), array variant.">TasGrid::loadNeededPoints()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a21324f2dd05df67569024b3e87f48bb5" title="Returns the model values that have been loaded in the gird.">getLoadedValues()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adcb888a2375dcbb51775b3a894eb32df" title="Alias of loadNeededValues().">loadNeededPoints()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae25d400a7e8a28693f32a49959fe1833" title="Overwrites the current set of coefficients (and loaded values) with the ones provided.">setHierarchicalCoefficients()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Update and Adaptive Refinement</dt><dd>The most efficient approximation schemes adapt the grid (and the associated basis functions) to the target model. Tasmanian provides several adaptive procedures tailored to different types of grids. The refinement requires two-way communication between the model and Tasmanian, i.e., Tasmanian provides an initial set of points, the model provides the values, then Tasmanian provides an updated set of points, and so on. This can be done either in batches of point or in dynamic construction setup where values can be given one at a time in an arbitrary order (see next paragraph). See also the papers referenced in <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f" title="Used by Global Sequence and Fourier grids, indicates the selection criteria.">TasGrid::TypeDepth</a> and <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed" title="Refinement strategy for local polynomial and wavelet grids.">TasGrid::TypeRefinement</a>.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac54ac6202ec15150fd22f9c68bc9c920" title="Based on the grid type, calls updateGlobalGrid(), updateSequenceGrid() or updateFourierGrid().">updateGrid()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abeedfde8e084afd6db031faf7d81a482" title="Set refinement using anisotropic estimate for the optimal points.">setAnisotropicRefinement()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a48053e1f3b95f0a84a41f48ad6b56220" title="Call setAnisotropicRefinement() and then getNeededPoints().">getAnisotropicRefinement()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8ddc00da3fbba0147bdbbf142aec4d14" title="Call setSurplusRefinement() for Sequence and Global grids with a sequence rule and then getNeededPoin...">getSurplusRefinement()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa2c461cb4699df8844812e6bf9f23872" title="Remove all needed points from the grid.">clearRefinement()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2a2b507fe96772d2060e4b383587a3b1" title="Return the currently set level limits.">getLevelLimits()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a724e63b8ccccdf44169a6433cb2fa97c" title="Removes the currently set level limits.">clearLevelLimits()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8f5d84e3fa2f9e9fd70eeaedae5d51c3" title="Removes all points from the grid that have relative surplus less than the tolerance.">removePointsByHierarchicalCoefficient()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Dynamic Construction</dt><dd>The standard refinement procedure works in batches, where all model values for the batch have to be computed externally and loaded together in the correct order. The dynamic construction alleviates those restrictions, but comes at an increase cost since Tasmanian has to do more work and store extra data. The dynamic construction (and the internal data-structures) are initiated with the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a886e52d4b9180c468c80d9f2339e7608" title="Begin a dynamic construction procedure.">beginConstruction()</a> command and batch refinement cannot be used until the procedure is concluded. See also <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a> that can take a user defined model and fully automate the construction process.<ul>
<li><a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a886e52d4b9180c468c80d9f2339e7608" title="Begin a dynamic construction procedure.">beginConstruction()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1b233fa0fb01f435e9a9c1aa2dfec420" title="End the procedure, clears flags and unused constructed points, can go back to using regular refinemen...">finishConstruction()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">getCandidateConstructionPoints()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afa1f2b9ae8a96023bbf529a78173daee" title="Add pairs of points with associated model values.">loadConstructedPoints()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Using Unstructured Data</dt><dd>The standard sparse grid methods assume that model data is available at the very specific grid points that are chosen according to optimal estimates. However, in some cases, the model inputs cannot be controlled precisely and only randomly samples model data is available. Sparse grids can still produce accurate surrogates using such unstructured data by effectively removing the points and working only with the underlying basis (the basis is still optimal for the corresponding class of functions). The hierarchical basis method allow direct access to the values of the basis functions and the associated coefficients.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad68205bdd245e6f6f234a5c72435b14d" title="Computes the values of the hierarchical function basis at the specified points.">evaluateHierarchicalFunctions()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30f2fec64329b04aaf97fd7f02e83b64" title="Constructs a sparse matrix with the values of the hierarchical basis functions.">evaluateSparseHierarchicalFunctions()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab521b88c5efcfe07a6630623f5aa1fdf" title="Computes the values of the hierarchical function basis at the specified points (CUDA version).">evaluateHierarchicalFunctionsGPU()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3c1a16961eb8fe73d96c69d969d1f874" title="Computes the values of the hierarchical function basis at the specified points (sparse/CUDA version).">evaluateSparseHierarchicalFunctionsGPU()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae25d400a7e8a28693f32a49959fe1833" title="Overwrites the current set of coefficients (and loaded values) with the ones provided.">setHierarchicalCoefficients()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae3b1e21762c8798d4185dbce18980095" title="Return a reference to the internal data-structure that stores the hierarchical coefficients.">getHierarchicalCoefficients()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa0784cd2d4edce9fa02e9d6bfcfe2b54" title="Returns the integrals of the hierarchical basis functions.">integrateHierarchicalFunctions()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3317411286e1f00cc0a0d752da389017" title="Returns the support of the hierarchical functions.">getHierarchicalSupport()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Evaluate Methods</dt><dd>The evaluate methods compute the sparse grid approximation to the model for arbitrary point within the domain, i.e., for points that don't necessarily align with the original grid. The batch and fast evaluate method can leverage accelerated linear algebra libraries such as BLAS, cuBLAS and MAGAMA. See the documentation for <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a> for details.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adf49fb81aeb1886bf82b2e6e0b92f31d" title="Overload that uses GPU raw-arrays.">evaluateBatchGPU()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a29c041f02cec68b17258be4f41f18010" title="Equivalent to evaluate() with enabled acceleration or evaluateBatch() with a batch of one point.">evaluateFast()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6a0574dcaa0a03d68f583fbf9bf34d2a" title="Overload that returns a vector.">integrate()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Acceleration Back-end Selection</dt><dd>Allows specifying the acceleration used for evaluation methods and (in some cases) for computing the basis coefficients during <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a>. For example, methods are provided to check the number of available CUDA devices and to select an active device on a multi-GPU system.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6f8b7e76b93d48dc14ebe264bafcaff6" title="Returns the current effective acceleration mode.">getAccelerationType()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac5ef3f5b8d4a0f34ca6466cc6e79c08c" title="Set the preferred back-end algorithm for Local Polynomial grids.">favorSparseAcceleration()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afba3b52348459273432a95e29627ba99" title="Select the current CUDA device.">setGPUID()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a037284049ec188a606d1b41ce3d2c92f" title="Returns the currently set CUDA device.">getGPUID()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8267890d88dcae6942723ac87eb90c83" title="Return the number of visible CUDA devices.">getNumGPUs()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a26da7f37c10ef476605881ebc44ccb3d" title="Returns whether a specific mode can be enabled.">isAccelerationAvailable()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8a6eba530b513cd4d8ba56591816fa1f" title="Return the CUDA device name.">getGPUName()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9fd38cf26a489b54861e993eec2e7c39" title="Return the available device memory, in units of MB.">getGPUMemory()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Set User Provided Handles for Accelerated Linear Algebra</dt><dd>Acceleration frameworks such as CUDA ROCm and oneAPI use handles and queues that are either opaque pointers to internal data-structures (CUDA and ROCm) or queues that must be used for all types of acceleration and data operations. A Tasmanian object will allocate internal handles as needed, but the user can specify the handles manually. The handles must be set after a GPU capable acceleration has been enabled via <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a>, Tasmanian takes a non-owning reference and the user is responsible for deleting the handle <b>after</b> the Tasmanian object has been destroyed or a non-GPU acceleration is selected, i.e., accel_none or accel_cpu_blas. The handles are accepted as void-pointers (the type is stripped) to keep consistent API since only one GPU framework can be enabled in a single Tasmanian build and the headers for the other frameworks will not be present.<ul>
<li><b></b>(CUDA) <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad223c8c4ac1dfbe2720d06533951d0a4" title="Takes a user provided cuBlas handle.">setCuBlasHandle()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#add8bad0a246c6c8c2d94f55c61fcca39" title="Takes a user provided cuSparse handle.">setCuSparseHandle()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a902ec72e75b078788777ee63dfb2050e" title="Takes a user provided cuSparse handle.">setCuSolverHandle()</a></li>
<li><b></b>(ROCm) <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af402274302c748e4332c917fb8f4620b" title="Takes a user provided cuBlas handle.">setRocBlasHandle()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a715043598d7c248c82b8be4f688cd30c" title="Takes a user provided cuSparse handle.">setRocSparseHandle()</a></li>
<li><b></b>(oneAPI) <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aca1a393ad59aa8e7948719798eab9e72" title="Takes a user provided sycl::queue handle.">setSycleQueue()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Get Grid Meta-data</dt><dd>Various method that read the number of points, grid type, specifics about the rule and domain transformations and others. Some of the output is in human-readable format for debugging and sanity check.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a14bedd0855aa792cbb615b0da2879358" title="Return the underlying TasGrid::TypeOneDRule that gives the points and basis functions.">getRule()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a99e0227c26396eb530ac8f6b0f2a2ae9" title="Return the character string that is the description of the user-provided tabulated rule.">getCustomRuleDescription()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac53865dbacb405d11b957fd233d85d7e" title="Return the alpha parameter in the call to makeGlobalGrid(), or return 0 if the grid is not Global.">getAlpha()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2182ff1c269cdd5d442024ba678096cc" title="Return the beta parameter in the call to makeGlobalGrid(), or return 0 if the grid is not Global.">getBeta()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#afd84d394dc8d95b5ec434e297f52f2c3" title="Return the order parameter in the call to makeLocalPolynomialGrid() or makeWaveletGrid(),...">getOrder()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a003a8f8b508c4b272526a7108d203583" title="Returns true if the grid is of type global, false otherwise.">isGlobal()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8ef98af9659a28489f5e30e44264e20e" title="Returns true if the grid is of type sequence, false otherwise.">isSequence()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeb4ec32ff286e5411af40dceb480772d" title="Returns true if the grid is of type local polynomial, false otherwise.">isLocalPolynomial()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a93f3d6de822ba2eed99ad060dd88dace" title="Returns true if the grid is of type Fourier, false otherwise.">isFourier()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aedd2120f00a4d73d8a255f4870c2eaf6" title="Returns true if the grid is of type wavelet, false otherwise.">isWavelet()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aed40212a1689e6fdf4a197650128e886" title="Returns true if the grid is empty (no type), false otherwise.">isEmpty()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad714e9e2ca10e99cda523bd353781b78" title="Returns true if the grid is empty (no type), false otherwise.">empty()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa1e393d27f07b24e9c8d348210ff6bd3" title="Prints short human-readable text describing the grid properties.">printStats()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Get Library Meta-data</dt><dd>Runtime API is provided for the library version and various compile time options. Those methods are <b>static</b> and are included in the class API solely for consistency reasons.<ul>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab40d28fdd0d4a3d959b44d75d01e3638" title="Return a hard-coded character string with the version in format &quot;Major.Minor&quot;.">getVersion()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a94da3260d3f479f4c791fcb60e953418" title="Return the library major version.">getVersionMajor()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1ed9447f1700a41c191e3dcc0f6f744a" title="Return the library minor version.">getVersionMinor()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a45a78c7b7bfdf5d095d404275d353ba1" title="Return a hard-coded character string with a brief statement of the license.">getLicense()</a></li>
<li><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab0cbc4077c1b5b534d44f6c7fb3f0392" title="Return the git hash string, will use a placeholder if the git command was not found on compile time o...">getGitCommitHash()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#acce0f3e2c6adc03f0a810818eff2867b" title="Return the CMAKE_BUILD_TYPE and CMAKE_CXX_FLAGS used in the configuration.">getCmakeCxxFlags()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ac85e798fc76c4013b609616d0eece115" title="Returns true if compiled with OpenMP support, e.g., Tasmanian_ENABLE_OPENMP=ON.">isOpenMPEnabled()</a> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9790fc9925342d9416dbddb2342637d5" name="a9790fc9925342d9416dbddb2342637d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9790fc9925342d9416dbddb2342637d5">&#9670;&#160;</a></span>makeGlobalGrid() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>custom_filename</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Global Grid using Lagrange polynomials with support over the entire domain. </p>
<p>Construct a sparse grid with the given set of parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>is a positive integer specifying the dimension or number of model inputs of the grid. There is no hard restriction on how big the dimension can be; however, for large dimensions, the number of points of the sparse grid grows fast and hence the grid may require a prohibitive amount of memory. </td></tr>
    <tr><td class="paramname">outputs</td><td>is a non-negative integer specifying the number of outputs for the model. If outputs is zero, then the grid can only generate quadrature and interpolation weights. There is no hard restriction on how many outputs can be handled; however, Tasmanian requires at least outputs times number of points in storage and the computational complexity of evaluate and I/O methods increases linearly with the number of outputs. </td></tr>
    <tr><td class="paramname">depth</td><td>is a non-negative integer that controls the density of grid points. This is commonly referred to the "level" of the grid and corresponds to the L parameter in the formulas for <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f" title="Used by Global Sequence and Fourier grids, indicates the selection criteria.">TasGrid::TypeDepth</a>. There is no hard restriction on how big depth can be; however, the number of points have a strong influence on performance and memory requirements. </td></tr>
    <tr><td class="paramname">type</td><td>indicates the tensor selection strategy, see <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f" title="Used by Global Sequence and Fourier grids, indicates the selection criteria.">TasGrid::TypeDepth</a>. </td></tr>
    <tr><td class="paramname">rule</td><td>is one of the global rules, see <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2" title="Used to specify the one dimensional family of rules that induces the sparse grid.">TasGrid::TypeOneDRule</a>. </td></tr>
    <tr><td class="paramname">anisotropic_weights</td><td>indicates the relative "importance" of the inputs. If an empty vector is provided, the isotropic selection is used, i.e., assuming all inputs are equally important. If non-empty vector is given, then the size must match the number of required weights based on the selection <b>type</b>, i.e., the <b>curved</b> types use 2 x <b>dimensions</b> number of weights while the non-curved types use only <b>dimensions</b>. Integer values are used, but only the relative scale affects the selection, e.g., {2, 1}, {4, 2}, {20, 10} and {200, 100} are equivalent. The first <b>dimensions</b> entries correspond to the <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \xi_1, \xi_2, \cdots, \xi_d $" src="form_1.png" width="95" height="18"/></picture> weights and the second set corrections to the <picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \eta_1, \eta_2, \cdots, \eta_d $" src="form_2.png" width="98" height="12"/></picture> weights in the formulas in <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f" title="Used by Global Sequence and Fourier grids, indicates the selection criteria.">TasGrid::TypeDepth</a>. </td></tr>
    <tr><td class="paramname">alpha</td><td>specifies the <picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \alpha $" src="form_3.png" width="11" height="9"/></picture> parameter for the integration weight <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \rho(x) $" src="form_4.png" width="33" height="19"/></picture>, ignored when <b>rule</b> is doesn't have such parameter. See <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2" title="Used to specify the one dimensional family of rules that induces the sparse grid.">TasGrid::TypeOneDRule</a>. </td></tr>
    <tr><td class="paramname">beta</td><td>specifies the <picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \beta $" src="form_5.png" width="12" height="18"/></picture> parameter for the integration weight <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \rho(x) $" src="form_4.png" width="33" height="19"/></picture>, ignored when <b>rule</b> is doesn't have such parameter. See <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2" title="Used to specify the one dimensional family of rules that induces the sparse grid.">TasGrid::TypeOneDRule</a>. </td></tr>
    <tr><td class="paramname">custom_filename</td><td>specifies the file containing the custom rule description, used only when <b>rule</b> is <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a7597d0c89be786bb966355bc34b4e0f0" title="User provided rule, nodes and weights must be provided with a separate file.">TasGrid::rule_customtabulated</a>. </td></tr>
    <tr><td class="paramname">level_limits</td><td>is either empty or has size <b>dimensions</b> indicating the restriction of the levels for each direction which in turn restricts the number of points. For example, limit 1 when using <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a7979fed9357e95bf01dc3169051f9fcf" title="Classic nested rule using Chebyshev nodes with very low Lebesgue constant.">TasGrid::rule_clenshawcurtis</a> will restricts the grid to the mid-point and end-points of the domain. Each dimension can have a different restriction and negative numbers indicate no restriction for that direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>with human readable messages when integers are out of range, the <b>rule</b> is not a global rule, or the vectors have incorrect size. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the <b>custom_filename</b> if missing, or it cannot be opened, or the format is incorrect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7714d84d823d00e8f4fbdcda34ed9a3d" name="a7714d84d823d00e8f4fbdcda34ed9a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7714d84d823d00e8f4fbdcda34ed9a3d">&#9670;&#160;</a></span>makeGlobalGrid() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>custom_filename</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>The inputs are the same as <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a></b> except the vectors are replaced by arrays. Passing <b>nullptr</b> for an array is equivalent to passing an empty vector. Throws the same exceptions, but it does not check if the arrays have the correct size. </p>

</div>
</div>
<a id="a522a181d924f4427cb7c36421507090b" name="a522a181d924f4427cb7c36421507090b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522a181d924f4427cb7c36421507090b">&#9670;&#160;</a></span>makeGlobalGrid() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CustomTabulated.html">CustomTabulated</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>crule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload make a Global Grid using the provided custom rule. </p>
<p>Compared to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>, this uses the provided <a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">CustomTabulated</a> rule with rule_customtabulated. </p>

</div>
</div>
<a id="a1085ad2ff79ef2df0cf16cf31f54b451" name="a1085ad2ff79ef2df0cf16cf31f54b451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1085ad2ff79ef2df0cf16cf31f54b451">&#9670;&#160;</a></span>makeGlobalGrid() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CustomTabulated.html">CustomTabulated</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>crule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>Same as the other <a class="el" href="classTasGrid_1_1CustomTabulated.html" title="Class providing manipulation of custom tabulated rules, file I/O and structured access to the points,...">CustomTabulated</a> overload but uses raw-arrays. </p>

</div>
</div>
<a id="add5d51d4a5cddb0753f8a38dee15fb18" name="add5d51d4a5cddb0753f8a38dee15fb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5d51d4a5cddb0753f8a38dee15fb18">&#9670;&#160;</a></span>makeSequenceGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeSequenceGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make Sequence Grid using Newton polynomials with support over the entire domain. </p>
<p>Mathematically the Sequence and Global grids do not differ in properties; however, the implementation of the Sequence grids uses optimized internal data structures which leads to massive increase in speed when calling evaluate methods at the expense of doubled memory size and increased cost of <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a></b>. The inputs are identical to <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a></b> with the restriction that <b>rule</b> must be one of: </p><div class="fragment"><div class="line"><a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67">rule_rleja</a>           <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">rule_leja</a>           <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a013fec186e156860f5c89b56c18be6ca">rule_minlebesgue</a></div>
<div class="line"><a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab25addae4849761fabd0648c409e4fe0">rule_rlejashifted</a>    <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aae014e63a109512fecddb1a0b1a6443f">rule_maxlebesgue</a>    <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4f62c63dee6ab4c61c62ea4b179bb92c">rule_mindelta</a></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2a013fec186e156860f5c89b56c18be6ca"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a013fec186e156860f5c89b56c18be6ca">TasGrid::rule_minlebesgue</a></div><div class="ttdeci">@ rule_minlebesgue</div><div class="ttdoc">A greedy sequence rule with nodes added to minimize the Lebesgue constant.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:321</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">TasGrid::rule_leja</a></div><div class="ttdeci">@ rule_leja</div><div class="ttdoc">Classic sequence rule, moderate Lebesgue constant growth (empirical result only).</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:299</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2a4f62c63dee6ab4c61c62ea4b179bb92c"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4f62c63dee6ab4c61c62ea4b179bb92c">TasGrid::rule_mindelta</a></div><div class="ttdeci">@ rule_mindelta</div><div class="ttdoc">A greedy sequence rule with nodes added to minimize the norm of the surplus operator.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:325</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2aae014e63a109512fecddb1a0b1a6443f"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aae014e63a109512fecddb1a0b1a6443f">TasGrid::rule_maxlebesgue</a></div><div class="ttdeci">@ rule_maxlebesgue</div><div class="ttdoc">A greedy sequence rule with nodes placed at the maximum of the Lebesgue function.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:317</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2ab25addae4849761fabd0648c409e4fe0"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab25addae4849761fabd0648c409e4fe0">TasGrid::rule_rlejashifted</a></div><div class="ttdeci">@ rule_rlejashifted</div><div class="ttdoc">Similar sequence to rule_rleja but with nodes strictly in the interior.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:311</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67">TasGrid::rule_rleja</a></div><div class="ttdeci">@ rule_rleja</div><div class="ttdoc">Classic sequence rule based on complex analysis, moderate Lebesgue constant growth (theoretically pro...</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:303</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>with human readable messages when integers are out of range, the <b>rule</b> is not a sequence rule, or the vectors have incorrect size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f541f68b1e4b13fbc7dd31b1efd3fce" name="a1f541f68b1e4b13fbc7dd31b1efd3fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f541f68b1e4b13fbc7dd31b1efd3fce">&#9670;&#160;</a></span>makeSequenceGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeSequenceGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>The inputs are the same as <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#add5d51d4a5cddb0753f8a38dee15fb18" title="Make Sequence Grid using Newton polynomials with support over the entire domain.">makeSequenceGrid()</a></b> except the vectors are replaced by arrays. Passing <b>nullptr</b> for an array is equivalent to passing an empty vector. Throws the same exceptions, but it does not check if the arrays have the correct size. </p>

</div>
</div>
<a id="aed3b81ba818620f88f7885186ec240a2" name="aed3b81ba818620f88f7885186ec240a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3b81ba818620f88f7885186ec240a2">&#9670;&#160;</a></span>makeLocalPolynomialGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeLocalPolynomialGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make Local Polynomial Grid using piece-wise polynomials with decreasing (compact) support. </p>
<p>Creates a grid based on one of the local hierarchical piece-wise polynomial rules. Local grids can be used for integration, but in many cases the quadrature weights will be zero for some points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>is a positive integer specifying the dimension or number of model inputs of the grid. See also <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>. </td></tr>
    <tr><td class="paramname">outputs</td><td>is a non-negative integer specifying the number of outputs for the model. Unlike <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a> the storage requirement is at least twice the number of points times the number of outputs. </td></tr>
    <tr><td class="paramname">depth</td><td>is a non-negative integer that controls the density of grid points, i.e., the "level". The initial construction of the local grids uses tensor selection equivalent to <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa6feeea3001da5a72dcf3602b9e3cfb0c" title="Ignoring the polynomial space, use rules with index .">TasGrid::type_level</a> and depth is the <b>L</b> parameter in the formula. </td></tr>
    <tr><td class="paramname">order</td><td>is an integer no smaller than -1 indicating the largest polynomial order of the basis functions, i.e., 1 indicates the use of constant and linear functions only, while 2 would allow quadratics (if enough points are present). Using -1 indicates using the largest possible order for each point. See the papers referenced in the <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed" title="Refinement strategy for local polynomial and wavelet grids.">TasGrid::TypeRefinement</a> description. </td></tr>
    <tr><td class="paramname">rule</td><td>is one of the local polynomial rules, e.g., <div class="fragment"><div class="line"><a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f">rule_localp</a>    <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae337b4afeab83445025e17c5b5c50a4a">rule_semilocalp</a>    <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab53ef82abdf78847f8422f0a17d7c28d">rule_localp0</a>    <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a6ca48da916fa34d52f234d007218d982">rule_localpb</a></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f">TasGrid::rule_localp</a></div><div class="ttdeci">@ rule_localp</div><div class="ttdoc">Nested rule with a hierarchy of uniformly distributed nodes and functions with compact support.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:362</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2a6ca48da916fa34d52f234d007218d982"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a6ca48da916fa34d52f234d007218d982">TasGrid::rule_localpb</a></div><div class="ttdeci">@ rule_localpb</div><div class="ttdoc">Variation of rule_localp focusing nodes on the boundary instead of the interior.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:368</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2ab53ef82abdf78847f8422f0a17d7c28d"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab53ef82abdf78847f8422f0a17d7c28d">TasGrid::rule_localp0</a></div><div class="ttdeci">@ rule_localp0</div><div class="ttdoc">Variation of rule_localp assuming the model is zero at the domain boundary.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:364</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2ae337b4afeab83445025e17c5b5c50a4a"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae337b4afeab83445025e17c5b5c50a4a">TasGrid::rule_semilocalp</a></div><div class="ttdeci">@ rule_semilocalp</div><div class="ttdoc">Variation of rule_localp using increased support in exchange for higher order basis (better for smoot...</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:366</div></div>
</div><!-- fragment --> Note that using order <b>0</b> with any rule will automatically switch to a special piece-wise constant hierarchy. </td></tr>
    <tr><td class="paramname">level_limits</td><td>is identical to that for <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>with human readable messages when integers are out of range, the <b>rule</b> is not a local polynomial rule, or the vector has incorrect size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46de747af60e89360aae074d00161c0f" name="a46de747af60e89360aae074d00161c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46de747af60e89360aae074d00161c0f">&#9670;&#160;</a></span>makeLocalPolynomialGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeLocalPolynomialGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em> = <code><a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a1c5c4c912fb7bfaa5571c1db7a17646f">rule_localp</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>The inputs are the same as <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aed3b81ba818620f88f7885186ec240a2" title="Make Local Polynomial Grid using piece-wise polynomials with decreasing (compact) support.">makeLocalPolynomialGrid()</a></b> except the vector is replaced by an array. Passing <b>nullptr</b> for an array is equivalent to passing an empty vector. Throws the same exceptions, but this does not check if the array has the correct size. </p>

</div>
</div>
<a id="a35b09ba463727decb5c96e4040393641" name="a35b09ba463727decb5c96e4040393641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b09ba463727decb5c96e4040393641">&#9670;&#160;</a></span>makeWaveletGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeWaveletGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Wavelet grid using local hierarchical wavelet basis. </p>
<p>Wavelets are specialized functions that form a Riesz basis and can offer better convergence in an adaptive refinement process. See the pdf manual for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>is a positive integer specifying the dimension or number of model inputs of the grid. See also <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>. </td></tr>
    <tr><td class="paramname">outputs</td><td>is a non-negative integer specifying the number of outputs for the model. Unlike <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a> the storage requirement is at least twice the number of points times the number of outputs. </td></tr>
    <tr><td class="paramname">depth</td><td>is a non-negative integer that controls the density of grid points, i.e., the "level". The initial construction of the local grids uses tensor selection equivalent to <a class="el" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa6feeea3001da5a72dcf3602b9e3cfb0c" title="Ignoring the polynomial space, use rules with index .">TasGrid::type_level</a> and depth is the <b>L</b> parameter in the formula, but unlike the local polynomial hierarchies the zero-th level has 3 or 5 points and hence the grid density is overall higher. </td></tr>
    <tr><td class="paramname">order</td><td>is the wavelet approximation order, implemented orders are only 1 and 3 (wavelet order cannot be an even number). </td></tr>
    <tr><td class="paramname">level_limits</td><td>is identical to that for <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>with human readable messages when integers are out of range, or the vector has incorrect size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc8036abf3c59fe31212c21c700a4aeb" name="adc8036abf3c59fe31212c21c700a4aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8036abf3c59fe31212c21c700a4aeb">&#9670;&#160;</a></span>makeWaveletGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeWaveletGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>The inputs are the same as <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b09ba463727decb5c96e4040393641" title="Make a Wavelet grid using local hierarchical wavelet basis.">makeWaveletGrid()</a></b> except the vector is replaced by an array. Passing <b>nullptr</b> for an array is equivalent to passing an empty vector. Throws the same exceptions, but this does not check if the array has the correct size. </p>

</div>
</div>
<a id="a2277a336a8e37728a61b5f2932487de2" name="a2277a336a8e37728a61b5f2932487de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2277a336a8e37728a61b5f2932487de2">&#9670;&#160;</a></span>makeFourierGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeFourierGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Fourier grid using trigonometric basis with support over the entire domain. </p>
<p>The trigonometric basis guarantees that the interpolant is periodic (in all derivatives) across the domain boundary. This is the only grid that defaults to a canonical interval [0, 1] (as opposed to [-1, 1]). The parameters and error messages are identical to those used in <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>, but this always uses <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab88eab2577ab9d7f1c0eae056ea012ae" title="Trigonometric basis with uniformly distributed nodes (primarily for internal use).">TasGrid::rule_fourier</a> and the polynomial order in the selection is replaced by the frequency of the trigonometric basis. </p>

</div>
</div>
<a id="abd80e501848d329413cd02d28ad29c59" name="abd80e501848d329413cd02d28ad29c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd80e501848d329413cd02d28ad29c59">&#9670;&#160;</a></span>makeFourierGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::makeFourierGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>The inputs are the same as <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2277a336a8e37728a61b5f2932487de2" title="Make a Fourier grid using trigonometric basis with support over the entire domain.">makeFourierGrid()</a></b> except the vectors are replaced by arrays. Passing <b>nullptr</b> for an array is equivalent to passing an empty vector. Throws the same exceptions, but it does not check if the arrays have the correct size. </p>

</div>
</div>
<a id="a57fef46babb671c68ed6375da9d96a61" name="a57fef46babb671c68ed6375da9d96a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fef46babb671c68ed6375da9d96a61">&#9670;&#160;</a></span>copyGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::copyGrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs_begin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs_end</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the grid with a copy of the <b>source</b>, does not copy the acceleration options. </p>
<p>Using the default inputs is equivalent to the assignment operator, otherwise this allows to copy all points and inputs of the grid but only a sub-range of the outputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the grid to copy from.</td></tr>
    <tr><td class="paramname">outputs_begin</td><td>the first output of the new grid. </td></tr>
    <tr><td class="paramname">outputs_end</td><td>is the first not-included output, i.e., the logic is similar to std::copy(). If the last parameter is outside of the range, then include all outputs from output_begin till the end of the outputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad72b8b49644b0cd6a2e7acf6b51875b" name="aad72b8b49644b0cd6a2e7acf6b51875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad72b8b49644b0cd6a2e7acf6b51875b">&#9670;&#160;</a></span>copyGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::copyGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs_begin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputs_end</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload using pass-by-reference as opposed to a pointer. </p>
<p>The pointer version is supported for backwards compatibility, this is the preferred way to use the copy command. </p>

</div>
</div>
<a id="aa3844fa4877ed768db7a25c70b207899" name="aa3844fa4877ed768db7a25c70b207899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3844fa4877ed768db7a25c70b207899">&#9670;&#160;</a></span>updateGlobalGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::updateGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new grid and merge it with the current one. </p>
<p>This method is used for refinement with user specified anisotropic weights. As such, it can be called only for global grids with a nested rule. If there are no loaded points (or if the number of outputs is zero) then this is equivalent to calling <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a> (i.e., completely replacing the grid) using the current <b>dimensions</b>, <b>outputs</b>, and <b>rule</b> parameters and the new values for <b>depth</b>, <b>type</b>, anisotropic coefficients and level limits. If there are loaded model values, then the new grid will be added to the existing one without removing any existing points.</p>
<p>The parameters used and the thrown exceptions are identical to those in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a9790fc9925342d9416dbddb2342637d5" title="Make a Global Grid using Lagrange polynomials with support over the entire domain.">makeGlobalGrid()</a>. In addition, <b>std::runtime_error</b> is thrown if the current grid is not Global. </p>

</div>
</div>
<a id="ae2a5e7d613d3101b31c2101c55d8f8f9" name="ae2a5e7d613d3101b31c2101c55d8f8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a5e7d613d3101b31c2101c55d8f8f9">&#9670;&#160;</a></span>updateGlobalGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::updateGlobalGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>Array dimensions are not checked, otherwise identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa3844fa4877ed768db7a25c70b207899" title="Construct a new grid and merge it with the current one.">updateGlobalGrid()</a>. </p>

</div>
</div>
<a id="aaad3a5f9304cb39236f1bde2177a71ba" name="aaad3a5f9304cb39236f1bde2177a71ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad3a5f9304cb39236f1bde2177a71ba">&#9670;&#160;</a></span>updateSequenceGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::updateSequenceGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new grid and merge it with the current one. </p>
<p>This method is used for refinement with user specified anisotropic weights. If there are no loaded points (or if the number of outputs is zero) then this is equivalent to calling <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#add5d51d4a5cddb0753f8a38dee15fb18" title="Make Sequence Grid using Newton polynomials with support over the entire domain.">makeSequenceGrid()</a> (i.e., completely replacing the grid) using the current <b>dimensions</b>, <b>outputs</b>, and <b>rule</b> parameters and the new values for <b>depth</b>, <b>type</b>, anisotropic coefficients and level limits. If there are loaded model values, then the new grid will be added to the existing one without removing any existing points.</p>
<p>The parameters used and the thrown exceptions are identical to those in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#add5d51d4a5cddb0753f8a38dee15fb18" title="Make Sequence Grid using Newton polynomials with support over the entire domain.">makeSequenceGrid()</a>. In addition, <b>std::runtime_error</b> is thrown if the current grid is not Sequence. </p>

</div>
</div>
<a id="a13c25461dd243b59abd771b6ebb7c630" name="a13c25461dd243b59abd771b6ebb7c630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c25461dd243b59abd771b6ebb7c630">&#9670;&#160;</a></span>updateSequenceGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::updateSequenceGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>Array dimensions are not checked, otherwise identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aaad3a5f9304cb39236f1bde2177a71ba" title="Construct a new grid and merge it with the current one.">updateSequenceGrid()</a>. </p>

</div>
</div>
<a id="a67f090d1f36da85a708a0998bf30a188" name="a67f090d1f36da85a708a0998bf30a188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f090d1f36da85a708a0998bf30a188">&#9670;&#160;</a></span>updateFourierGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::updateFourierGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new grid and merge it with the current one. </p>
<p>This method is used for refinement with user specified anisotropic weights. If there are no loaded points (or if the number of outputs is zero) then this is equivalent to calling <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2277a336a8e37728a61b5f2932487de2" title="Make a Fourier grid using trigonometric basis with support over the entire domain.">makeFourierGrid()</a> (i.e., completely replacing the grid) using the current <b>dimensions</b>, <b>outputs</b>, and <b>rule</b> parameters and the new values for <b>depth</b>, <b>type</b>, anisotropic coefficients and level limits. If there are loaded model values, then the new grid will be added to the existing one without removing any existing points.</p>
<p>The parameters used and the thrown exceptions are identical to those in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a2277a336a8e37728a61b5f2932487de2" title="Make a Fourier grid using trigonometric basis with support over the entire domain.">makeFourierGrid()</a>. In addition, <b>std::runtime_error</b> is thrown if the current grid is not Fourier. </p>

</div>
</div>
<a id="aae0e02a1708164d2f42ef319575f513d" name="aae0e02a1708164d2f42ef319575f513d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0e02a1708164d2f42ef319575f513d">&#9670;&#160;</a></span>updateFourierGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::updateFourierGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>Array dimensions are not checked, otherwise identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a67f090d1f36da85a708a0998bf30a188" title="Construct a new grid and merge it with the current one.">updateFourierGrid()</a>. </p>

</div>
</div>
<a id="ac54ac6202ec15150fd22f9c68bc9c920" name="ac54ac6202ec15150fd22f9c68bc9c920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54ac6202ec15150fd22f9c68bc9c920">&#9670;&#160;</a></span>updateGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::updateGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Based on the grid type, calls <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa3844fa4877ed768db7a25c70b207899" title="Construct a new grid and merge it with the current one.">updateGlobalGrid()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aaad3a5f9304cb39236f1bde2177a71ba" title="Construct a new grid and merge it with the current one.">updateSequenceGrid()</a> or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a67f090d1f36da85a708a0998bf30a188" title="Construct a new grid and merge it with the current one.">updateFourierGrid()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is not Global, Sequence or Fourier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a396b74c826a3cc6590ae41b740722d" name="a4a396b74c826a3cc6590ae41b740722d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a396b74c826a3cc6590ae41b740722d">&#9670;&#160;</a></span>updateGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::updateGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>Array dimensions are not checked, otherwise identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a67f090d1f36da85a708a0998bf30a188" title="Construct a new grid and merge it with the current one.">updateFourierGrid()</a>. </p>

</div>
</div>
<a id="a99e0227c26396eb530ac8f6b0f2a2ae9" name="a99e0227c26396eb530ac8f6b0f2a2ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e0227c26396eb530ac8f6b0f2a2ae9">&#9670;&#160;</a></span>getCustomRuleDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * TasGrid::TasmanianSparseGrid::getCustomRuleDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the character string that is the description of the user-provided tabulated rule. </p>
<p>User-provided rules, i.e., Global grids with <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a7597d0c89be786bb966355bc34b4e0f0" title="User provided rule, nodes and weights must be provided with a separate file.">TasGrid::rule_customtabulated</a> have a description string that is returned by this method. All other grids and rules will return an empty string. </p>

</div>
</div>
<a id="ae5f6ca18129b711842eae96e29c955e4" name="ae5f6ca18129b711842eae96e29c955e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f6ca18129b711842eae96e29c955e4">&#9670;&#160;</a></span>getLoadedPoints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getLoadedPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the points already associated with model values. </p>
<p>Returns a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> with the coordinates of the loaded points. The vector is logically divided into strips of length <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>, each strip corresponds to a single point. </p>

</div>
</div>
<a id="a14908b6de77f777723ef0b1a4c26142d" name="a14908b6de77f777723ef0b1a4c26142d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14908b6de77f777723ef0b1a4c26142d">&#9670;&#160;</a></span>getLoadedPoints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getLoadedPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that accepts the vector as a parameter. </p>
<p>The vector is resized to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and overwritten with the loaded points. See <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae5f6ca18129b711842eae96e29c955e4" title="Return the points already associated with model values.">getLoadedPoints()</a>. </p>

</div>
</div>
<a id="a206fd0d5bdbaa86637f0e931f7748012" name="a206fd0d5bdbaa86637f0e931f7748012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206fd0d5bdbaa86637f0e931f7748012">&#9670;&#160;</a></span>getLoadedPoints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getLoadedPoints </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-array, writes the loaded points to the first <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> entries of the array. </p>
<p>Assumes the array size if at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>, overwrites the entries with the loaded points in the same format as in <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae5f6ca18129b711842eae96e29c955e4" title="Return the points already associated with model values.">getLoadedPoints()</a>. </p>

</div>
</div>
<a id="a06cb7e7175784ab10c1e6267dc718ebb" name="a06cb7e7175784ab10c1e6267dc718ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cb7e7175784ab10c1e6267dc718ebb">&#9670;&#160;</a></span>getNeededPoints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getNeededPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the points that require model values. </p>
<p>Returns a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> with the coordinates of the needed points. The vector is logically divided into strips of length <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>, each strip corresponds to a single point. </p>

</div>
</div>
<a id="a21852e90b2f7542bd0743ec232a2468c" name="a21852e90b2f7542bd0743ec232a2468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21852e90b2f7542bd0743ec232a2468c">&#9670;&#160;</a></span>getNeededPoints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getNeededPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that accepts the vector as a parameter. </p>
<p>The vector is resized to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and overwritten with the needed points. See <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a>. </p>

</div>
</div>
<a id="a43614bf94e7d7a2b44c8e1ee9ac40a72" name="a43614bf94e7d7a2b44c8e1ee9ac40a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43614bf94e7d7a2b44c8e1ee9ac40a72">&#9670;&#160;</a></span>getNeededPoints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getNeededPoints </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-array, writes the loaded points to the first <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> entries of the array. </p>
<p>Assumes the array size if at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>, overwrites the entries with the loaded points in the same format as in <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a>. </p>

</div>
</div>
<a id="a6c92561d8654d227e341438d92b3a2be" name="a6c92561d8654d227e341438d92b3a2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c92561d8654d227e341438d92b3a2be">&#9670;&#160;</a></span>getPoints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the loaded points if any, otherwise returns the needed points. </p>
<p>Grid operations that do not require model values, e.g., <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3b1c5a9c46ed61a61b36d96b1f6b9be3" title="Returns a vector of size getNumPoints() of the quadrature weights of the grid.">getQuadratureWeights()</a>, operate with the loaded points, but in some cases all points may be needed, e.g., right after a make method is called. Thus, points is an alias to the loaded points unless there are no loaded points, in which case points aliases to the needed points. The overloads of this method have the same behavior as the corresponding overload of the other get points methods.</p>
<p>Note that if <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> is zero then the grid is <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad714e9e2ca10e99cda523bd353781b78" title="Returns true if the grid is empty (no type), false otherwise.">empty()</a>. </p>

</div>
</div>
<a id="a57f17ec6ba8cb8507a0aab2af8782236" name="a57f17ec6ba8cb8507a0aab2af8782236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f17ec6ba8cb8507a0aab2af8782236">&#9670;&#160;</a></span>getPoints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that accepts the vector as a parameter. </p>
<p>See <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a>. </p>

</div>
</div>
<a id="aaf9f338c4594431e83c904133360f69b" name="aaf9f338c4594431e83c904133360f69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9f338c4594431e83c904133360f69b">&#9670;&#160;</a></span>getPoints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getPoints </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that accepts the raw array as an input. </p>
<p>See <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a>. </p>

</div>
</div>
<a id="a3b1c5a9c46ed61a61b36d96b1f6b9be3" name="a3b1c5a9c46ed61a61b36d96b1f6b9be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1c5a9c46ed61a61b36d96b1f6b9be3">&#9670;&#160;</a></span>getQuadratureWeights() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getQuadratureWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> of the quadrature weights of the grid. </p>
<p>The quadrature is designed to work with weight of constant 1 unless the grid <b>rule</b> is associated with a special weight. See <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2" title="Used to specify the one dimensional family of rules that induces the sparse grid.">TasGrid::TypeOneDRule</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> holding the quadrature weights; the order of the weights matches the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a>. </dd></dl>

</div>
</div>
<a id="a49b4ddf376167977a4ebc4733a1048e5" name="a49b4ddf376167977a4ebc4733a1048e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b4ddf376167977a4ebc4733a1048e5">&#9670;&#160;</a></span>getQuadratureWeights() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getQuadratureWeights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that accepts the vector as a parameter. </p>
<p>See <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3b1c5a9c46ed61a61b36d96b1f6b9be3" title="Returns a vector of size getNumPoints() of the quadrature weights of the grid.">getQuadratureWeights()</a>. </p>

</div>
</div>
<a id="a8f05fa86976ca28513c2d0fd3f4f1236" name="a8f05fa86976ca28513c2d0fd3f4f1236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f05fa86976ca28513c2d0fd3f4f1236">&#9670;&#160;</a></span>getQuadratureWeights() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getQuadratureWeights </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weights</em>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that accepts the raw array as an input. </p>
<p>See <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3b1c5a9c46ed61a61b36d96b1f6b9be3" title="Returns a vector of size getNumPoints() of the quadrature weights of the grid.">getQuadratureWeights()</a>. </p>

</div>
</div>
<a id="ab448a4aa17ef3eee59f8e8dcb55dd769" name="ab448a4aa17ef3eee59f8e8dcb55dd769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab448a4aa17ef3eee59f8e8dcb55dd769">&#9670;&#160;</a></span>getInterpolationWeights() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getInterpolationWeights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights of the model outputs that combine to construct the approximation value at <b>x</b>. </p>
<p>The sum of the model values times the weights will produce the approximation at <b>x</b>. For problems where the model outputs can be represented by a vector, it is recommended to use <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a> and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> methods which have much better performance. However, not all models can be easily represented as vector valued functions, e.g., the discretization of the operators in a parametrized partial differential equation can result in sparse matrices with very different fill. Therefore, Tasmanian offers the option to compute these weights and leave to the user to compute the corresponding weighted sum, e.g., the matrix for each grid point is stored independently and the action of the parametrized operator onto the vector is approximated as a weighed linear combination of the individual matrix vector results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> with the coordinates of the point of interest in the transformed domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> with the interpolation weights, the order of the weights matches the order of the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a>.</dd></dl>
<p>Note that using a vector <b>x</b> outside of the domain will result in undefined behavior, but will not throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <b>x</b> has an incorrect size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34bad439633fc4ec836d3c7a6d6624e" name="ab34bad439633fc4ec836d3c7a6d6624e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34bad439633fc4ec836d3c7a6d6624e">&#9670;&#160;</a></span>getInterpolationWeights() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getInterpolationWeights </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>x</em>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that uses raw-array, does not check the array size. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab448a4aa17ef3eee59f8e8dcb55dd769" title="Returns the weights of the model outputs that combine to construct the approximation value at x.">getInterpolationWeights()</a> but does not throw if <b>x</b> is larger than <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>; however, using shorter <b>x</b> is undefined behavior and will likely segfault. </p>

</div>
</div>
<a id="a969d557cf43d6b749e0fa3c3656ea861" name="a969d557cf43d6b749e0fa3c3656ea861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969d557cf43d6b749e0fa3c3656ea861">&#9670;&#160;</a></span>getInterpolationWeights() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getInterpolationWeights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses the vector as a parameter. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab448a4aa17ef3eee59f8e8dcb55dd769" title="Returns the weights of the model outputs that combine to construct the approximation value at x.">getInterpolationWeights()</a> but the <b>weights</b> vector will be resized to size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> and the entries will be overwritten with the output of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab448a4aa17ef3eee59f8e8dcb55dd769" title="Returns the weights of the model outputs that combine to construct the approximation value at x.">getInterpolationWeights()</a>. </p>

</div>
</div>
<a id="aed3736b94b245231de100df06c7987df" name="aed3736b94b245231de100df06c7987df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3736b94b245231de100df06c7987df">&#9670;&#160;</a></span>getInterpolationWeights() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getInterpolationWeights </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weights</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses raw-array, does not check the array size. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab448a4aa17ef3eee59f8e8dcb55dd769" title="Returns the weights of the model outputs that combine to construct the approximation value at x.">getInterpolationWeights()</a> but does not throw if <b>x</b> is larger than <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>; the length of <b>x</b> must be at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and the length of <b>weighs</b> must be at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a>. </p>

</div>
</div>
<a id="ab08e2fff2eeed94ff10fea6b8a81b93d" name="ab08e2fff2eeed94ff10fea6b8a81b93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08e2fff2eeed94ff10fea6b8a81b93d">&#9670;&#160;</a></span>getDifferentiationWeights() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getDifferentiationWeights </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights of the model outputs that combine to construct the approximate Jacobian matrix (derivative) at <b>x</b>. </p>
<p>The Jacobian of the k-th output at <b>x</b> is the sum of the model values of the k-th output times the Jacobian of the nodal functions at <b>x</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> with the coordinates of the point of interest in the transformed domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> * <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> with the differentiation weights, the order of the weights matches the order of the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a>.</dd></dl>
<p>Note that using a vector <b>x</b> outside of the domain will result in undefined behavior, but will not throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <b>x</b> has an incorrect size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab64a5bcdd3379d221cd7dcfee55aaa8" name="aab64a5bcdd3379d221cd7dcfee55aaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab64a5bcdd3379d221cd7dcfee55aaa8">&#9670;&#160;</a></span>getDifferentiationWeights() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getDifferentiationWeights </td>
          <td>(</td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>x</em>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that uses raw-array, does not check the array size. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab08e2fff2eeed94ff10fea6b8a81b93d" title="Returns the weights of the model outputs that combine to construct the approximate Jacobian matrix (d...">getDifferentiationWeights()</a> but does not throw if <b>x</b> is larger than <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>; however, using shorter <b>x</b> is undefined behavior and will likely segfault. </p>

</div>
</div>
<a id="a05082fdbd002099dc0999757bd76814f" name="a05082fdbd002099dc0999757bd76814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05082fdbd002099dc0999757bd76814f">&#9670;&#160;</a></span>getDifferentiationWeights() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getDifferentiationWeights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses the vector as a parameter. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab08e2fff2eeed94ff10fea6b8a81b93d" title="Returns the weights of the model outputs that combine to construct the approximate Jacobian matrix (d...">getDifferentiationWeights()</a> but the <b>weights</b> vector will be resized to size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> * <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and the entries will be overwritten with the output of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab08e2fff2eeed94ff10fea6b8a81b93d" title="Returns the weights of the model outputs that combine to construct the approximate Jacobian matrix (d...">getDifferentiationWeights()</a>. </p>

</div>
</div>
<a id="a2140bd3867ada4e0828e22824d6e68d5" name="a2140bd3867ada4e0828e22824d6e68d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2140bd3867ada4e0828e22824d6e68d5">&#9670;&#160;</a></span>getDifferentiationWeights() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getDifferentiationWeights </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weights</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses raw-array, does not check the array size. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab08e2fff2eeed94ff10fea6b8a81b93d" title="Returns the weights of the model outputs that combine to construct the approximate Jacobian matrix (d...">getDifferentiationWeights()</a> but does not throw if <b>x</b> is larger than <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>; the length of <b>x</b> must be at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and the length of <b>weighs</b> must be at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> * <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>. </p>

</div>
</div>
<a id="af9a9e720271b111893fdcd7e70a4ff3e" name="af9a9e720271b111893fdcd7e70a4ff3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a9e720271b111893fdcd7e70a4ff3e">&#9670;&#160;</a></span>loadNeededValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::loadNeededValues </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the values of the model outputs at the needed points, or overwrites the currently loaded points. </p>
<p>In order to construct an interpolant, Tasmanian needs the values of the model outputs at each grid point. If there are needed points (i.e., <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a> is not zero), then <b>vals</b> must correspond to the model outputs at the needed points, otherwise, it must correspond to the loaded points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>A vector that is logically divided into strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> each strip corresponding to a single point. The order of the outputs must match the order of the points from either <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a06cb7e7175784ab10c1e6267dc718ebb" title="Return the points that require model values.">getNeededPoints()</a> or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae5f6ca18129b711842eae96e29c955e4" title="Return the points already associated with model values.">getLoadedPoints()</a>. If <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a> is zero, the total size must be <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a>, otherwise, it must be <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6aee5d2252c87b9d7cba380694243c41" title="Return the number of points that should be provided to the next call of loadNeededValues().">getNumNeeded()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <b>vals</b> has an incorrect size.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The needed points can always be cleared with <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa2c461cb4699df8844812e6bf9f23872" title="Remove all needed points from the grid.">clearRefinement()</a> and new needed points can be assigned with <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abeedfde8e084afd6db031faf7d81a482" title="Set refinement using anisotropic estimate for the optimal points.">setAnisotropicRefinement()</a> or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a>. </p>

</div>
</div>
<a id="a3217125cade60ca65e476f5a22531551" name="a3217125cade60ca65e476f5a22531551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3217125cade60ca65e476f5a22531551">&#9670;&#160;</a></span>loadNeededValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::loadNeededValues </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses a raw-array, does not check the array size. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adcb888a2375dcbb51775b3a894eb32df" title="Alias of loadNeededValues().">loadNeededPoints()</a> but does not throw if <b>vals</b> has an incorrect size (but will segfault). </p>

</div>
</div>
<a id="aa7567a695e37d9c4188933653e35bf30" name="aa7567a695e37d9c4188933653e35bf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7567a695e37d9c4188933653e35bf30">&#9670;&#160;</a></span>loadNeededPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::loadNeededPoints </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that uses a raw-array, does not check the array size. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adcb888a2375dcbb51775b3a894eb32df" title="Alias of loadNeededValues().">loadNeededPoints()</a> but does not throw if <b>vals</b> has an incorrect size (but will segfault). </p>

</div>
</div>
<a id="a21324f2dd05df67569024b3e87f48bb5" name="a21324f2dd05df67569024b3e87f48bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21324f2dd05df67569024b3e87f48bb5">&#9670;&#160;</a></span>getLoadedValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double * TasGrid::TasmanianSparseGrid::getLoadedValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the model values that have been loaded in the gird. </p>
<p>Returns a pointer to the internal data-structures, which <b>must</b> <b>not</b> be modified and will be invalidated by any operation that affects the loaded points, e.g., <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa5b56474f1ce23a77b0f62a7bd8c9ee3" title="Merges the loaded and needed points into a single grid, resets all loaded values to zero.">mergeRefinement()</a> or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a>. The model values will follow the internal Tasmanian order, identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae5f6ca18129b711842eae96e29c955e4" title="Return the points already associated with model values.">getLoadedPoints()</a>. </p>

</div>
</div>
<a id="a30cbf78f4e11a953ee964576a3a70840" name="a30cbf78f4e11a953ee964576a3a70840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cbf78f4e11a953ee964576a3a70840">&#9670;&#160;</a></span>evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the interpolant (or point-wise approximation) at the given point <b>x</b>. </p>
<p>This is the reference implementation that does not use any acceleration mode even if one is set. As a result, the calls to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> are thread-safe but potentially slow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>indicates the coordinate entries of a point within the domain of the sparse grid, the size must be equal to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>will contain the approximated model outputs corresponding to <b>x</b>, the vector will be resized to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <b>x</b> has an incorrect size.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> calling <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> for a point outside of the domain is Mathematically incorrect, even though no exception will be generated. </p>

</div>
</div>
<a id="a32c4d8007bd527ec37fc6c6fe7b71ffa" name="a32c4d8007bd527ec37fc6c6fe7b71ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c4d8007bd527ec37fc6c6fe7b71ffa">&#9670;&#160;</a></span>evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluate </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses raw-arrays, does not check the array size. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> but does not throw, assumes <b>x</b> has size at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and <b>y</b> is at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a>, will segfault if either is too short. </p>

</div>
</div>
<a id="a7e35f5abc8315c4af97b1abb7e191d85" name="a7e35f5abc8315c4af97b1abb7e191d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e35f5abc8315c4af97b1abb7e191d85">&#9670;&#160;</a></span>evaluateBatch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateBatch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; FloatType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FloatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the interpolant (or point-wise approximation) for a batch of points. </p>
<p>Identical to calling <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> for each point defined by <b>x</b>, but uses the specified acceleration mode and is potentially much faster, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a> for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FloatType</td><td>is either <b>float</b> or <b>double</b> indicating the precision to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>is logically divided into strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> defining the coordinates of points within the sparse grid domain, see also <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>is logically divided into <b>x.size()</b> / <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> number of strips each with length <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a>, provides the approximated model outputs for each point defined by <b>x</b>. The vector will be resized, if the original size is incorrect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if instantiated with <b>float</b> and the current acceleration mode is neither CUDA nor MAGMA, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes:</b> this does not check if <b>x.size()</b> divides evenly.</p>
<p>The batch call: </p><div class="fragment"><div class="line">grid.evaluateBatch(x, y);</div>
</div><!-- fragment --><p> is Mathematically equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;x.size() / grid.getNumDimensions(); i++)</div>
<div class="line">     grid.evaluate(&amp;x[i * grid.getNumDimensions()],</div>
<div class="line">                   &amp;y[i * grid.getNumOutputs()]);</div>
</div><!-- fragment --><p> However, depending on the acceleration mode, the performance can be significantly different. </p>

</div>
</div>
<a id="aba8c743f9205db5cd8c69d0a7a45c84f" name="aba8c743f9205db5cd8c69d0a7a45c84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8c743f9205db5cd8c69d0a7a45c84f">&#9670;&#160;</a></span>evaluateBatch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateBatch </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses raw-arrays. </p>
<p>Raw-arrays do not provide size, thus the user must specify the number of points and the arrays are assumed to have sufficient size (otherwise the call will segfault). See also <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>is logically organized into <b>num_x</b> strips of length <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>, each strip will hold the coordinates of a point within the sparse grid domain.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_x</td><td>is the total number of points stored in <b>x</b>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>is logically organized into <b>num_x</b> strips of length <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a>, each strip will be overwritten with the corresponding approximated model outputs.</td></tr>
  </table>
  </dd>
</dl>
<p>The following two calls are equivalent: </p><div class="fragment"><div class="line">grid.evaluateBatch(x, y); <span class="comment">// using containers</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">grid.evaluateBatch(x.data(), x.size() / grid.getNumDimensions(), y.data()); <span class="comment">// using raw arrays</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a44de3a7c92c8b7d0abf4db4917377816" name="a44de3a7c92c8b7d0abf4db4917377816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44de3a7c92c8b7d0abf4db4917377816">&#9670;&#160;</a></span>evaluateBatch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateBatch </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using single precision and GPU/CUDA acceleration. </p>
<p>Works identical to the other raw-array overload but works only with CUDA and MAGMA acceleration modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>see the double precision array overload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_x</td><td>see the double precision array overload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>see the double precision array overload</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the acceleration mode is not CUDA or MAGMA, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>from failed calls to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adf49fb81aeb1886bf82b2e6e0b92f31d" title="Overload that uses GPU raw-arrays.">evaluateBatchGPU()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf49fb81aeb1886bf82b2e6e0b92f31d" name="adf49fb81aeb1886bf82b2e6e0b92f31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf49fb81aeb1886bf82b2e6e0b92f31d">&#9670;&#160;</a></span>evaluateBatchGPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateBatchGPU </td>
          <td>(</td>
          <td class="paramtype">const FloatType&#160;</td>
          <td class="paramname"><em>gpu_x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu_num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType&#160;</td>
          <td class="paramname"><em>gpu_y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses GPU raw-arrays. </p>
<p>Identical to the raw-array version of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a>, but <b>gpu_x</b> and <b>gpu_y</b> must point to memory allocated on the CUDA device matching <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a037284049ec188a606d1b41ce3d2c92f" title="Returns the currently set CUDA device.">getGPUID()</a>. Requires that Tasmanian was compiled with CUDA support and CUDA (or MAGAMA) acceleration mode has been enabled.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Tasmanian was not build with <b>-DTasmanian_ENABLE_CUDA=ON</b>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if calling for a grid type that doesn't have appropriate CUDA kernels, e.g., local polynomial or wavelet grids with order more than 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29c041f02cec68b17258be4f41f18010" name="a29c041f02cec68b17258be4f41f18010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c041f02cec68b17258be4f41f18010">&#9670;&#160;</a></span>evaluateFast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateFast </td>
          <td>(</td>
          <td class="paramtype">const FloatType&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType&#160;</td>
          <td class="paramname"><em>y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> with enabled acceleration or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a> with a batch of one point. </p>
<p>Some use cases still require performance but cannot batch multiple points together. The <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a29c041f02cec68b17258be4f41f18010" title="Equivalent to evaluate() with enabled acceleration or evaluateBatch() with a batch of one point.">evaluateFast()</a> method will work the same as <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a>, but will use the specified acceleration mode.</p>
<p><b>Note:</b> in older versions of Tasmanian, this function used to call a different set of algorithms optimized for single point evaluations; currently, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a> will automatically switch to the appropriate mode depending on <b>x.size()</b> and <b>num_x</b>. Thus, this method is now an alias to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a>. </p>

</div>
</div>
<a id="a74a3e006e0b97eb7ad8e2f7c5fa769b8" name="a74a3e006e0b97eb7ad8e2f7c5fa769b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a3e006e0b97eb7ad8e2f7c5fa769b8">&#9670;&#160;</a></span>evaluateFast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateFast </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; FloatType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FloatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a>. </p>
<p>Provided for consistency and backwards compatibility. </p>

</div>
</div>
<a id="a939ee80c26cd714518107a6718f97e95" name="a939ee80c26cd714518107a6718f97e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939ee80c26cd714518107a6718f97e95">&#9670;&#160;</a></span>integrate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::integrate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the integral of each model output over the sparse grid domain. </p>
<p>The integration weight is assumed 1 unless another weight is associated with the underlying one dimensional rule, see <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2" title="Used to specify the one dimensional family of rules that induces the sparse grid.">TasGrid::TypeOneDRule</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>will be resized to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> and overwritten with the approximated integral of each model output.</td></tr>
  </table>
  </dd>
</dl>
<p>The output of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6a0574dcaa0a03d68f583fbf9bf34d2a" title="Overload that returns a vector.">integrate()</a> is Mathematically equivalent to calling <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3b1c5a9c46ed61a61b36d96b1f6b9be3" title="Returns a vector of size getNumPoints() of the quadrature weights of the grid.">getQuadratureWeights()</a> and computing the sum of model values times weights. However, when the model values have been loaded <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6a0574dcaa0a03d68f583fbf9bf34d2a" title="Overload that returns a vector.">integrate()</a> is faster and more convenient. </p>

</div>
</div>
<a id="afe014455d9517ae1517fdb9a92c0bbba" name="afe014455d9517ae1517fdb9a92c0bbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe014455d9517ae1517fdb9a92c0bbba">&#9670;&#160;</a></span>integrate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::integrate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses a raw-array. </p>
<p>Equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6a0574dcaa0a03d68f583fbf9bf34d2a" title="Overload that returns a vector.">integrate()</a> but <b>q</b> must have sufficient size to write the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>must have size of at least <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35b06e4357796cdf4bbcf0294f895130" name="a35b06e4357796cdf4bbcf0294f895130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b06e4357796cdf4bbcf0294f895130">&#9670;&#160;</a></span>differentiate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::differentiate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative (if available) of the surrogate model at an input point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the point of interest where the Jacobian should be evaluated. </td></tr>
    <tr><td class="paramname">jacobian</td><td>will be resized to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> * <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and overwritten with the Jacobian matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c191937fa931777bf5f1ab332038177" name="a2c191937fa931777bf5f1ab332038177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c191937fa931777bf5f1ab332038177">&#9670;&#160;</a></span>differentiate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::differentiate </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>jacobian</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses a raw-array. </p>
<p>Equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b06e4357796cdf4bbcf0294f895130" title="Computes the derivative (if available) of the surrogate model at an input point.">differentiate()</a> but <b>jacobian</b> must have sufficient size to write the result. </p>

</div>
</div>
<a id="ad05292623b53a824962fe1edb716704f" name="ad05292623b53a824962fe1edb716704f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05292623b53a824962fe1edb716704f">&#9670;&#160;</a></span>setDomainTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setDomainTransform </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a linear domain transformation. </p>
<p>By default integration and interpolation are performed on a canonical interval [-1, 1], with the exception of Fourier grids using [0, 1] and some Gauss rules, see <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2" title="Used to specify the one dimensional family of rules that induces the sparse grid.">TasGrid::TypeOneDRule</a>. The linear transformation will shift the interval to an arbitrary [a, b] (or shift and scale for the unbounded case). Different values can be specified for each dimension and the transformation will be automatically applied to every operation that uses points, e.g., <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a> and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30cbf78f4e11a953ee964576a3a70840" title="Computes the value of the interpolant (or point-wise approximation) at the given point x.">evaluate()</a> will return/accept only transformed points.</p>
<p>Setting or changing the transformation will change the points and weights, therefore, the transformations should be set immediately after calling a make command and before calling get-points or computing model values. Changing the transformation will not throw, but will likely invalidate the loaded data and should be used with extreme caution (the validity of the underlying Mathematics is left to the user to analyze).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>with size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> specifies the <b>a</b> transformation parameter for each input </td></tr>
    <tr><td class="paramname">b</td><td>with size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> specifies the <b>b</b> transformation parameter for each input</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is empty. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if either input has incorrect size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae35a4e4b8369a29145933ec9cf695862" name="ae35a4e4b8369a29145933ec9cf695862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35a4e4b8369a29145933ec9cf695862">&#9670;&#160;</a></span>setDomainTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setDomainTransform </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a> but does not check for the size of <b>a</b> and <b>b</b>, although it still checks if the grid is empty. </p>

</div>
</div>
<a id="a5c43417f57606e0390db95514878bede" name="a5c43417f57606e0390db95514878bede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c43417f57606e0390db95514878bede">&#9670;&#160;</a></span>isSetDomainTransfrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TasGrid::TasmanianSparseGrid::isSetDomainTransfrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <b>true</b> if a linear domain transformation has been set, <b>false</b> otherwise. </p>
<p>Allows to check if there is a set transformation or if working on the canonical domain. </p>

</div>
</div>
<a id="a6c9056f3c6e2b19d85863c81b8c41aea" name="a6c9056f3c6e2b19d85863c81b8c41aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9056f3c6e2b19d85863c81b8c41aea">&#9670;&#160;</a></span>clearDomainTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::clearDomainTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the domain transformation. </p>
<p>Use with extreme caution, see <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a>. </p>

</div>
</div>
<a id="a5f7268590a793656253d54970f8bedd3" name="a5f7268590a793656253d54970f8bedd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7268590a793656253d54970f8bedd3">&#9670;&#160;</a></span>getDomainTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getDomainTransform </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the two vectors used to call <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a>. </p>
<p>If the grid is empty or if no transformation has been set, this will return empty vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>will be resized to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and overwritten with the a vector of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>will be resized to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and overwritten with the b vector of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> this works the same regardless of which <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a> overload has been used. </p>

</div>
</div>
<a id="a0bcdfd6fa7a5489b106c2c83213f7251" name="a0bcdfd6fa7a5489b106c2c83213f7251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcdfd6fa7a5489b106c2c83213f7251">&#9670;&#160;</a></span>getDomainTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getDomainTransform </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the values of the two vectors used to call <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a>. </p>
<p>Assuming that the inputs have sufficient size, will overwrite the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> entries with the domain transformation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is empty or if the domain transformation has not been set.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> this works the same regardless of which <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad05292623b53a824962fe1edb716704f" title="Set a linear domain transformation.">setDomainTransform()</a> overload has been used. </p>

</div>
</div>
<a id="a17142448ed4f55a78b8d9d0a9dec3450" name="a17142448ed4f55a78b8d9d0a9dec3450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17142448ed4f55a78b8d9d0a9dec3450">&#9670;&#160;</a></span>setConformalTransformASIN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setConformalTransformASIN </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>truncation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set conformal transformation using truncated Maclaurin series of the arcsin() function. </p>
<p>Conformal transformations apply a non-linear map to the points, weights and basis functions of a grid, in an attempt to accelerate convergence for some types of functions. The objective is to expand the area of analytic extension of the target function and thus accelerate convergence; however, if applied to the wrong function, conformal transformations can deteriorate the accuracy. Characterizing the functions that would most benefit from conformal maps is an active area of research.</p>
<p>The truncated Maclaurin series of the arcsin() work well with functions that have a pole close to the edges of the domain. See:<br  />
P. Jantsch, C. G. Webster, <a href="https://link.springer.com/chapter/10.1007/978-3-319-75426-0_6" style="font-weight:bold">Sparse Grid Quadrature Rules Based on Conformal Mappings</a>, Sparse Grids and Applications - Miami 2016 pp 117&ndash;134.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">truncation</td><td>is a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> that indicates the number of terms to keep in each direction. The more terms, the more pronounced the transformation becomes; however, too many terms can in fact produce a pole even worse than the original. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a724e63b8ccccdf44169a6433cb2fa97c" name="a724e63b8ccccdf44169a6433cb2fa97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724e63b8ccccdf44169a6433cb2fa97c">&#9670;&#160;</a></span>clearLevelLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::clearLevelLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the currently set level limits. </p>
<p>Once level limits have been set (by either the make or set-refinement commands), the limits will be used for all follow-on commands unless either overwritten with a new set of limits of cleared with this command. </p>

</div>
</div>
<a id="a2a2b507fe96772d2060e4b383587a3b1" name="a2a2b507fe96772d2060e4b383587a3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2b507fe96772d2060e4b383587a3b1">&#9670;&#160;</a></span>getLevelLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; TasGrid::TasmanianSparseGrid::getLevelLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the currently set level limits. </p>
<p>Returns the limits that have been set with the last command. If no limits have been set, an empty vector will be returned. </p>

</div>
</div>
<a id="abeedfde8e084afd6db031faf7d81a482" name="abeedfde8e084afd6db031faf7d81a482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeedfde8e084afd6db031faf7d81a482">&#9670;&#160;</a></span>setAnisotropicRefinement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setAnisotropicRefinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_growth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set refinement using anisotropic estimate for the optimal points. </p>
<p>Computes the anisotropic coefficients based on the current set of loaded points, then adds more points to the grid by selecting the points with largest coefficients. The new points are set to <b>needed</b>. See also <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a01d6976c4e8f488349192a1fd716ab92" title="Estimate the anisotropic rates of coefficient decay for different direction.">estimateAnisotropicCoefficients()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>indicates the type of estimate to use, e.g., total degree or curved; regardless of the specified rule the interpolation estimate is computed (not quadrature).</td></tr>
    <tr><td class="paramname">min_growth</td><td>is the minimum number of points to add to the grid, e.g., if the model can be executed in parallel then minimum number of points is needed to ensure occupancy for all computing resources. The value of <b>min_growth</b> can never be less than 1, but the actual number of points can exceed the <b>min_growth</b> depending on the weights and growth of the one dimensional rule.</td></tr>
    <tr><td class="paramname">output</td><td>indicates which output to use to compute the estimate, using -1 indicates to use all outputs (possible with Sequence and Fourier grids only, Global grids require a specific output).</td></tr>
    <tr><td class="paramname">level_limits</td><td>(if not empty) will be used to overwrite the currently set limits. The limits must be either empty or have size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>; if empty, the current set of limits will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if called during dynamic construction, or there are no loaded points, or there are no outputs.</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <b>min_growth</b> is not positive, <b>output</b> is out of range, or <b>level_limits</b> has the wrong size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00aa114128218c225e4fcfdbb89e8e8c" name="a00aa114128218c225e4fcfdbb89e8e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00aa114128218c225e4fcfdbb89e8e8c">&#9670;&#160;</a></span>setAnisotropicRefinement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setAnisotropicRefinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_growth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-array. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abeedfde8e084afd6db031faf7d81a482" title="Set refinement using anisotropic estimate for the optimal points.">setAnisotropicRefinement()</a> with the exception that level_limits is a raw array, empty is equivalent to <b>nullptr</b> and the size is not checked. </p>

</div>
</div>
<a id="a01d6976c4e8f488349192a1fd716ab92" name="a01d6976c4e8f488349192a1fd716ab92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d6976c4e8f488349192a1fd716ab92">&#9670;&#160;</a></span>estimateAnisotropicCoefficients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; TasGrid::TasmanianSparseGrid::estimateAnisotropicCoefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate the anisotropic rates of coefficient decay for different direction. </p>
<p>Available for Global, Sequence and Fourier grids, the anisotropic coefficients describe the space of the dominant basis functions needed to construct optimal approximation to the model. See the documentation of <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f" title="Used by Global Sequence and Fourier grids, indicates the selection criteria.">TasGrid::TypeDepth</a> of the different formulas. The estimate requires that values have been loaded in the grid, i.e., <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> &gt; 0 and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> &gt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>is the assumed type of optimal space, i.e., total degree, total degree with log-correction, or hyperbolic cross section. </td></tr>
    <tr><td class="paramname">output</td><td>determines the output to use for the inference of the coefficients, for Global grid it must be between 0 and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> -1, in other cases, it can also be set to -1 to indicate "all outputs" or for each basis use the larges coefficient among all outputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <b>xi</b> and <b>eta</b> (if used) parameters of the estimate indicated by <b>type</b>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is empty, has no outputs or no loaded points. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the output is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7653bf5f847592504bddb2edda7a0bdf" name="a7653bf5f847592504bddb2edda7a0bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7653bf5f847592504bddb2edda7a0bdf">&#9670;&#160;</a></span>estimateAnisotropicCoefficients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::estimateAnisotropicCoefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that writes the result to a parameter. </p>
<p>The inputs are equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a01d6976c4e8f488349192a1fd716ab92" title="Estimate the anisotropic rates of coefficient decay for different direction.">estimateAnisotropicCoefficients()</a> but the result is returned into <b>weights</b>. </p>

</div>
</div>
<a id="a555ded26e1a839b210eb21ac7b488d37" name="a555ded26e1a839b210eb21ac7b488d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555ded26e1a839b210eb21ac7b488d37">&#9670;&#160;</a></span>setSurplusRefinement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setSurplusRefinement </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence rule. </p>
<p>Using the relative magnitude of the surplus coefficients, add more points to the grid and set them to needed. The approach differs from the local (polynomial or wavelet) case in the interpretation of the surpluses, instead of local-spacial estimate the surpluses are interpreted as indicators of needed polynomial basis functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>indicates the cutoff threshold for refinement, points will not be included once the magnitude of the relative surplus drops below the tolerance. </td></tr>
    <tr><td class="paramname">output</td><td>indicates the output to use for the surpluses, the Sequence grid accepts -1 to indicate the use of all outputs. </td></tr>
    <tr><td class="paramname">level_limits</td><td>indicates a new set of limits, if empty the currently set limits will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the called during the construction process, if the grid is empty, of if the grid has no outputs or values. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the <b>output</b> is out of range, <b>tolerance</b> is negative, or if the <b>level_limits</b> has the wrong size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de67683567d3fbd6a712a01fc50e309" name="a3de67683567d3fbd6a712a01fc50e309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de67683567d3fbd6a712a01fc50e309">&#9670;&#160;</a></span>setSurplusRefinement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setSurplusRefinement </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>scale_correction</em> = <code>std::vector&lt;&#160;double&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refine the grid based on the surplus coefficients, Local-Polynomial and Wavelet grids. </p>
<p>Using the relative magnitude of the surplus coefficients, add more points to the grid and set them to needed. This method uses the hierarchical and local structure of the one dimensional rule and interprets the surplus as a local error indicator. The refinement can be combined with tests for completeness of the hierarchy (prioritizing parents or even the entire ancestry) or local anisotropy that can manifest even in globally isotropic cases. See <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed" title="Refinement strategy for local polynomial and wavelet grids.">TasGrid::TypeRefinement</a> for details.</p>
<p>If this method is called on a Global or a Sequence grid, the <b>criteria</b> will be ignored and the method will use the Global/Sequence variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>indicates the cutoff threshold for refinement, points will not be included once the magnitude of the relative surplus drops below the tolerance. </td></tr>
    <tr><td class="paramname">criteria</td><td>indicates how to prioritize the hierarchy and/or local anisotropy. </td></tr>
    <tr><td class="paramname">output</td><td>indicates a specific output to use for the refinement, by default (when -1) all model outputs will be considered together. </td></tr>
    <tr><td class="paramname">level_limits</td><td>indicates a new set of limits, if empty the currently set limits will be used. </td></tr>
    <tr><td class="paramname">scale_correction</td><td>is a set of weights that would multiply the surpluses before the tolerance test; the correction can be used to modify the threshold test (e.g., multiply the surplus by the integral of the basis functions) or to guide the refinement towards certain regions of the domain. The values of the correction terms are organized in order that matches the order of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> and there is one weight per active output (either 1 or <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> depending whether <b>output</b> is -1 or positive). If the scale correction is empty, then no correction is used (i.e., using correction of 1.0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if called during construction, or if the grid is empty or has no outputs or loaded points, of if the grid has incompatible type (not local polynomial or wavelet).</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <b>output</b> is out of range, of if the level limits and/or scale correction have incorrect size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8d180dca4c7e04857551ecd2538a229" name="ac8d180dca4c7e04857551ecd2538a229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d180dca4c7e04857551ecd2538a229">&#9670;&#160;</a></span>setSurplusRefinement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setSurplusRefinement </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>scale_correction</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that uses raw-arrays. </p>
<p>The <b>scale_correction</b> is a potentially large vector and using a raw array avoids a large data-copy when calling from C/Python/Fortran interfaces. Otherwise the method behaves the same, but does not throw if the arrays have incorrect size (will probably segfault). </p>

</div>
</div>
<a id="aa2c461cb4699df8844812e6bf9f23872" name="aa2c461cb4699df8844812e6bf9f23872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c461cb4699df8844812e6bf9f23872">&#9670;&#160;</a></span>clearRefinement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::clearRefinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all needed points from the grid. </p>
<p>Once a refinement is set, but before the new values have been loaded, the refinement can be canceled with this command. After this call, all needed points will be erased. </p>

</div>
</div>
<a id="aa5b56474f1ce23a77b0f62a7bd8c9ee3" name="aa5b56474f1ce23a77b0f62a7bd8c9ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b56474f1ce23a77b0f62a7bd8c9ee3">&#9670;&#160;</a></span>mergeRefinement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::mergeRefinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the loaded and needed points into a single grid, resets all loaded values to zero. </p>
<p>This method allows refinement to be used in cases where the model values cannot be computed at the grid points, e.g., when working with random or unstructured data. Once a refinement is set, the new points can be merged without model values which will result in a larger grid with all (previous and new) loaded values reset to 0.0. Afterwards, the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae25d400a7e8a28693f32a49959fe1833" title="Overwrites the current set of coefficients (and loaded values) with the ones provided.">setHierarchicalCoefficients()</a> method can be used to set a new set of coefficients, e.g., inferred from the data and the hierarchical basis values. </p>

</div>
</div>
<a id="a886e52d4b9180c468c80d9f2339e7608" name="a886e52d4b9180c468c80d9f2339e7608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886e52d4b9180c468c80d9f2339e7608">&#9670;&#160;</a></span>beginConstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::beginConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin a dynamic construction procedure. </p>
<p>Initializes the internal data-structures needed for the construction procedure (which is pretty cheap) and makes a call to <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa2c461cb4699df8844812e6bf9f23872" title="Remove all needed points from the grid.">clearRefinement()</a></b>.</p>
<p><b>Note:</b> after this call, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a> and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abeedfde8e084afd6db031faf7d81a482" title="Set refinement using anisotropic estimate for the optimal points.">setAnisotropicRefinement()</a> cannot be called until <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a1b233fa0fb01f435e9a9c1aa2dfec420" title="End the procedure, clears flags and unused constructed points, can go back to using regular refinemen...">finishConstruction()</a> is issued.</p>
<p><b>Note:</b> the construction process can be initiated before any model values have been loaded, in such case, the initial set of points will always come first in a call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">getCandidateConstructionPoints()</a>. </p>

</div>
</div>
<a id="ad0a1ad3fb58fa1e7ced8cbb59a051440" name="ad0a1ad3fb58fa1e7ced8cbb59a051440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a1ad3fb58fa1e7ced8cbb59a051440">&#9670;&#160;</a></span>isUsingConstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TasGrid::TasmanianSparseGrid::isUsingConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <b>true</b> if the dynamic construction procedure has been initialized, <b>false</b> otherwise. </p>
<p>Simply returns the internal flag. </p>

</div>
</div>
<a id="a7121e196e2f8e7bd5a1cc6a698231789" name="a7121e196e2f8e7bd5a1cc6a698231789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7121e196e2f8e7bd5a1cc6a698231789">&#9670;&#160;</a></span>getCandidateConstructionPoints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getCandidateConstructionPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a sorted list of points weighted by descending importance. </p>
<p>The <em>importance</em> is inferred from the user provided anisotropic weighs using the formula specified by the <b>type</b>, see <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f" title="Used by Global Sequence and Fourier grids, indicates the selection criteria.">TasGrid::TypeDepth</a>. The full tensor types will fallback to <b>type_level</b>.</p>
<p>Unlike the batch procedures in <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abeedfde8e084afd6db031faf7d81a482" title="Set refinement using anisotropic estimate for the optimal points.">setAnisotropicRefinement()</a>, there is no expectation that the entire batch is processed, in fact only a small subset of the most important points should be computed and loaded, then the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">getCandidateConstructionPoints()</a> should be called again and it will return an updated list of points. Enough points should be used from the top of the list to ensure occupancy across computing resources, e.g., CPU cores or MPI ranks, but the bottom set of points will contribute less and less to the overall accuracy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>sets the formula to use when weighting the potential points, see <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f" title="Used by Global Sequence and Fourier grids, indicates the selection criteria.">TasGrid::TypeDepth</a>. </td></tr>
    <tr><td class="paramname">anisotropic_weights</td><td>are the xi and eta parameters for the formula, the vector must have the correct size, either <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> or twice as much to handle the curved weights. </td></tr>
    <tr><td class="paramname">level_limits</td><td>(if not empty) will be used to overwrite the currently set limits. The limits must be either empty or have size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>; if empty, the current set of limits will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector organized in strips of length <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> that indicate the coordinates of the points to use as model inputs, unlike the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a> command, the points here are arranged in decreasing importance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is empty, Local Polynomial or this is called before <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a886e52d4b9180c468c80d9f2339e7608" title="Begin a dynamic construction procedure.">beginConstruction()</a>.</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the <b>anisotropic_weights</b> or <b>level_limits</b> have incorrect size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf7b9bf4ac3448c84662c2e17547f8bb" name="aaf7b9bf4ac3448c84662c2e17547f8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7b9bf4ac3448c84662c2e17547f8bb">&#9670;&#160;</a></span>getCandidateConstructionPoints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getCandidateConstructionPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Essentially the same as <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">getCandidateConstructionPoints()</a></b> but the weights are obtained from a call to <b><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a01d6976c4e8f488349192a1fd716ab92" title="Estimate the anisotropic rates of coefficient decay for different direction.">estimateAnisotropicCoefficients()</a></b>. </p>
<p>This method is the construction equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#abeedfde8e084afd6db031faf7d81a482" title="Set refinement using anisotropic estimate for the optimal points.">setAnisotropicRefinement()</a>. One notable difference is that this function will not throw if there are no loaded points, instead isotropic coefficient will be used until enough points are loaded so that estimates for the coefficients can be computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>sets the formula to use when weighting the potential points, see <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f" title="Used by Global Sequence and Fourier grids, indicates the selection criteria.">TasGrid::TypeDepth</a>. </td></tr>
    <tr><td class="paramname">output</td><td>indicates which coefficients will be used to estimate the anisotropic decay rate, when working with Sequence and Fourier grids this can be set to -1 to use all outputs. </td></tr>
    <tr><td class="paramname">level_limits</td><td>(if not empty) will be used to overwrite the currently set limits. The limits must be either empty or have size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>; if empty, the current set of limits will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector organized in strips of length <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> that indicate the coordinates of the points to use as model inputs, unlike the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6c92561d8654d227e341438d92b3a2be" title="Returns the loaded points if any, otherwise returns the needed points.">getPoints()</a> command, the points here are arranged in decreasing importance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is empty, Local Polynomial or this is called before <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a886e52d4b9180c468c80d9f2339e7608" title="Begin a dynamic construction procedure.">beginConstruction()</a>.</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the <b>level_limits</b> have incorrect size or <b>output</b> is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcc91b2f0cecb419ec314dc2812482a3" name="afcc91b2f0cecb419ec314dc2812482a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc91b2f0cecb419ec314dc2812482a3">&#9670;&#160;</a></span>getCandidateConstructionPoints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getCandidateConstructionPoints </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;&#160;int&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>scale_correction</em> = <code>std::vector&lt;&#160;double&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sorted list of points weighted by descending importance using the hierarchical surpluses. </p>
<p>This is the construction equivalent to the Local Polynomial <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a>. The inputs are the same as <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a> except the returned points will be sorted by decreasing surpluses. Similar to the other <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">getCandidateConstructionPoints()</a> overloads, this can be called before any model values have been loaded. </p>

</div>
</div>
<a id="afa1f2b9ae8a96023bbf529a78173daee" name="afa1f2b9ae8a96023bbf529a78173daee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1f2b9ae8a96023bbf529a78173daee">&#9670;&#160;</a></span>loadConstructedPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::loadConstructedPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add pairs of points with associated model values. </p>
<p>This is the construction equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a>, the main difference is that any number of points can be loaded here and the points can be in any arbitrary order (they have to correspond to the model values in this call only).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is a vector with strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> indicating the points where the model values were computed. The points do not have to be in any order; however, every point has to match a potential grid points. </td></tr>
    <tr><td class="paramname">y</td><td>is a vector with strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> indicating the model outputs corresponding each of the provided points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the number of strips in <b>y</b> are less than those in <b>x</b>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> regardless of the grid type and rule, as the depth/level increases the points become dense in the domain; thus every point is theoretically a potential grid points. However, if a random point is chosen than the level may easily overflow the range of the <b>int</b> type, the safest option is to make sure the points match the ones returned by <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">getCandidateConstructionPoints()</a>. </p>

</div>
</div>
<a id="acc6df5aee38e3e41ecb01a19a0e0e5b3" name="acc6df5aee38e3e41ecb01a19a0e0e5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6df5aee38e3e41ecb01a19a0e0e5b3">&#9670;&#160;</a></span>loadConstructedPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::loadConstructedPoints </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <b>loadConstructedPoint()</b> but using arrays in place of vectors (array size is not checked) </p>
<p>Does not throw on incorrect array size, but will likely segfault. </p>

</div>
</div>
<a id="a1b233fa0fb01f435e9a9c1aa2dfec420" name="a1b233fa0fb01f435e9a9c1aa2dfec420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b233fa0fb01f435e9a9c1aa2dfec420">&#9670;&#160;</a></span>finishConstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::finishConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End the procedure, clears flags and unused constructed points, can go back to using regular refinement. </p>
<p>After this call, the construction methods <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">getCandidateConstructionPoints()</a> and loadConstructedPoint() cannot be used until a new call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a886e52d4b9180c468c80d9f2339e7608" title="Begin a dynamic construction procedure.">beginConstruction()</a>.</p>
<p><b>Note:</b> finalizing the construction process can potentially lead to loss of data. The constructed points can be loaded in any order, but the points need to satisfy constraints before being incorporated within a grid. Some grids require that points form a lower complete set, or the point must form a connected graph, or there must be enough points to complete a tensor (when the rules grow by more than one point). In such scenarios, the points and values are stored in a temporary structure until enough data is present to add them to the grid. Finalizing the construction will delete all data for points that have not been incorporated yet. </p>

</div>
</div>
<a id="ae3b1e21762c8798d4185dbce18980095" name="ae3b1e21762c8798d4185dbce18980095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b1e21762c8798d4185dbce18980095">&#9670;&#160;</a></span>getHierarchicalCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double * TasGrid::TasmanianSparseGrid::getHierarchicalCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the internal data-structure that stores the hierarchical coefficients. </p>
<p>All types of grids (except Global grids), use a hierarchical basis representation where the interpolant is expressed as a set of coefficients times the basis functions. For Local Polynomial and Wavelet grids, the coefficients are commonly known as hierarchical surpluses; for Sequence grid, the coefficients correspond to the Newton polynomials; for Fourier grids, the coefficients are the linear combination of discrete Fourier transform coefficients.</p>
<p>The returned array has <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a> where each strip corresponds to one basis function. In the case of Fourier grids, the coefficients are complex numbers and (for performance reasons) the real and complex parts are stored separately, i.e., the first <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> strips hold the real parts and there is a second set of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> strips that hold the complex components. If the grid is empty or there are no outputs or no loaded points, then this returns <b>nullptr</b>.</p>
<p><b>Note:</b> modifying the coefficients through this pointer leads to undefined behavior, use <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae25d400a7e8a28693f32a49959fe1833" title="Overwrites the current set of coefficients (and loaded values) with the ones provided.">setHierarchicalCoefficients()</a> instead. </p>

</div>
</div>
<a id="ab4235ca9c02fb8e032c9498d707efd32" name="ab4235ca9c02fb8e032c9498d707efd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4235ca9c02fb8e032c9498d707efd32">&#9670;&#160;</a></span>getHierarchicalCoefficientsStatic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::getHierarchicalCoefficientsStatic </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the coefficients to the pre-allocated array, intended for internal use. . </p>

</div>
</div>
<a id="ae25d400a7e8a28693f32a49959fe1833" name="ae25d400a7e8a28693f32a49959fe1833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25d400a7e8a28693f32a49959fe1833">&#9670;&#160;</a></span>setHierarchicalCoefficients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setHierarchicalCoefficients </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites the current set of coefficients (and loaded values) with the ones provided. </p>
<p>Discards the current set of loaded values and the associated hierarchical coefficients, and replaces both with the data provided here. The coefficients are overwritten, while the values are inferred, i.e., the opposed from the use case of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a> where the model values are provided and the coefficients are computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>is a vector of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a74773f696fb6383f6c5caa2647519719" title="Return the number of points already associated with model values via loadNeededValues().">getNumLoaded()</a> strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a>, each strip corresponds to the coefficients of one basis function. Fourier coefficients are an exceptions as they require twice as many strips where the first set corresponds to the real components and the second set corresponds to the complex components of the coefficients.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>is the number of coefficients is incorrect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3534103dc8be7a328210e46d263bd4ad" name="a3534103dc8be7a328210e46d263bd4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3534103dc8be7a328210e46d263bd4ad">&#9670;&#160;</a></span>setHierarchicalCoefficients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setHierarchicalCoefficients </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that uses raw-arrays. </p>
<p>Identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae25d400a7e8a28693f32a49959fe1833" title="Overwrites the current set of coefficients (and loaded values) with the ones provided.">setHierarchicalCoefficients()</a> but does not check for the size of the array. </p>

</div>
</div>
<a id="ad68205bdd245e6f6f234a5c72435b14d" name="ad68205bdd245e6f6f234a5c72435b14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68205bdd245e6f6f234a5c72435b14d">&#9670;&#160;</a></span>evaluateHierarchicalFunctions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateHierarchicalFunctions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the values of the hierarchical function basis at the specified points. </p>
<p>The method for <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab448a4aa17ef3eee59f8e8dcb55dd769" title="Returns the weights of the model outputs that combine to construct the approximation value at x.">getInterpolationWeights()</a> computes the values of the nodal basis function, e.g., Lagrange polynomials, while this computes the values of the hierarchical functions, e.g., Newton polynomials. The call is optimized for multiple points at a time. The output consists of strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> and one strip corresponds to one point provided in <b>x</b>. Effectively this constructs a matrix in column major format where each column corresponds to a single input point <b>x</b> and each row corresponds to a single grid point.</p>
<p>When working with Fourier grids, the real and complex part of each basis is interlaced, i.e., the strip size is twice as large; see the array overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>has strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> indicating a point in the domain where the basis is to be computed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>will have the same number of strips with size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> (or twice that to accommodate the real and complex parts of the basis).</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> if the the output from <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae3b1e21762c8798d4185dbce18980095" title="Return a reference to the internal data-structure that stores the hierarchical coefficients.">getHierarchicalCoefficients()</a> is interpreted as a matrix in column major format with leading dimension of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a15ea595ac9b4b963f874544124aea62d" title="Return the outputs of the grid, i.e., number of model outputs.">getNumOutputs()</a>, and if the output of this call is interpreted as a matrix in column major format with leading dimension <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a>, then the result of the product of the coefficients times the basis will be equal to the result of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7e35f5abc8315c4af97b1abb7e191d85" title="Computes the value of the interpolant (or point-wise approximation) for a batch of points.">evaluateBatch()</a>. </p>

</div>
</div>
<a id="afcaf60b58f57dac66ee29de4c1929d84" name="afcaf60b58f57dac66ee29de4c1929d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcaf60b58f57dac66ee29de4c1929d84">&#9670;&#160;</a></span>evaluateHierarchicalFunctions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::evaluateHierarchicalFunctions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload that returns the result. </p>
<p>Useful for direct initialization of vectors. </p>

</div>
</div>
<a id="a6e6ebdcbe46af9138bd0ca71f790224b" name="a6e6ebdcbe46af9138bd0ca71f790224b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6ebdcbe46af9138bd0ca71f790224b">&#9670;&#160;</a></span>evaluateHierarchicalFunctions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateHierarchicalFunctions </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array overload, the inputs must have pre-allocated and correct size. </p>
<p>The size of <b>x</b> must be <b>num_x</b> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> and the size of <b>y</b> must be <b>num_x</b> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> (or twice that for the Fourier grids).</p>
<p>Example of returning the result in a vector of complex numbers: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a> grid = <a class="code hl_function" href="group__TasmanianSG.html#ga946aedd76d776e8669671026911755d1">TasGrid::makeFourierGrid</a>(...);</div>
<div class="line"><span class="keywordtype">int</span> num_x = ...; <span class="comment">// set the number of points</span></div>
<div class="line">std::vector&lt;double&gt; x(grid.<a class="code hl_function" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925">getNumDimensions</a>() * num_x);</div>
<div class="line"><span class="comment">// initialize x</span></div>
<div class="line">std::vector&lt;std::complex&lt;double&gt;&gt; y(grid.<a class="code hl_function" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133">getNumPoints</a>() * num_x);</div>
<div class="line">grid.<a class="code hl_function" href="classTasGrid_1_1TasmanianSparseGrid.html#ad68205bdd245e6f6f234a5c72435b14d">evaluateHierarchicalFunctions</a>(x.data(), num_x, <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(y.data()));</div>
<div class="line"><span class="comment">// at this point y is loaded with the complex numbers</span></div>
<div class="ttc" id="aclassTasGrid_1_1TasmanianSparseGrid_html"><div class="ttname"><a href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a></div><div class="ttdoc">The master-class that represents an instance of a Tasmanian sparse grid.</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:293</div></div>
<div class="ttc" id="aclassTasGrid_1_1TasmanianSparseGrid_html_a09a99fb1f72eb914a37dc92278e0c133"><div class="ttname"><a href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133">TasGrid::TasmanianSparseGrid::getNumPoints</a></div><div class="ttdeci">int getNumPoints() const</div><div class="ttdoc">Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:661</div></div>
<div class="ttc" id="aclassTasGrid_1_1TasmanianSparseGrid_html_ad68205bdd245e6f6f234a5c72435b14d"><div class="ttname"><a href="classTasGrid_1_1TasmanianSparseGrid.html#ad68205bdd245e6f6f234a5c72435b14d">TasGrid::TasmanianSparseGrid::evaluateHierarchicalFunctions</a></div><div class="ttdeci">void evaluateHierarchicalFunctions(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y) const</div><div class="ttdoc">Computes the values of the hierarchical function basis at the specified points.</div></div>
<div class="ttc" id="aclassTasGrid_1_1TasmanianSparseGrid_html_aeaed15359b94d960c8970c1d10178925"><div class="ttname"><a href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925">TasGrid::TasmanianSparseGrid::getNumDimensions</a></div><div class="ttdeci">int getNumDimensions() const</div><div class="ttdoc">Return the dimensions of the grid, i.e., number of model inputs.</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:642</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_ga946aedd76d776e8669671026911755d1"><div class="ttname"><a href="group__TasmanianSG.html#ga946aedd76d776e8669671026911755d1">TasGrid::makeFourierGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeFourierGrid(int dimensions, int outputs, int depth, TypeDepth type, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeFourierGrid().</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:2342</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a30f2fec64329b04aaf97fd7f02e83b64" name="a30f2fec64329b04aaf97fd7f02e83b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f2fec64329b04aaf97fd7f02e83b64">&#9670;&#160;</a></span>evaluateSparseHierarchicalFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateSparseHierarchicalFunctions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a sparse matrix with the values of the hierarchical basis functions. </p>
<p>The local basis functions associated with Local Polynomial and Wavelet grids means that only a small set of the basis functions will be non-zero at any given point in the domain. Effectively, the matrix build by <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad68205bdd245e6f6f234a5c72435b14d" title="Computes the values of the hierarchical function basis at the specified points.">evaluateHierarchicalFunctions()</a> will be sparse. This method generates the sparse matrix in compressed format in non-zeroes per entry in <b>x</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>has strips of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> indicating a point in the domain where the basis is to be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pntr</td><td>will have size one more than the number of strips in <b>x</b>, pntr[i] indicate the starting offsets of the entries for the i-th point, (the first entry will always be zero) and pntr.back() is the total number of non-zeros. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indx</td><td>holds the indexes of the supported basis functions, i.e., indx[pntr[i]] ... indx[pntr[i+1] - 1] are the indexes of the basis functions supported over the i-th point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vals</td><td>are the numeric values of the basis functions corresponding to the indexes in <b>indx</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3317411286e1f00cc0a0d752da389017" name="a3317411286e1f00cc0a0d752da389017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3317411286e1f00cc0a0d752da389017">&#9670;&#160;</a></span>getHierarchicalSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::getHierarchicalSupport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the support of the hierarchical functions. </p>
<p>The Global, Sequence and Fourier grids rely on basis functions with support over the entire domain. However, local-polynomial and wavelet grids have basis that is restricted to a hypercube centered at the corresponding point and with equal support in each direction. This method returns the length for each basis function and direction.</p>
<dl class="section return"><dt>Returns</dt><dd>either an empty vector (for an empty grid), or a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> times <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> organized in strips of length <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a>. Each strip corresponds to a basis function and if (in a some direction for some basis function) an x-point falls away from the corresponding grid point at a distance larger than the support, then the basis will evaluate to zero.</dd></dl>
<p><b>Note:</b> the support of all basis functions is logically restricted to the grid domain, i.e., the effective support equals the intersection of the hypercube and the domain. </p>

</div>
</div>
<a id="aa0784cd2d4edce9fa02e9d6bfcfe2b54" name="aa0784cd2d4edce9fa02e9d6bfcfe2b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0784cd2d4edce9fa02e9d6bfcfe2b54">&#9670;&#160;</a></span>integrateHierarchicalFunctions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::integrateHierarchicalFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integrals of the hierarchical basis functions. </p>
<p>Returns a vector of size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> that holds the integral of each basis function. If the output of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae3b1e21762c8798d4185dbce18980095" title="Return a reference to the internal data-structure that stores the hierarchical coefficients.">getHierarchicalCoefficients()</a> is interpreted as a matrix, the product of that matrix times this vector is the same as the output of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a939ee80c26cd714518107a6718f97e95" title="Computes the integral of each model output over the sparse grid domain.">TasmanianSparseGrid::integrate()</a>.</p>
<p>One use case of the integrals is to add scale correction to the surplus refinement, e.g., rescale the coefficients by the integral of the basis function: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> grid = <a class="code hl_function" href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a>(...);</div>
<div class="line"><span class="comment">// ... load values ... //</span></div>
<div class="line"><span class="keyword">auto</span> correction = grid.integrateHierarchicalFunctions();</div>
<div class="line">grid.setSurplusRefinement(1.E-4, <a class="code hl_enumvalue" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd">TasGrid::refine_classic</a>, 0, {}, correction);</div>
<div class="ttc" id="agroup__SGEnumerates_html_ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd"><div class="ttname"><a href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd">TasGrid::refine_classic</a></div><div class="ttdeci">@ refine_classic</div><div class="ttdoc">Isotropic refinement using only the children and disregarding missing parents.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:427</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_gaaa84e44ca8145727564dbb57e7c939a3"><div class="ttname"><a href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeLocalPolynomialGrid(int dimensions, int outputs, int depth, int order=1, TypeOneDRule rule=rule_localp, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeLocalPolynomialGrid().</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:2316</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a618283470b5211a0baa9d9f05bc5adaf" name="a618283470b5211a0baa9d9f05bc5adaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618283470b5211a0baa9d9f05bc5adaf">&#9670;&#160;</a></span>integrateHierarchicalFunctions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::integrateHierarchicalFunctions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>integrals</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload where the vector is passes as a parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integrals</td><td>will be resized to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> and overwritten with the integrals of the hierarchical basis functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b4c879a6844b0c0406075dd532c89bb" name="a4b4c879a6844b0c0406075dd532c89bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4c879a6844b0c0406075dd532c89bb">&#9670;&#160;</a></span>integrateHierarchicalFunctions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::integrateHierarchicalFunctions </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>integrals</em>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload using raw-arrays. </p>
<p>Useful mostly for the C/Python/Fortran interfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integrals</td><td>must have size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> and will be overwritten with the integrals of the hierarchical basis functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90ef79ca52084002348df6a07c3f82a8" name="a90ef79ca52084002348df6a07c3f82a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ef79ca52084002348df6a07c3f82a8">&#9670;&#160;</a></span>getGlobalPolynomialSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; TasGrid::TasmanianSparseGrid::getGlobalPolynomialSpace </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interpolation</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the powers of the polynomial that span the effective basis, Global and Sequence grids only. </p>
<p>Different rules have different growth in number of points and different exactness with respect to integration and interpolation. This method returns the actual polynomial space spanned by the basis used in the grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolation</td><td>determines whether to look for the space of exactly interpolated polynomials (<b>true</b>), or the space of exactly integrated polynomials (<b>false</b>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> number of strips each having <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> entries, each integer corresponds to the polynomial power in that direction, e.g., for a two dimensional grid (0, 0, 1, 0) indicates the constant in all directions and linear in the first input constant in the second.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is not Global or Sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1e393d27f07b24e9c8d348210ff6bd3" name="aa1e393d27f07b24e9c8d348210ff6bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e393d27f07b24e9c8d348210ff6bd3">&#9670;&#160;</a></span>printStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::printStats </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints short human-readable text describing the grid properties. </p>
<p>Among the outputs are type of the grid, number of inputs/outputs/points, one dimensional rule, and currently selected acceleration type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>indicates the stream to use for the text output, defaults to std::cout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab351871503d4cb7a8287f655eefed974" name="ab351871503d4cb7a8287f655eefed974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab351871503d4cb7a8287f655eefed974">&#9670;&#160;</a></span>enableAcceleration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::enableAcceleration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the current acceleration mode to the one specified. </p>
<p>Sets a new acceleration mode and releases the cached data-structures for the old mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the new acceleration mode, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> any acceleration method can be set regardless whether it is available. If the selected mode has not been enabled in CMake, this will select the "next-best" mode, thus <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a> is a suggestion rather than a hard request. See <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a6f8b7e76b93d48dc14ebe264bafcaff6" title="Returns the current effective acceleration mode.">getAccelerationType()</a>. </p>

</div>
</div>
<a id="aeb2d9bcbc406f656cb780ff9bf11bf2f" name="aeb2d9bcbc406f656cb780ff9bf11bf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2d9bcbc406f656cb780ff9bf11bf2f">&#9670;&#160;</a></span>enableAcceleration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::enableAcceleration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_gpu_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines calls the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a>, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a037284049ec188a606d1b41ce3d2c92f" title="Returns the currently set CUDA device.">getGPUID()</a> and allows for user provided handles. </p>
<p>The purpose of this method is to allow for one-show setup of the acceleration mode and gpu_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is a new acceleration mode, see <a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Modes of acceleration.">TasGrid::TypeAcceleration</a>. </td></tr>
    <tr><td class="paramname">new_gpu_id</td><td>is the new device id to use for acceleration, the number must be between 0 and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8267890d88dcae6942723ac87eb90c83" title="Return the number of visible CUDA devices.">getNumGPUs()</a> - 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5ef3f5b8d4a0f34ca6466cc6e79c08c" name="ac5ef3f5b8d4a0f34ca6466cc6e79c08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ef3f5b8d4a0f34ca6466cc6e79c08c">&#9670;&#160;</a></span>favorSparseAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::favorSparseAcceleration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>favor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the preferred back-end algorithm for Local Polynomial grids. </p>
<p>Usually the Local Polynomial grids use sparse data-structures and sparse linear algebra, but if the fill not sufficiently small then dense methods can yield better performance at the expense of higher memory footprint. In <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a4e99f4378b49ba22efd866d1eff3e689" title="Default (if available), uses both BLAS and LAPACK libraries.">TasGrid::accel_cpu_blas</a> mode, the dense algorithm will be used when the fill increases above the 10% threshold. In CUDA mode, even if the fill is computed, switching modes incurs a large overhead and thus the sparse algorithm is always favored. Sparse computations work better on newer GPU architectures (e.g., Pascal and Volta) and consumer (gaming) cards with reduced double-precision capabilities, but older devices coupled with small grids may work better with the dense algorithm. Hence, Tasmanian includes the manual option to select the desired algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">favor</td><td>if set to <b>true</b> will force the sparse back-end, if set to <b>false</b> will force the dense back-end. If the mode has been forced already, calling the method with the converse <b>favor</b> will reset mode to the default (automatic) selection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad223c8c4ac1dfbe2720d06533951d0a4" name="ad223c8c4ac1dfbe2720d06533951d0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad223c8c4ac1dfbe2720d06533951d0a4">&#9670;&#160;</a></span>setCuBlasHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setCuBlasHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a user provided cuBlas handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>must be a valid and initialized cublasHandle_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if CUDA is not enabled in CMake and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add8bad0a246c6c8c2d94f55c61fcca39" name="add8bad0a246c6c8c2d94f55c61fcca39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8bad0a246c6c8c2d94f55c61fcca39">&#9670;&#160;</a></span>setCuSparseHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setCuSparseHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a user provided cuSparse handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>must be a valid and initialized cusparseHandle_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if CUDA is not enabled in CMake and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a902ec72e75b078788777ee63dfb2050e" name="a902ec72e75b078788777ee63dfb2050e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902ec72e75b078788777ee63dfb2050e">&#9670;&#160;</a></span>setCuSolverHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setCuSolverHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a user provided cuSparse handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>must be a valid and initialized cusolverDnHandle_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if CUDA is not enabled in CMake and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af402274302c748e4332c917fb8f4620b" name="af402274302c748e4332c917fb8f4620b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af402274302c748e4332c917fb8f4620b">&#9670;&#160;</a></span>setRocBlasHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setRocBlasHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a user provided cuBlas handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>must be a valid and initialized rocblas_handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if HIP is not enabled in CMake and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a715043598d7c248c82b8be4f688cd30c" name="a715043598d7c248c82b8be4f688cd30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715043598d7c248c82b8be4f688cd30c">&#9670;&#160;</a></span>setRocSparseHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setRocSparseHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a user provided cuSparse handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>must be a valid and initialized rocsparse_handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if HIP is not enabled in CMake and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca1a393ad59aa8e7948719798eab9e72" name="aca1a393ad59aa8e7948719798eab9e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1a393ad59aa8e7948719798eab9e72">&#9670;&#160;</a></span>setSycleQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setSycleQueue </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a user provided sycl::queue handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>must be a valid and initialized sycl::queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if DPC++ is not enabled in CMake and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f8b7e76b93d48dc14ebe264bafcaff6" name="a6f8b7e76b93d48dc14ebe264bafcaff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8b7e76b93d48dc14ebe264bafcaff6">&#9670;&#160;</a></span>getAccelerationType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> TasGrid::TasmanianSparseGrid::getAccelerationType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current effective acceleration mode. </p>
<p>Returns the acceleration mode that will be used, i.e., the one selected internally based on the request made in <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ab351871503d4cb7a8287f655eefed974" title="Change the current acceleration mode to the one specified.">enableAcceleration()</a>. </p>

</div>
</div>
<a id="a26da7f37c10ef476605881ebc44ccb3d" name="a26da7f37c10ef476605881ebc44ccb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26da7f37c10ef476605881ebc44ccb3d">&#9670;&#160;</a></span>isAccelerationAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TasGrid::TasmanianSparseGrid::isAccelerationAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a specific mode can be enabled. </p>
<p>Based on the CMake compile time options, this method returns <b>true</b> for all acceleration modes that will be enabled, and <b>false</b> for all modes that will be replaced by a fallback alternative. </p>

</div>
</div>
<a id="afba3b52348459273432a95e29627ba99" name="afba3b52348459273432a95e29627ba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba3b52348459273432a95e29627ba99">&#9670;&#160;</a></span>setGPUID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::setGPUID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_gpu_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the current CUDA device. </p>
<p>Select the CUDA device to be used for the CUDA acceleration types, default device is <b>0</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_gpu_id</td><td>is the CUDA device ID of the new device, the number is between 0 and <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8267890d88dcae6942723ac87eb90c83" title="Return the number of visible CUDA devices.">getNumGPUs()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the <b>new_gpu_id</b> is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a037284049ec188a606d1b41ce3d2c92f" name="a037284049ec188a606d1b41ce3d2c92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037284049ec188a606d1b41ce3d2c92f">&#9670;&#160;</a></span>getGPUID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TasGrid::TasmanianSparseGrid::getGPUID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently set CUDA device. </p>
<p>Does not throw if CUDA is not enabled in CMake, instead the default <b>0</b> is returned. </p>

</div>
</div>
<a id="a8267890d88dcae6942723ac87eb90c83" name="a8267890d88dcae6942723ac87eb90c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8267890d88dcae6942723ac87eb90c83">&#9670;&#160;</a></span>getNumGPUs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int TasGrid::TasmanianSparseGrid::getNumGPUs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of visible CUDA devices. </p>
<p>Simple wrapper to cudaGetDeviceCount().</p>
<p>Use the <b>tasgrid</b> command line tool to see all available devices: </p><div class="fragment"><div class="line">tasgrid -v</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9fd38cf26a489b54861e993eec2e7c39" name="a9fd38cf26a489b54861e993eec2e7c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd38cf26a489b54861e993eec2e7c39">&#9670;&#160;</a></span>getGPUMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int TasGrid::TasmanianSparseGrid::getGPUMemory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the available device memory, in units of MB. </p>
<p>Simple wrapper to cudaGetDeviceProperties() returning totalGlobalMem divided by 2^20. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu</td><td>is the CUDA device ID to be queried, if the device is out of range then <b>0</b> will be returned (i.e., Tasmanian will not throw). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a6eba530b513cd4d8ba56591816fa1f" name="a8a6eba530b513cd4d8ba56591816fa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6eba530b513cd4d8ba56591816fa1f">&#9670;&#160;</a></span>getGPUName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string TasGrid::TasmanianSparseGrid::getGPUName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the CUDA device name. </p>
<p>Simple wrapper to cudaGetDeviceProperties() returning "name". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu</td><td>is the CUDA device ID to be queried, if the device is out of range then empty string will be returned (i.e., Tasmanian will not throw). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the CUDA device name. </dd></dl>

</div>
</div>
<a id="ab521b88c5efcfe07a6630623f5aa1fdf" name="ab521b88c5efcfe07a6630623f5aa1fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab521b88c5efcfe07a6630623f5aa1fdf">&#9670;&#160;</a></span>evaluateHierarchicalFunctionsGPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateHierarchicalFunctionsGPU </td>
          <td>(</td>
          <td class="paramtype">const FloatType&#160;</td>
          <td class="paramname"><em>gpu_x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu_num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType&#160;</td>
          <td class="paramname"><em>gpu_y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the values of the hierarchical function basis at the specified points (CUDA version). </p>
<p>Equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad68205bdd245e6f6f234a5c72435b14d" title="Computes the values of the hierarchical function basis at the specified points.">evaluateHierarchicalFunctions()</a> but using arrays allocated on the CUDA device. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FloatType</td><td>must be either float or double to indicate the precision used by the CUDA kernels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_x</td><td>must have size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> times <b>cpu_num_x</b> and must be allocated on the currently set CUDA device. </td></tr>
    <tr><td class="paramname">cpu_num_x</td><td>is an integer (located on the CPU memory) indicating the number of points. </td></tr>
    <tr><td class="paramname">gpu_y</td><td>must have size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a09a99fb1f72eb914a37dc92278e0c133" title="Returns getNumLoaded() if positive, otherwise returns getNumNeeded(), see getPoints().">getNumPoints()</a> times <b>cpu_num_x</b> and must be allocated on the currently set CUDA device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is Global or Wavelet or if the currently set acceleration mode is not compatible, i.e., <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766" title="Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the...">TasGrid::accel_none</a> or <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a4e99f4378b49ba22efd866d1eff3e689" title="Default (if available), uses both BLAS and LAPACK libraries.">TasGrid::accel_cpu_blas</a>. Also, if CUDA has not been enabled at compile time.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> will not work for LocalPolynomial grids with order bigger than 2 or Wavelets with order 3. </p>

</div>
</div>
<a id="a3c1a16961eb8fe73d96c69d969d1f874" name="a3c1a16961eb8fe73d96c69d969d1f874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1a16961eb8fe73d96c69d969d1f874">&#9670;&#160;</a></span>evaluateSparseHierarchicalFunctionsGPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateSparseHierarchicalFunctionsGPU </td>
          <td>(</td>
          <td class="paramtype">const FloatType&#160;</td>
          <td class="paramname"><em>gpu_x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu_num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>gpu_pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>gpu_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType *&amp;&#160;</td>
          <td class="paramname"><em>gpu_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>num_nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the values of the hierarchical function basis at the specified points (sparse/CUDA version). </p>
<p>Equivalent to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30f2fec64329b04aaf97fd7f02e83b64" title="Constructs a sparse matrix with the values of the hierarchical basis functions.">evaluateSparseHierarchicalFunctions()</a> but using arrays allocated on the CUDA device. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FloatType</td><td>must be either float or double to indicate the precision used by the CUDA kernels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpu_x</td><td>must have size <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeaed15359b94d960c8970c1d10178925" title="Return the dimensions of the grid, i.e., number of model inputs.">getNumDimensions()</a> times <b>cpu_num_x</b> and must be allocated on the currently set CUDA device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpu_num_x</td><td>is an integer (located on the CPU memory) indicating the number of points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gpu_pntr</td><td>will be allocated to size <b>cpu_num_x</b> + 1 and will hold the offsets of indexes for each point, the current memory will not be freed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gpu_indx</td><td>will be allocated to the number of non-zeros and will hold the indexes of the non-zeros for each point, the current memory will not be freed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gpu_vals</td><td>will be allocated to the number of non-zeros and will hold the non-zero values of the basis function, the current memory will not be freed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_nz</td><td>is an integer located on the CPU, will be overwritten to the total number of non-zeros.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is not Local Polynomial or if the currently set acceleration mode is not compatible, i.e., <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a91176d8f6abf97b8b2352665bfbbd766" title="Usually the slowest mode, uses only OpenMP multi-threading, but optimized for memory and could be the...">TasGrid::accel_none</a> or <a class="el" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581a4e99f4378b49ba22efd866d1eff3e689" title="Default (if available), uses both BLAS and LAPACK libraries.">TasGrid::accel_cpu_blas</a>. Also, if CUDA has not been enabled at compile time.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> will not work for LocalPolynomial grids with order bigger than 2. </p>

</div>
</div>
<a id="aee9f656b9220bd652e73930ace2694b6" name="aee9f656b9220bd652e73930ace2694b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9f656b9220bd652e73930ace2694b6">&#9670;&#160;</a></span>operator EvaluateCallable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TasGrid::TasmanianSparseGrid::operator <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a75802ac3fa6495ad9ca2f8063c0d7464">EvaluateCallable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom conversion to a callable method using the <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90" title="Generic probability distribution used by Tasmanian.">TasDREAM::DreamPDF</a> signature. </p>
<p>This conversion allows an instance of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html" title="The master-class that represents an instance of a Tasmanian sparse grid.">TasmanianSparseGrid</a> to be passed as input to any method that expects <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90" title="Generic probability distribution used by Tasmanian.">TasDREAM::DreamPDF</a>, <a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d" title="Generic model signature used by Tasmanian.">TasDREAM::DreamModel</a> or <a class="el" href="group__DREAMSampleCore.html#ga1aaf27a3d3639c0f0cdf270af1f45c22" title="Generic signature for a combination of a likelihood and a model.">TasDREAM::DreamMergedLikelyModel</a>. </p>

</div>
</div>
<a id="aceb78af481464eb3878d43ee44b487f4" name="aceb78af481464eb3878d43ee44b487f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb78af481464eb3878d43ee44b487f4">&#9670;&#160;</a></span>getDomainInside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ae7f55726763394dda700d6efa5f9f68b">DomainInsideSignature</a> TasGrid::TasmanianSparseGrid::getDomainInside </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lambda object that satisfies the <a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f" title="Generic test function whether a sample belongs in the domain.">TasDREAM::DreamDomain</a> signature. </p>
<p>This method allows for the domain currently set in the grid to be passed to the Tasmanian DREAM sampling templates in place of the <b>inside()</b> object. </p>

</div>
</div>
<a id="a8f5d84e3fa2f9e9fd70eeaedae5d51c3" name="a8f5d84e3fa2f9e9fd70eeaedae5d51c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5d84e3fa2f9e9fd70eeaedae5d51c3">&#9670;&#160;</a></span>removePointsByHierarchicalCoefficient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::removePointsByHierarchicalCoefficient </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>scale_correction</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all points from the grid that have relative surplus less than the <b>tolerance</b>. </p>
<p>The <b>output</b> and <b>scale_correction</b> variables have the same effects as in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a>. The purpose of this call is to reduce the number of points and thus the memory footprint of the grid. As such, points will be removed with no regard of preserving lower completeness or connectivity of the hierarchical graphs; therefore, it is possible that the grid no longer has a valid state with respect to the update and refinement algorithms. Calling <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#af9a9e720271b111893fdcd7e70a4ff3e" title="Provides the values of the model outputs at the needed points, or overwrites the currently loaded poi...">loadNeededValues()</a> or any refinement or construction method after the removal of points may lead to undefined behavior; get, evaluate and file I/O methods are safe to call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>the cut-off tolerance for the point removal. </td></tr>
    <tr><td class="paramname">output</td><td>is the output to use for the tolerance test, can be set to -1 to use all outputs. </td></tr>
    <tr><td class="paramname">scale_correction</td><td>is the same as in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is not Local Polynomial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3306c2d1852f283f74d46944da298ead" name="a3306c2d1852f283f74d46944da298ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3306c2d1852f283f74d46944da298ead">&#9670;&#160;</a></span>removePointsByHierarchicalCoefficient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::removePointsByHierarchicalCoefficient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_new_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>scale_correction</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keeps only the given number of points with largest scaled surpluses. </p>
<p>Similar to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a8f5d84e3fa2f9e9fd70eeaedae5d51c3" title="Removes all points from the grid that have relative surplus less than the tolerance.">removePointsByHierarchicalCoefficient()</a>, but the points are not removed based on a comparison to a tolerance. Instead, only the given number of points is kept so that the remaining points have the largest scaled surplus coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_new_points</td><td>the number of points to keep in the grid. </td></tr>
    <tr><td class="paramname">output</td><td>is the output to use for the tolerance test, can be set to -1 to use all outputs. </td></tr>
    <tr><td class="paramname">scale_correction</td><td>is the same as in the call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">setSurplusRefinement()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the grid is not Local Polynomial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb91720427ae70b4e099aac92da10ea7" name="aeb91720427ae70b4e099aac92da10ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb91720427ae70b4e099aac92da10ea7">&#9670;&#160;</a></span>evaluateSparseHierarchicalFunctionsGetNZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TasGrid::TasmanianSparseGrid::evaluateSparseHierarchicalFunctionsGetNZ </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of non-zeros in a call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30f2fec64329b04aaf97fd7f02e83b64" title="Constructs a sparse matrix with the values of the hierarchical basis functions.">evaluateSparseHierarchicalFunctions()</a>. </p>
<p>Used by the C/Python/Fortran interfaces, counts the number of non-zeros so memory can be pre-allocated by the corresponding language before a call to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aa3104baab26653ece767f11807b58856" title="Assumes pre-allocated arrays, otherwise identical to evaluateSparseHierarchicalFunctions()">evaluateSparseHierarchicalFunctionsStatic()</a>. </p>

</div>
</div>
<a id="aa3104baab26653ece767f11807b58856" name="aa3104baab26653ece767f11807b58856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3104baab26653ece767f11807b58856">&#9670;&#160;</a></span>evaluateSparseHierarchicalFunctionsStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::evaluateSparseHierarchicalFunctionsStatic </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assumes pre-allocated arrays, otherwise identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a30f2fec64329b04aaf97fd7f02e83b64" title="Constructs a sparse matrix with the values of the hierarchical basis functions.">evaluateSparseHierarchicalFunctions()</a> </p>
<p>See <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#aeb91720427ae70b4e099aac92da10ea7" title="Count the number of non-zeros in a call to evaluateSparseHierarchicalFunctions().">evaluateSparseHierarchicalFunctionsGetNZ()</a>. </p>

</div>
</div>
<a id="ac3081eecec78373f57dfc42a94472bfc" name="ac3081eecec78373f57dfc42a94472bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3081eecec78373f57dfc42a94472bfc">&#9670;&#160;</a></span>getPointsIndexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int * TasGrid::TasmanianSparseGrid::getPointsIndexes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the multi-indexes of the loaded points. </p>
<p>Testing and debugging purposes mostly. </p>

</div>
</div>
<a id="ad5066f9228a98b3a226e3a6fa8502baf" name="ad5066f9228a98b3a226e3a6fa8502baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5066f9228a98b3a226e3a6fa8502baf">&#9670;&#160;</a></span>getNeededIndexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int * TasGrid::TasmanianSparseGrid::getNeededIndexes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the multi-indexes of the needed points. </p>
<p>Testing and debugging purposes mostly. </p>

</div>
</div>
<a id="a051c467f6ab62ca7e6e8970de24cdb51" name="a051c467f6ab62ca7e6e8970de24cdb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051c467f6ab62ca7e6e8970de24cdb51">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * TasGrid::TasmanianSparseGrid::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the internal grid. </p>
<p>Casts the internal unique_ptr to <b>T</b> and returns the result. </p>

</div>
</div>
<a id="a1be2a2bf4e9bdd16fb5cd858eeedc14a" name="a1be2a2bf4e9bdd16fb5cd858eeedc14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be2a2bf4e9bdd16fb5cd858eeedc14a">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * TasGrid::TasmanianSparseGrid::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload using const. </p>
<p>Same as <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a051c467f6ab62ca7e6e8970de24cdb51" title="Return a reference to the internal grid.">get()</a>, but the method is const and returns a const reference. </p>

</div>
</div>
<a id="acf7fde3a74e6c17b1f6eeb596c42fc90" name="acf7fde3a74e6c17b1f6eeb596c42fc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7fde3a74e6c17b1f6eeb596c42fc90">&#9670;&#160;</a></span>getAccelerationContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTasGrid_1_1AccelerationContext.html">AccelerationContext</a> const  * TasGrid::TasmanianSparseGrid::getAccelerationContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the addon methods to use the acceleration context. </p>

</div>
</div>
<a id="a7058fe43f56c7219dc8f22f62101a606" name="a7058fe43f56c7219dc8f22f62101a606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7058fe43f56c7219dc8f22f62101a606">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the grid to empty. </p>
<p>Resets the grid, all cache data structures, and the acceleration mode. </p>

</div>
</div>
<a id="adfa9a50e15df89678c5b02815942dc09" name="adfa9a50e15df89678c5b02815942dc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa9a50e15df89678c5b02815942dc09">&#9670;&#160;</a></span>mapCanonicalToTransformed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::mapCanonicalToTransformed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps canonical points to the transformed equivalent. </p>
<p>Given an array of canonical points <b>x</b> with size <b>num_points</b> and <b>num_dimensions</b> for given <b>rule</b>, convert them to transformed points applying only the linear transform. </p>

</div>
</div>
<a id="a077b5c5c1fc01729b97a06d02368c784" name="a077b5c5c1fc01729b97a06d02368c784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077b5c5c1fc01729b97a06d02368c784">&#9670;&#160;</a></span>mapTransformedToCanonical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::mapTransformedToCanonical </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the inverse map from transformed to canonical points. </p>
<p>Similar to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#adfa9a50e15df89678c5b02815942dc09" title="Maps canonical points to the transformed equivalent.">mapCanonicalToTransformed()</a>, uses the inverse transform. </p>

</div>
</div>
<a id="a55ac9f41dfa4528da24472065826888a" name="a55ac9f41dfa4528da24472065826888a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ac9f41dfa4528da24472065826888a">&#9670;&#160;</a></span>getQuadratureScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TasGrid::TasmanianSparseGrid::getQuadratureScale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the quadrature scale factor associated with the linear transform. </p>
<p>Uses the <b>num_dimensions</b> and <b>rule</b>, as well as private members <b>alpha</b> and <b>beta</b>. </p>

</div>
</div>
<a id="a91bb7e7919294b59929f5b0c43b54ff2" name="a91bb7e7919294b59929f5b0c43b54ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bb7e7919294b59929f5b0c43b54ff2">&#9670;&#160;</a></span>mapConformalCanonicalToTransformed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::mapConformalCanonicalToTransformed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the non-linear transformation to the points. </p>
<p>Using the set conformal transform (private variables), applies the non-linear transform to the points <b>x</b> with given number of dimensions and number of points. </p>

</div>
</div>
<a id="a2f893c1558d5495ffe3decb4dbcac065" name="a2f893c1558d5495ffe3decb4dbcac065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f893c1558d5495ffe3decb4dbcac065">&#9670;&#160;</a></span>mapConformalTransformedToCanonical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::mapConformalTransformedToCanonical </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; FloatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the inverse non-linear transformation to the points. </p>
<p>Using the set conformal transform (private variables), applies the inverse non-linear transform. </p>

</div>
</div>
<a id="af53bfbd4785998b377b03c53f8af63f3" name="af53bfbd4785998b377b03c53f8af63f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53bfbd4785998b377b03c53f8af63f3">&#9670;&#160;</a></span>mapConformalWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::mapConformalWeights </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weights</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quadrature weight correction for the conformal map. </p>
<p>Using the set conformal transform (private variables), compute the quadrature weights correction. </p>

</div>
</div>
<a id="a3daf055cf0cd2a590ca27482dc901a05" name="a3daf055cf0cd2a590ca27482dc901a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3daf055cf0cd2a590ca27482dc901a05">&#9670;&#160;</a></span>formCanonicalPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const FloatType * TasGrid::TasmanianSparseGrid::formCanonicalPoints </td>
          <td>(</td>
          <td class="paramtype">const FloatType *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; FloatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw-array with the canonical points, combines both transformations. </p>
<p>If no transforms have been set, then return an alias to <b>x</b>. Otherwise, <b>x_temp</b> is resized, filled with the transformed points and an alias is returned. Canonical points are given in <b>x</b>, and <b>num_x</b> holds the number of points. This method applies both linear and non-linear transforms. </p>

</div>
</div>
<a id="a0956195dcad90888e70c19976fe3beb1" name="a0956195dcad90888e70c19976fe3beb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0956195dcad90888e70c19976fe3beb1">&#9670;&#160;</a></span>formCanonicalPointsGPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * TasGrid::TasmanianSparseGrid::formCanonicalPointsGPU </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1GpuVector.html">GpuVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_x_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a CUDA raw-array with the canonical points, linear transform only. </p>
<p>Similar to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3daf055cf0cd2a590ca27482dc901a05" title="Returns a raw-array with the canonical points, combines both transformations.">formCanonicalPoints()</a> except the input and output arrays/vectors are allocated on the current CUDA device. Works with single and double precision <b>T</b>. </p>

</div>
</div>
<a id="a563ec046da76e6607f556a129701c4f6" name="a563ec046da76e6607f556a129701c4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563ec046da76e6607f556a129701c4f6">&#9670;&#160;</a></span>diffCanonicalTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; TasGrid::TasmanianSparseGrid::diffCanonicalTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Jacobian matrix (derivative) of the transform defined by <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a3daf055cf0cd2a590ca27482dc901a05" title="Returns a raw-array with the canonical points, combines both transformations.">formCanonicalPoints()</a>. Since this matrix is diagonal, we only return the diagonal vector. </p>
<p>This is primarily used in the <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a35b06e4357796cdf4bbcf0294f895130" title="Computes the derivative (if available) of the surrogate model at an input point.">TasmanianSparseGrid::differentiate()</a> method, which applies the chain rule to the (possibly) transformed grid. </p>

</div>
</div>
<a id="a1931d6c8c6a5542f362ac7babda015d8" name="a1931d6c8c6a5542f362ac7babda015d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1931d6c8c6a5542f362ac7babda015d8">&#9670;&#160;</a></span>formTransformedPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::formTransformedPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies both linear and non-linear transformation to the canonical points. </p>
<p>The raw-array <b>x</b> holds <b>num_points</b> and will be overwritten with the result of the application of both transforms. </p>

</div>
</div>
<a id="a683cdd8328a55fc1811dadc6fe844586" name="a683cdd8328a55fc1811dadc6fe844586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683cdd8328a55fc1811dadc6fe844586">&#9670;&#160;</a></span>writeAscii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::writeAscii </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ofs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the grid to a stream using ASCII format. </p>
<p>Uses an open stream, writes the grid. </p>

</div>
</div>
<a id="a3c682f9b3350c5ba3b307b47c96865f9" name="a3c682f9b3350c5ba3b307b47c96865f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c682f9b3350c5ba3b307b47c96865f9">&#9670;&#160;</a></span>readAscii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::readAscii </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>ifs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the grid from a stream using ASCII format. </p>
<p>Uses an open stream, read the grid. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Tasmanian detects a problem with the file format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac15219f68a8eab0bc78ad9924af5c815" name="ac15219f68a8eab0bc78ad9924af5c815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15219f68a8eab0bc78ad9924af5c815">&#9670;&#160;</a></span>writeBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::writeBinary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ofs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the grid to a stream using binary format. </p>
<p>Uses an open stream, writes the grid. </p>

</div>
</div>
<a id="a1f7e59e76904e35bac5448cf699b75a5" name="a1f7e59e76904e35bac5448cf699b75a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7e59e76904e35bac5448cf699b75a5">&#9670;&#160;</a></span>readBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasmanianSparseGrid::readBinary </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>ifs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the grid from a stream using binary format. </p>
<p>Uses an open stream, read the grid. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Tasmanian detects a problem with the file format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SparseGrids/<a class="el" href="TasmanianSparseGrid_8hpp_source.html">TasmanianSparseGrid.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="navelem"><a class="el" href="namespaceTasGrid.html">TasGrid</a></li><li class="navelem"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
