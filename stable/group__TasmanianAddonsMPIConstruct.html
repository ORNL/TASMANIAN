<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1: MPI Automated Surrogate Construction Procedure</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.1
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TasmanianAddonsMPIConstruct.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MPI Automated Surrogate Construction Procedure<div class="ingroups"><a class="el" href="group__TasmanianAddons.html">Additional Capabilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for MPI Automated Surrogate Construction Procedure:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianAddonsMPIConstruct.png" border="0" usemap="#agroup____TasmanianAddonsMPIConstruct" alt=""/></div>
<map name="agroup____TasmanianAddonsMPIConstruct" id="agroup____TasmanianAddonsMPIConstruct">
<area shape="rect" href="group__TasmanianAddons.html" title=" " alt="" coords="5,13,156,38"/>
<area shape="rect" title=" " alt="" coords="204,5,376,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga35e2b2fa104542946ae93656b2cfe698"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">TasGrid::ModelSignatureMPI</a> = std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y)&gt;</td></tr>
<tr class="memdesc:ga35e2b2fa104542946ae93656b2cfe698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of a model function to be used in the MPI construction procedures.  <a href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">More...</a><br /></td></tr>
<tr class="separator:ga35e2b2fa104542946ae93656b2cfe698"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga959c5c21a2c9bffd485ac75f7098eafb"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga959c5c21a2c9bffd485ac75f7098eafb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb">TasGrid::mpiConstructSurrogate</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_num_points, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, double tolerance, <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> criteria, int output=-1, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::vector&lt; double &gt; const &amp;scale_correction=std::vector&lt; double &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:ga959c5c21a2c9bffd485ac75f7098eafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda, MPI version.  <a href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb">More...</a><br /></td></tr>
<tr class="separator:ga959c5c21a2c9bffd485ac75f7098eafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec04bf28521616e8082a73bb6c6baa2"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:gaeec04bf28521616e8082a73bb6c6baa2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#gaeec04bf28521616e8082a73bb6c6baa2">TasGrid::mpiConstructSurrogate</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_num_points, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:gaeec04bf28521616e8082a73bb6c6baa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda, MPI version.  <a href="group__TasmanianAddonsMPIConstruct.html#gaeec04bf28521616e8082a73bb6c6baa2">More...</a><br /></td></tr>
<tr class="separator:gaeec04bf28521616e8082a73bb6c6baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bef49fcf53bfe96df8fb433e3cf4cc7"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga8bef49fcf53bfe96df8fb433e3cf4cc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga8bef49fcf53bfe96df8fb433e3cf4cc7">TasGrid::mpiConstructSurrogate</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_num_points, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int output, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:ga8bef49fcf53bfe96df8fb433e3cf4cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda, MPI version.  <a href="group__TasmanianAddonsMPIConstruct.html#ga8bef49fcf53bfe96df8fb433e3cf4cc7">More...</a><br /></td></tr>
<tr class="separator:ga8bef49fcf53bfe96df8fb433e3cf4cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0472ab32a5ad7ee714ba5539db592932"><td class="memTemplParams" colspan="2">template&lt;bool use_initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga0472ab32a5ad7ee714ba5539db592932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga0472ab32a5ad7ee714ba5539db592932">TasGrid::mpiConstructWorker</a> (<a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a> model, int num_dimensions, int num_outputs, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm)</td></tr>
<tr class="memdesc:ga0472ab32a5ad7ee714ba5539db592932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the worker (i.e., non-root) portion of the MPI sampling.  <a href="group__TasmanianAddonsMPIConstruct.html#ga0472ab32a5ad7ee714ba5539db592932">More...</a><br /></td></tr>
<tr class="separator:ga0472ab32a5ad7ee714ba5539db592932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Distributed sampling procedure, construction similar to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a> but the parallelism is associated with different ranks in an MPI communicator. These templates require Tasmanian_ENABLE_MPI=ON. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga35e2b2fa104542946ae93656b2cfe698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35e2b2fa104542946ae93656b2cfe698">&#9670;&nbsp;</a></span>ModelSignatureMPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">TasGrid::ModelSignatureMPI</a> = typedef std::function&lt;void(std::vector&lt;double&gt; const &amp;x, std::vector&lt;double&gt; &amp;y)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature of a model function to be used in the MPI construction procedures. </p>
<p>The logic is identical to the <a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9" title="Signature of a model function to be used in the construction procedures.">TasGrid::ModelSignature</a> used in the <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a> templates, with the exception of the removal of the thread-id. In an MPI context, the thread-id is replaced by the MPI rank which can be queried using MPI_Comm_rank(). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga959c5c21a2c9bffd485ac75f7098eafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga959c5c21a2c9bffd485ac75f7098eafb">&#9670;&nbsp;</a></span>mpiConstructSurrogate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_initial_guess = no_initial_guess&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::mpiConstructSurrogate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_samples_per_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>scale_correction</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>checkpoint_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse grid surrogate to the model defined by the lambda, MPI version. </p>
<p>The logic is the same as in <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>, construct adaptive sparse grid surrogate to the mode defined by the lambda using parallel computations. The model will be executed with different inputs <b>x</b> on different ranks within the MPI communicator. All ranks of across the communicator must make an identical call with identical parameters before the <b>grid</b>. The grid and the refinement and checkpoint parameters will be used only by the <b>root</b> rank and will not be addressed by the rest.</p>
<dl class="section user"><dt>MPI and Multi-Threading</dt><dd>This template will call <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a> and it will spawn a separate thread for each active ranks within the communicator. Thus, MPI must support multi-threading and the multi-threaded initialization call must be used: <div class="fragment"><div class="line"><span class="comment">// instead of calling MPI_Init() call the following</span></div>
<div class="line"><span class="keywordtype">int</span> threads_available;</div>
<div class="line">MPI_Init_thread(&amp;argc, &amp;argv, MPI_THREAD_MULTIPLE, &amp;threads_available);</div>
<div class="line"><span class="keywordflow">if</span> (threads_available != MPI_THREAD_MULTIPLE)</div>
<div class="line">   std::cerr &lt;&lt; <span class="stringliteral">&quot;MPI threading not available, TasGrid::mpiConstructSurrogate() will not work.\n&quot;</span>;</div>
</div><!-- fragment --> Note that the <a class="el" href="group__TasmanianAddonsMPIGridSend.html#ga81fed6fbf2fd899aca4922646d2566d1" title="Send a grid to another process in the MPI comm.">MPIGridSend()</a> and other similar methods do not require multi-threading.</dd></dl>
<p>The list of inputs is very similar to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>, here we outline the main differences.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">use_initial_guess</td><td>defines whether to compute an initial guess for the model outputs and send that over the communicator. The MPI procedure always runs in parallel mode hence there is no additional template parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>the inputs <b>x</b> and outputs <b>y</b> of the model are the same as in <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>; however, there is no thread_id. Only one call of the model will be executed on each active rank and thus the MPI native MPI_Comm_rank() can be used in place of the thread_id.</td></tr>
    <tr><td class="paramname">num_dimensions</td><td>must match <b>grid.getNumDimensions()</b>. This is a required parameter since only the <b>root</b> rank is assumed to have access to the grid, the other ranks need to know the correct dimension without the grid. </td></tr>
    <tr><td class="paramname">num_outputs</td><td>must match <b>grid.getNumOutputs()</b>, see <b>num_dimensions</b>.</td></tr>
    <tr><td class="paramname">max_num_points</td><td>defines the computational budget, same as <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>.</td></tr>
    <tr><td class="paramname">max_samples_per_job</td><td>defines the number of samples that will be given to the model in each call, see <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>.</td></tr>
    <tr><td class="paramname">max_num_ranks</td><td>defines the number of ranks to use, if it exceeds the size of the communicator then all ranks will be used in the process. If less than the size, the <b>root</b> process will not make calls to the model but it will be working on the internal grid methods. This is useful when dealing with many points where the cost of loading points is not negligible. If the <b>max_num_ranks</b> is less than the communicator size minus one, then some of the ranks will be completely idle (usually the ranks with higher number).</td></tr>
    <tr><td class="paramname">tagx</td><td>is the MPI_Send() tag to use when communicating the inputs <b>x</b> to the worker rank. </td></tr>
    <tr><td class="paramname">tagy</td><td>is the MPI_Send() tag to use when communicating the outputs <b>y</b> to the root rank.</td></tr>
    <tr><td class="paramname">root</td><td>is the MPI rank within the communicator that has the initial copy of the <b>grid</b> as well as the refinement parameters that are identical to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. The final result from the construction will be held by the <b>root</b> rank only, the grids for the rest of other ranks will not be accessed.</td></tr>
    <tr><td class="paramname">comm</td><td>is the MPI communicator where sampling will take place, e.g., MPI_COMM_WORLD.</td></tr>
    <tr><td class="paramname">grid</td><td>on rank <b>root</b> is the grid to be constructed, ignored when the rank is different.</td></tr>
    <tr><td class="paramname">tolerance</td><td>refinement parameter, see <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. </td></tr>
    <tr><td class="paramname">criteria</td><td>refinement parameter, see <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. </td></tr>
    <tr><td class="paramname">output</td><td>refinement parameter, see <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. </td></tr>
    <tr><td class="paramname">level_limits</td><td>refinement parameter, see <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. </td></tr>
    <tr><td class="paramname">scale_correction</td><td>refinement parameter, see <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>.</td></tr>
    <tr><td class="paramname">checkpoint_filename</td><td>is either empty (skip checkpoints) or the filename to use to save the intermediate results. Note that only the <b>root</b> rank will issue read/write commands to the files.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example 1: Model that uses no MPI</dt><dd>Construct a surrogate to a model described by a parametrized system of equations using a local polynomial gird and arbitrary number of MPI ranks. Rank 0 will be responsible for the grid construction and computing the initial guess for all solutions, the rest of the ranks will be calling a solver which makes no MPI calls. The computational budget is 10,000 points and the solver works with one equation at a time. <div class="fragment"><div class="line"><span class="comment">// solves the equation using the initial guess and makes no MPI calls</span></div>
<div class="line"><span class="keywordtype">void</span> solver(std::vector&lt;double&gt; <span class="keyword">const</span> &amp;inputs,</div>
<div class="line">            std::vector&lt;double&gt; &amp;solution,</div>
<div class="line">            std::vector&lt;double&gt; &amp;initial guess);</div>
<div class="line">...</div>
<div class="line">int me, num_ranks, tagx = 11, tagy = 12;</div>
<div class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;me); <span class="comment">// rank of this process</span></div>
<div class="line">MPI_Comm_size(comm, &amp;num_ranks); <span class="comment">// all ranks</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> num_inputs = ...;  <span class="comment">// must match the solver</span></div>
<div class="line"><span class="keywordtype">int</span> num_outputs = ...; <span class="comment">// must match the solver</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a> grid;</div>
<div class="line"><span class="keywordflow">if</span> (me == 0)</div>
<div class="line">    grid = <a class="code" href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a>(num_inputs, num_outputs, ...);</div>
<div class="line"> </div>
<div class="line">TasGrid::mpiConstructSurrogate&lt;TasGrid::with_initial_guess&gt;(</div>
<div class="line">    [&amp;](std::vector&lt;double&gt; <span class="keyword">const</span> &amp;x, std::vector&lt;double&gt; &amp;y)</div>
<div class="line">    -&gt;<span class="keywordtype">void</span>{</div>
<div class="line">        <span class="keyword">auto</span> initial_guess = y; <span class="comment">// on input y is the initial guess</span></div>
<div class="line">        std::vector&lt;double&gt; solution;</div>
<div class="line">        solver(x, solution, initial_guess);</div>
<div class="line">        y = solution; <span class="comment">// on output y is the solution</span></div>
<div class="line">    },</div>
<div class="line">    num_dimensions, num_outputs,</div>
<div class="line">    10000, 1, num_ranks - 1, tagx, tagy, 0, MPI_COMM_WORLD,</div>
<div class="line">    grid, tolerance, <a class="code" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda939fdaecc186a219034e156eb8ace917">TasGrid::refine_fds</a>, ... );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// at this point, grid on rank 0 will hold the surrogate to solver()</span></div>
<div class="line"><span class="comment">// grid on all other processes will be empty()</span></div>
<div class="ttc" id="aclassTasGrid_1_1TasmanianSparseGrid_html"><div class="ttname"><a href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a></div><div class="ttdoc">The master-class that represents an instance of a Tasmanian sparse grid.</div><div class="ttdef"><b>Definition:</b> TasmanianSparseGrid.hpp:293</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_ggac709fc494353223f300235750f8b96eda939fdaecc186a219034e156eb8ace917"><div class="ttname"><a href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda939fdaecc186a219034e156eb8ace917">TasGrid::refine_fds</a></div><div class="ttdeci">@ refine_fds</div><div class="ttdoc">Anisotropic refinement adding children only if the parents are already included.</div><div class="ttdef"><b>Definition:</b> tsgEnumerates.hpp:433</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_gaaa84e44ca8145727564dbb57e7c939a3"><div class="ttname"><a href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeLocalPolynomialGrid(int dimensions, int outputs, int depth, int order=1, TypeOneDRule rule=rule_localp, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeLocalPolynomialGrid().</div><div class="ttdef"><b>Definition:</b> TasmanianSparseGrid.hpp:2301</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example 2: Model that works on sub-communicator</dt><dd>Suppose that the model requires multiple MPI ranks for efficient computing and it can operate on an arbitrary MPI communicator. In this example, we take the MPI world communicator and we sub-divide it into many smaller comms, then each sub-communicator will be used to handle an independent sample. In this example, all ranks participate in the process, assuming that the cost of the grid manipulations is negligible compared to the model simulations. There is no initial guess in the complicated model. <div class="fragment"><div class="line"><span class="comment">// model that computes the outputs using all ranks on an arbitrary communicator</span></div>
<div class="line"><span class="keywordtype">void</span> model(std::vector&lt;double&gt; <span class="keyword">const</span> &amp;inputs,</div>
<div class="line">           std::vector&lt;double&gt; &amp;outputs,</div>
<div class="line">           MPI_Comm comm);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// number of ranks to assign to the communicators for each call to model()</span></div>
<div class="line">int ranks_per_model = ...;</div>
<div class="line"><span class="keywordtype">int</span> world_me, num_ranks, tagx = 11, tagy = 12;</div>
<div class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_me); <span class="comment">// rank of this process in world comm</span></div>
<div class="line">MPI_Comm comm_worker; <span class="comment">// local comm for the work done by the model</span></div>
<div class="line"><span class="comment">// split the world communicator into local ones</span></div>
<div class="line">MPI_Comm_split(MPI_COMM_WORLD, world_me / ranks_per_model, world_me % ranks_per_model, &amp;comm_worker);</div>
<div class="line"><span class="keywordtype">int</span> worker_me;</div>
<div class="line">MPI_Comm_rank(comm_worker, &amp;worker_me); <span class="comment">// this procees rank within the worker comm</span></div>
<div class="line"><span class="comment">// create a sub-comm for the processes that would commonicate with Tasmanian</span></div>
<div class="line">MPI_Comm comm_tasmanian; <span class="comment">// communicator for Tasmanian operations</span></div>
<div class="line">MPI_Comm_split(MPI_COMM_WORLD, (worker_me == 0) ? 0 : MPI_UNDEFINED, world_me, &amp;comm_tasmanian);</div>
<div class="line"><span class="keywordtype">int</span> num_tasmanian_ranks;</div>
<div class="line"><span class="keywordflow">if</span> (worker_me == 0) MPI_Comm_size(comm_tasmanian, &amp;num_tasmanian_ranks);</div>
<div class="line"><span class="keywordtype">int</span> tasmanian_root = 0; <span class="comment">// world_me = zero is the same as tasmanian_root = zero</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> num_inputs = ...;  <span class="comment">// must match the solver</span></div>
<div class="line"><span class="keywordtype">int</span> num_outputs = ...; <span class="comment">// must match the solver</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (worker_me == 0){</div>
<div class="line">    <a class="code" href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb">mpiConstructSurrogate</a>(</div>
<div class="line">        [&amp;](...)-&gt;<span class="keywordtype">void</span>{</div>
<div class="line">            MPI_Bcast(... sent x to all ranks in comm_worker ...);</div>
<div class="line">            model(..., comm_worker); <span class="comment">// participate in this model evaluation</span></div>
<div class="line">            MPI_Gather(... collect all results in <span class="keyword">this</span> process ...);</div>
<div class="line">        },</div>
<div class="line">    num_inputs, num_outputs, 10000, 1, num_tasmanian_ranks, tagx, tagy,</div>
<div class="line">    tasmanian_root, comm_tasmanian,</div>
<div class="line">    grid, ...);</div>
<div class="line">}<span class="keywordflow">else</span>{</div>
<div class="line">    MPI_Bcast(... get x from rank 0 on comm_worker ...);</div>
<div class="line">    model(x, outputs, comm_worker);</div>
<div class="line">    MPI_Gather(... gather the results in rank 0 on comm_worker ...);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__TasmanianAddonsMPIConstruct_html_ga959c5c21a2c9bffd485ac75f7098eafb"><div class="ttname"><a href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb">TasGrid::mpiConstructSurrogate</a></div><div class="ttdeci">void mpiConstructSurrogate(ModelSignatureMPI model, int num_dimensions, int num_outputs, size_t max_num_points, size_t max_samples_per_job, size_t max_num_ranks, int tagx, int tagy, int root, MPI_Comm comm, TasmanianSparseGrid &amp;grid, double tolerance, TypeRefinement criteria, int output=-1, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::vector&lt; double &gt; const &amp;scale_correction=std::vector&lt; double &gt;(), std::string const &amp;checkpoint_filename=std::string())</div><div class="ttdoc">Construct a sparse grid surrogate to the model defined by the lambda, MPI version.</div><div class="ttdef"><b>Definition:</b> tsgMPIConstructGrid.hpp:336</div></div>
</div><!-- fragment --> <b>Note:</b> the code above demonstrates the idea of the split world communicator, an actual Implementation would differ in details and specifics. </dd></dl>

</div>
</div>
<a id="gaeec04bf28521616e8082a73bb6c6baa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec04bf28521616e8082a73bb6c6baa2">&#9670;&nbsp;</a></span>mpiConstructSurrogate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_initial_guess = no_initial_guess&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::mpiConstructSurrogate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_samples_per_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>std::vector&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>checkpoint_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse grid surrogate to the model defined by the lambda, MPI version. </p>
<p>Uses the user provided <b>anisotropic_weights</b> to order the samples by importance, see<br  />
 <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad404cac878b8f570665f60b6d9aeb249" title="Generate a sorted list of points weighted by descending importance.">TasmanianSparseGrid::getCandidateConstructionPoints()</a>. and the overloads to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. </p>

</div>
</div>
<a id="ga8bef49fcf53bfe96df8fb433e3cf4cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bef49fcf53bfe96df8fb433e3cf4cc7">&#9670;&nbsp;</a></span>mpiConstructSurrogate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_initial_guess = no_initial_guess&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::mpiConstructSurrogate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_samples_per_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>checkpoint_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse grid surrogate to the model defined by the lambda, MPI version. </p>
<p>Uses anisotropic weights to order the samples by importance, starts with a fully isotropic grid until enough points are loaded to allow to estimate the weights, see <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#ad404cac878b8f570665f60b6d9aeb249" title="Generate a sorted list of points weighted by descending importance.">TasmanianSparseGrid::getCandidateConstructionPoints()</a>. and the overloads to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. </p>

</div>
</div>
<a id="ga0472ab32a5ad7ee714ba5539db592932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0472ab32a5ad7ee714ba5539db592932">&#9670;&nbsp;</a></span>mpiConstructWorker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_initial_guess = no_initial_guess&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::mpiConstructWorker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga35e2b2fa104542946ae93656b2cfe698">ModelSignatureMPI</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_samples_per_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the worker (i.e., non-root) portion of the MPI sampling. </p>
<p>Using any of the <a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb" title="Construct a sparse grid surrogate to the model defined by the lambda, MPI version.">TasGrid::mpiConstructSurrogate()</a> overloads, the grid, the budget and the refinement parameters are accessed only by the root rank, the rest is not used by the workers. This template can be instantiated for the non-root rank with only the relevant inputs.</p>
<ul>
<li>The call to this method <b>must</b> be paired with a call to <a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb" title="Construct a sparse grid surrogate to the model defined by the lambda, MPI version.">TasGrid::mpiConstructSurrogate()</a> on the root rank.</li>
<li>The inputs (including the template parameter) <b>must</b> match the ones in the call to <a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb" title="Construct a sparse grid surrogate to the model defined by the lambda, MPI version.">TasGrid::mpiConstructSurrogate()</a>. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div> -->
</body>
</html>
