<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1: DREAM Sampling Templates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.1
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DREAMSampleCore.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DREAM Sampling Templates<div class="ingroups"><a class="el" href="group__TasmanianDREAM.html">DREAM: DiffeRential Evolution Adaptive Metropolis</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for DREAM Sampling Templates:</div>
<div class="dyncontent">
<div class="center"><img src="group__DREAMSampleCore.png" border="0" usemap="#agroup____DREAMSampleCore" alt=""/></div>
<map name="agroup____DREAMSampleCore" id="agroup____DREAMSampleCore">
<area shape="rect" title=" " alt="" coords="201,20,395,45"/>
<area shape="rect" href="group__TasmanianDREAM.html" title=" " alt="" coords="5,5,153,60"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafeb68ea720f1eaaf79fa2e02422d760f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">TasDREAM::DreamDomain</a> = std::function&lt; bool(std::vector&lt; double &gt; const &amp;x)&gt;</td></tr>
<tr class="memdesc:gafeb68ea720f1eaaf79fa2e02422d760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic test function whether a sample belongs in the domain.  <a href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">More...</a><br /></td></tr>
<tr class="separator:gafeb68ea720f1eaaf79fa2e02422d760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5add005db743d24f08a6ace332bb90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">TasDREAM::DreamPDF</a> = std::function&lt; void(const std::vector&lt; double &gt; &amp;candidates, std::vector&lt; double &gt; &amp;values)&gt;</td></tr>
<tr class="memdesc:ga7a5add005db743d24f08a6ace332bb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic probability distribution used by Tasmanian.  <a href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">More...</a><br /></td></tr>
<tr class="separator:ga7a5add005db743d24f08a6ace332bb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a11e40c3382379abad6b3afc43cc9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d">TasDREAM::DreamModel</a> = std::function&lt; void(const std::vector&lt; double &gt; &amp;candidates, std::vector&lt; double &gt; &amp;outputs)&gt;</td></tr>
<tr class="memdesc:ga23a11e40c3382379abad6b3afc43cc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic model signature used by Tasmanian.  <a href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d">More...</a><br /></td></tr>
<tr class="separator:ga23a11e40c3382379abad6b3afc43cc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebb714e7e8eb21e67da8121cac622ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea">TasDREAM::DreamLikelihood</a> = std::function&lt; void(<a class="el" href="group__DREAMEnumerates.html#ga71a406371701ba98394a923434395ff5">TypeSamplingForm</a> form, const std::vector&lt; double &gt; &amp;model_outputs, std::vector&lt; double &gt; &amp;likely)&gt;</td></tr>
<tr class="memdesc:gacebb714e7e8eb21e67da8121cac622ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic likelihood signature used by Tasmanian.  <a href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea">More...</a><br /></td></tr>
<tr class="separator:gacebb714e7e8eb21e67da8121cac622ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ac315139d1f687abe581f344af92f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#gaf3ac315139d1f687abe581f344af92f1">TasDREAM::DreamPrior</a> = std::function&lt; void(<a class="el" href="group__DREAMEnumerates.html#ga71a406371701ba98394a923434395ff5">TypeSamplingForm</a> form, const std::vector&lt; double &gt; &amp;candidates, std::vector&lt; double &gt; &amp;values)&gt;</td></tr>
<tr class="memdesc:gaf3ac315139d1f687abe581f344af92f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic signature for the prior distributions used by Tasmanian.  <a href="group__DREAMSampleCore.html#gaf3ac315139d1f687abe581f344af92f1">More...</a><br /></td></tr>
<tr class="separator:gaf3ac315139d1f687abe581f344af92f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aaf27a3d3639c0f0cdf270af1f45c22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga1aaf27a3d3639c0f0cdf270af1f45c22">TasDREAM::DreamMergedLikelyModel</a> = std::function&lt; void(const std::vector&lt; double &gt; &amp;candidates, std::vector&lt; double &gt; &amp;values)&gt;</td></tr>
<tr class="memdesc:ga1aaf27a3d3639c0f0cdf270af1f45c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic signature for a combination of a likelihood and a model.  <a href="group__DREAMSampleCore.html#ga1aaf27a3d3639c0f0cdf270af1f45c22">More...</a><br /></td></tr>
<tr class="separator:ga1aaf27a3d3639c0f0cdf270af1f45c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga51ca0fa1e74342db600bb9186fdd8158"><td class="memItemLeft" align="right" valign="top"><a id="ga51ca0fa1e74342db600bb9186fdd8158"></a>
<a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">DreamDomain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga51ca0fa1e74342db600bb9186fdd8158">TasDREAM::hypercube</a> (std::vector&lt; double &gt; const &amp;lower, std::vector&lt; double &gt; const &amp;upper)</td></tr>
<tr class="memdesc:ga51ca0fa1e74342db600bb9186fdd8158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a lambda that matches the <b>inside</b> signature in <b><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">SampleDREAM()</a></b>, test if the vector x is in the hyperbube described by <b>lower</b> and <b>upper</b>. <br /></td></tr>
<tr class="separator:ga51ca0fa1e74342db600bb9186fdd8158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22795d18ab97c804ae7a4feec71d0da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga22795d18ab97c804ae7a4feec71d0da2">TasDREAM::no_update</a> (std::vector&lt; double &gt; &amp;)</td></tr>
<tr class="memdesc:ga22795d18ab97c804ae7a4feec71d0da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy function that does not make any changes to the vector as default for the <b>independent_update()</b> in <b><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">SampleDREAM()</a></b>.  <a href="group__DREAMSampleCore.html#ga22795d18ab97c804ae7a4feec71d0da2">More...</a><br /></td></tr>
<tr class="separator:ga22795d18ab97c804ae7a4feec71d0da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d96d12972b7baca992d9fc4f9ed7d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga72d96d12972b7baca992d9fc4f9ed7d4">TasDREAM::const_one</a> ()</td></tr>
<tr class="memdesc:ga72d96d12972b7baca992d9fc4f9ed7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy function that returns 1.0, used as default for the <b>differential_update()</b> in <b><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">SampleDREAM()</a></b>.  <a href="group__DREAMSampleCore.html#ga72d96d12972b7baca992d9fc4f9ed7d4">More...</a><br /></td></tr>
<tr class="separator:ga72d96d12972b7baca992d9fc4f9ed7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c17682f1d9e0eb669a74cbd6c5fadfa"><td class="memTemplParams" colspan="2">template&lt;int weight_percent&gt; </td></tr>
<tr class="memitem:ga1c17682f1d9e0eb669a74cbd6c5fadfa"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga1c17682f1d9e0eb669a74cbd6c5fadfa">TasDREAM::const_percent</a> ()</td></tr>
<tr class="memdesc:ga1c17682f1d9e0eb669a74cbd6c5fadfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that returns a constant based on the percentage, i.e., <b>weight_percent</b> / 100.0.  <a href="group__DREAMSampleCore.html#ga1c17682f1d9e0eb669a74cbd6c5fadfa">More...</a><br /></td></tr>
<tr class="separator:ga1c17682f1d9e0eb669a74cbd6c5fadfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7100467a4cf3a6335fff1fe5f6a5a747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747">TasDREAM::uniform_prior</a> (<a class="el" href="group__DREAMEnumerates.html#ga71a406371701ba98394a923434395ff5">TypeSamplingForm</a>, const std::vector&lt; double &gt; &amp;, std::vector&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:ga7100467a4cf3a6335fff1fe5f6a5a747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform prior distribution for both regular and log form.  <a href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747">More...</a><br /></td></tr>
<tr class="separator:ga7100467a4cf3a6335fff1fe5f6a5a747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631fef1c5cc457528b0857c3d4ad2043"><td class="memTemplParams" colspan="2">template&lt;TypeSamplingForm form = regform&gt; </td></tr>
<tr class="memitem:ga631fef1c5cc457528b0857c3d4ad2043"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">DreamPDF</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga631fef1c5cc457528b0857c3d4ad2043">TasDREAM::posterior</a> (<a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d">DreamModel</a> model, <a class="el" href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea">DreamLikelihood</a> likelihood, <a class="el" href="group__DREAMSampleCore.html#gaf3ac315139d1f687abe581f344af92f1">DreamPrior</a> prior)</td></tr>
<tr class="memdesc:ga631fef1c5cc457528b0857c3d4ad2043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the three components of a Bayesian posterior into a single distribution.  <a href="group__DREAMSampleCore.html#ga631fef1c5cc457528b0857c3d4ad2043">More...</a><br /></td></tr>
<tr class="separator:ga631fef1c5cc457528b0857c3d4ad2043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9133b6fe7da7bcf959b319c1cb2e422e"><td class="memTemplParams" colspan="2">template&lt;TypeSamplingForm form = regform&gt; </td></tr>
<tr class="memitem:ga9133b6fe7da7bcf959b319c1cb2e422e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">DreamPDF</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga9133b6fe7da7bcf959b319c1cb2e422e">TasDREAM::posterior</a> (<a class="el" href="group__DREAMSampleCore.html#ga1aaf27a3d3639c0f0cdf270af1f45c22">DreamMergedLikelyModel</a> likelihood_model, <a class="el" href="group__DREAMSampleCore.html#gaf3ac315139d1f687abe581f344af92f1">DreamPrior</a> prior)</td></tr>
<tr class="memdesc:ga9133b6fe7da7bcf959b319c1cb2e422e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload where the model and likelihood are combined into a single call.  <a href="group__DREAMSampleCore.html#ga9133b6fe7da7bcf959b319c1cb2e422e">More...</a><br /></td></tr>
<tr class="separator:ga9133b6fe7da7bcf959b319c1cb2e422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3d35404c9a3afcf10048364b3ce6dc"><td class="memTemplParams" colspan="2">template&lt;TypeSamplingForm form = regform&gt; </td></tr>
<tr class="memitem:ga3a3d35404c9a3afcf10048364b3ce6dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc">TasDREAM::SampleDREAM</a> (int num_burnup, int num_collect, <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">DreamPDF</a> probability_distribution, <a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">DreamDomain</a> inside, <a class="el" href="classTasDREAM_1_1TasmanianDREAM.html">TasmanianDREAM</a> &amp;state, std::function&lt; void(std::vector&lt; double &gt; &amp;x)&gt; independent_update=<a class="el" href="group__DREAMSampleCore.html#ga22795d18ab97c804ae7a4feec71d0da2">no_update</a>, std::function&lt; double(void)&gt; differential_update=<a class="el" href="group__DREAMSampleCore.html#ga72d96d12972b7baca992d9fc4f9ed7d4">const_one</a>, std::function&lt; double(void)&gt; get_random01=<a class="el" href="namespaceTasDREAM.html#a7bd06b0f18e539d527de0951594e75a7">tsgCoreUniform01</a>)</td></tr>
<tr class="memdesc:ga3a3d35404c9a3afcf10048364b3ce6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core template for the sampling algorithm.  <a href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc">More...</a><br /></td></tr>
<tr class="separator:ga3a3d35404c9a3afcf10048364b3ce6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f61969203c5fbe30334dfe7cbcca8bf"><td class="memTemplParams" colspan="2">template&lt;TypeSamplingForm form = regform&gt; </td></tr>
<tr class="memitem:ga1f61969203c5fbe30334dfe7cbcca8bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DREAMSampleCore.html#ga1f61969203c5fbe30334dfe7cbcca8bf">TasDREAM::SampleDREAM</a> (int num_burnup, int num_collect, <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">DreamPDF</a> probability_distribution, <a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">DreamDomain</a> inside, <a class="el" href="classTasDREAM_1_1TasmanianDREAM.html">TasmanianDREAM</a> &amp;state, <a class="el" href="group__DREAMEnumerates.html#ga0bb0e31a49288d281d3039eb3fb32d36">TypeDistribution</a> dist, double magnitude, std::function&lt; double(void)&gt; differential_update=<a class="el" href="group__DREAMSampleCore.html#ga72d96d12972b7baca992d9fc4f9ed7d4">const_one</a>, std::function&lt; double(void)&gt; get_random01=<a class="el" href="namespaceTasDREAM.html#a7bd06b0f18e539d527de0951594e75a7">tsgCoreUniform01</a>)</td></tr>
<tr class="memdesc:ga1f61969203c5fbe30334dfe7cbcca8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <b><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">SampleDREAM()</a></b> assuming independent update from a list of internally implemented options.  <a href="group__DREAMSampleCore.html#ga1f61969203c5fbe30334dfe7cbcca8bf">More...</a><br /></td></tr>
<tr class="separator:ga1f61969203c5fbe30334dfe7cbcca8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Templates and auxiliary methods for the DREAM sampling. The main template is <a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">TasDREAM::SampleDREAM()</a> with one overload and several helper functions. The helpers provide ways to define the probability distribution: either custom defined, interpolated with a sparse grid, or product of Bayesian inference problem. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gafeb68ea720f1eaaf79fa2e02422d760f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeb68ea720f1eaaf79fa2e02422d760f">&#9670;&nbsp;</a></span>DreamDomain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">TasDREAM::DreamDomain</a> = typedef std::function&lt;bool(std::vector&lt;double&gt; const &amp;x)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic test function whether a sample belongs in the domain. </p>
<p>The function accepts a single vector with size equal to the number of domain dimensions and must return <b>true</b> if the vector belongs to the domain or <b>false</b> otherwise. </p>

</div>
</div>
<a id="ga7a5add005db743d24f08a6ace332bb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a5add005db743d24f08a6ace332bb90">&#9670;&nbsp;</a></span>DreamPDF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">TasDREAM::DreamPDF</a> = typedef std::function&lt;void(const std::vector&lt;double&gt; &amp;candidates, std::vector&lt;double&gt; &amp;values)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic probability distribution used by Tasmanian. </p>
<p>The probability distribution must be set to accept multiple candidates and return the value of the unscaled probability distribution for each point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidates</td><td>is a vector with size that is an even multiple of the dimensions, the vector is organized logically into strips of size num-dimensions. Each strip represents a test point that is guaranteed to be inside the domain. </td></tr>
    <tr><td class="paramname">values</td><td>is a vector with size equal to the number of strips (samples) in <b>candidates</b>. The vector should not be resized, instead each value has to be overwritten with the corresponding unscaled probability distribution.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> the generic probability distribution does not accept a parameter to specify the sampling form, e.g., <a class="el" href="group__DREAMEnumerates.html#gga71a406371701ba98394a923434395ff5ad662ab51216cd8c4f7cc6a832bc63e80" title="Use the logarithm form for the probability density.">TasDREAM::logform</a>. The returned values <b>must</b> corresponding to the sampling form set in the <a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">TasDREAM::SampleDREAM()</a> template. If logarithm form is used, the values can be negative, in regular form the values must be positive, Tasmanian will not throw an exception but using negative values with <a class="el" href="group__DREAMEnumerates.html#gga71a406371701ba98394a923434395ff5a72f0ea425fcdf8ac86f37c261ef9fc5a" title="Use the standard form for the probability density.">TasDREAM::regform</a> leads to undefined behavior. </p>

</div>
</div>
<a id="ga23a11e40c3382379abad6b3afc43cc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23a11e40c3382379abad6b3afc43cc9d">&#9670;&nbsp;</a></span>DreamModel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d">TasDREAM::DreamModel</a> = typedef std::function&lt;void(const std::vector&lt;double&gt; &amp;candidates, std::vector&lt;double&gt; &amp;outputs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic model signature used by Tasmanian. </p>
<p>The model is very similar to the <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90" title="Generic probability distribution used by Tasmanian.">TasDREAM::DreamPDF</a>, in fact the input <b>candidates</b> is the same. The differences are two:</p><ul>
<li>the model may have multiple outputs and the number of returned outputs must match the number of outputs used by the likelihood.</li>
<li>the <b>outputs</b> vector will not be set to the correct size, it <b>must</b> be resized, because Tasmanian does not keep track of the number of outputs.</li>
</ul>
<p><b>Note:</b> the <b>outputs</b> vector will be fed as input to the <a class="el" href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea" title="Generic likelihood signature used by Tasmanian.">TasDREAM::DreamLikelihood</a>. </p>

</div>
</div>
<a id="gacebb714e7e8eb21e67da8121cac622ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacebb714e7e8eb21e67da8121cac622ea">&#9670;&nbsp;</a></span>DreamLikelihood</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea">TasDREAM::DreamLikelihood</a> = typedef std::function&lt;void(<a class="el" href="group__DREAMEnumerates.html#ga71a406371701ba98394a923434395ff5">TypeSamplingForm</a> form, const std::vector&lt;double&gt; &amp;model_outputs, std::vector&lt;double&gt; &amp;likely)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic likelihood signature used by Tasmanian. </p>
<p>The likelihood assigns a value to how likely the model outputs are given data (i.e., measurements). Classes that inherit <a class="el" href="classTasDREAM_1_1TasmanianLikelihood.html" title="Interface for the likelihood classes.">TasmanianLikelihood</a> will automatically convert to a lambda object with this signature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form</td><td>is the sampling type used in the call to <a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">TasDREAM::SampleDREAM()</a>, in a custom object it is sufficient to implement only one form, Tasmanian likelihood classes implement both and thus the parameter specifies which implementation to use. </td></tr>
    <tr><td class="paramname">model_outputs</td><td>is identical to <b>outputs</b> parameter in <a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d" title="Generic model signature used by Tasmanian.">TasDREAM::DreamModel</a> except here it is used as an input to compute the likelihood. </td></tr>
    <tr><td class="paramname">likely</td><td>is a vector with size equal to the entries with <b>outputs</b>, the entries must be overwritten with the corresponding likelihood. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3ac315139d1f687abe581f344af92f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3ac315139d1f687abe581f344af92f1">&#9670;&nbsp;</a></span>DreamPrior</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__DREAMSampleCore.html#gaf3ac315139d1f687abe581f344af92f1">TasDREAM::DreamPrior</a> = typedef std::function&lt;void(<a class="el" href="group__DREAMEnumerates.html#ga71a406371701ba98394a923434395ff5">TypeSamplingForm</a> form, const std::vector&lt;double&gt; &amp;candidates, std::vector&lt;double&gt; &amp;values)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic signature for the prior distributions used by Tasmanian. </p>
<p>Specifies the prior distribution, the <a class="el" href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747" title="Uniform prior distribution for both regular and log form.">TasDREAM::uniform_prior()</a> satisfies this signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form</td><td>is the same as in <a class="el" href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea" title="Generic likelihood signature used by Tasmanian.">TasDREAM::DreamLikelihood</a>. </td></tr>
    <tr><td class="paramname">candidates</td><td>is the same as in <a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d" title="Generic model signature used by Tasmanian.">TasDREAM::DreamModel</a> and <a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90" title="Generic probability distribution used by Tasmanian.">TasDREAM::DreamPDF</a>. </td></tr>
    <tr><td class="paramname">values</td><td>are similar to the <b>likely</b> in <a class="el" href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea" title="Generic likelihood signature used by Tasmanian.">TasDREAM::DreamLikelihood</a>, but instead of the likelihood the values define the prior distribution in the specified <b>form</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1aaf27a3d3639c0f0cdf270af1f45c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aaf27a3d3639c0f0cdf270af1f45c22">&#9670;&nbsp;</a></span>DreamMergedLikelyModel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__DREAMSampleCore.html#ga1aaf27a3d3639c0f0cdf270af1f45c22">TasDREAM::DreamMergedLikelyModel</a> = typedef std::function&lt;void(const std::vector&lt;double&gt; &amp;candidates, std::vector&lt;double&gt; &amp;values)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic signature for a combination of a likelihood and a model. </p>
<p>The likelihood and the model are not always separated, e.g., a sparse grid approximation can be used to interpolated the likelihood which has a single output and is therefore cheaper than interpolating multi-output model. The implementation should be equivalent to: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidates</td><td>is same as in <a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d" title="Generic model signature used by Tasmanian.">TasDREAM::DreamModel</a>. </td></tr>
    <tr><td class="paramname">values</td><td>is same as in <a class="el" href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea" title="Generic likelihood signature used by Tasmanian.">TasDREAM::DreamLikelihood</a> <b>likely</b> parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga22795d18ab97c804ae7a4feec71d0da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22795d18ab97c804ae7a4feec71d0da2">&#9670;&nbsp;</a></span>no_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasDREAM::no_update </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy function that does not make any changes to the vector as default for the <b>independent_update()</b> in <b><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">SampleDREAM()</a></b>. </p>
<p>The function is no-op. </p>

</div>
</div>
<a id="ga72d96d12972b7baca992d9fc4f9ed7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72d96d12972b7baca992d9fc4f9ed7d4">&#9670;&nbsp;</a></span>const_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TasDREAM::const_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy function that returns 1.0, used as default for the <b>differential_update()</b> in <b><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">SampleDREAM()</a></b>. </p>
<p>Just an inline function that returns 1.0. </p>

</div>
</div>
<a id="ga1c17682f1d9e0eb669a74cbd6c5fadfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c17682f1d9e0eb669a74cbd6c5fadfa">&#9670;&nbsp;</a></span>const_percent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int weight_percent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double TasDREAM::const_percent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template that returns a constant based on the percentage, i.e., <b>weight_percent</b> / 100.0. </p>
<p>The template simplifies the syntax when calling <b><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">SampleDREAM()</a></b> with a constant differential update. For example, setting the update to 0.5 can be done with </p><div class="fragment"><div class="line">TasmanianDREAM state(...);</div>
<div class="line"><a class="code" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc">SampleDREAM</a>(..., independent_update, const_percent&lt;50&gt;, state);</div>
<div class="ttc" id="agroup__DREAMSampleCore_html_ga3a3d35404c9a3afcf10048364b3ce6dc"><div class="ttname"><a href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc">TasDREAM::SampleDREAM</a></div><div class="ttdeci">void SampleDREAM(int num_burnup, int num_collect, DreamPDF probability_distribution, DreamDomain inside, TasmanianDREAM &amp;state, std::function&lt; void(std::vector&lt; double &gt; &amp;x)&gt; independent_update=no_update, std::function&lt; double(void)&gt; differential_update=const_one, std::function&lt; double(void)&gt; get_random01=tsgCoreUniform01)</div><div class="ttdoc">Core template for the sampling algorithm.</div><div class="ttdef"><b>Definition:</b> tsgDreamSample.hpp:414</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga7100467a4cf3a6335fff1fe5f6a5a747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7100467a4cf3a6335fff1fe5f6a5a747">&#9670;&nbsp;</a></span>uniform_prior()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasDREAM::uniform_prior </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DREAMEnumerates.html#ga71a406371701ba98394a923434395ff5">TypeSamplingForm</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniform prior distribution for both regular and log form. </p>
<p>Applies uniform (non-informative) prior, can be used with any of the Bayesian inference methods. In practice, this actually does nothing, since adding zero (in <b>logform</b>) or mulitplying by 1 (in <b>regform</b>) amounts to nothing. </p>

</div>
</div>
<a id="ga631fef1c5cc457528b0857c3d4ad2043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631fef1c5cc457528b0857c3d4ad2043">&#9670;&nbsp;</a></span>posterior() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TypeSamplingForm form = regform&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">DreamPDF</a> TasDREAM::posterior </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#ga23a11e40c3382379abad6b3afc43cc9d">DreamModel</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#gacebb714e7e8eb21e67da8121cac622ea">DreamLikelihood</a>&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#gaf3ac315139d1f687abe581f344af92f1">DreamPrior</a>&#160;</td>
          <td class="paramname"><em>prior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines the three components of a Bayesian posterior into a single distribution. </p>
<p>The Bayesian posterior has a model, likelihood function and a prior distribution. This function combines three function objects into a single probability distribution that be passed to SampleDREAM, e.g., </p><div class="fragment"><div class="line"><a class="code" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc">SampleDREAM</a>(num_burnup, num_collect, <a class="code" href="group__DREAMSampleCore.html#ga631fef1c5cc457528b0857c3d4ad2043">posterior</a>(likely, model, <a class="code" href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747">uniform_prior</a>), ...);</div>
<div class="ttc" id="agroup__DREAMSampleCore_html_ga631fef1c5cc457528b0857c3d4ad2043"><div class="ttname"><a href="group__DREAMSampleCore.html#ga631fef1c5cc457528b0857c3d4ad2043">TasDREAM::posterior</a></div><div class="ttdeci">DreamPDF posterior(DreamModel model, DreamLikelihood likelihood, DreamPrior prior)</div><div class="ttdoc">Combines the three components of a Bayesian posterior into a single distribution.</div><div class="ttdef"><b>Definition:</b> tsgDreamSample.hpp:260</div></div>
<div class="ttc" id="agroup__DREAMSampleCore_html_ga7100467a4cf3a6335fff1fe5f6a5a747"><div class="ttname"><a href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747">TasDREAM::uniform_prior</a></div><div class="ttdeci">void uniform_prior(TypeSamplingForm, const std::vector&lt; double &gt; &amp;, std::vector&lt; double &gt; &amp;values)</div><div class="ttdoc">Uniform prior distribution for both regular and log form.</div><div class="ttdef"><b>Definition:</b> tsgDreamSample.hpp:120</div></div>
</div><!-- fragment --><p>The generality of the approach used here comes at the price of volatility. There is no builtin error-checking and error-detection on vector sizes. Specifically, the number of inputs provided by the model must match the outputs accepted by the likelihood, and the number of dimensions accepted by the model and prior must be the same.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">form</td><td>indicates whether to use the regular or logarithm of the sampling problem; Gaussian-types of likelihood functions are often used where the regular form can be <img class="formulaInl" alt="$ \exp( -0.5 x^2 ) $" src="form_35.png" width="95" height="21"/> while the log-form is <img class="formulaInl" alt="$ -0.5 x^2 $" src="form_36.png" width="53" height="16"/>, working with a simple quadratic function can be more stable with respect to rounding error. The template parameter <b>must</b> be the same as in the call to <a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">TasDREAM::SampleDREAM()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>accepts a set of model inputs and will return the corresponding model values.<ul>
<li><b>candidates</b> is the same as in the input of <b>probability_distribution()</b> in the call to <a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">TasDREAM::SampleDREAM()</a>. Logically the candidates will be arranged in strips of size equal to the problem dimensions, the vector size will divide evenly by the dimensions and the factor is the number of candidates.</li>
<li><b>outputs</b> must be resized to match the number of candidates times the number of outputs, the behavior must match that of TasmanianSparseGrid::evaluateBatch().</li>
</ul>
</td></tr>
    <tr><td class="paramname">likelihood</td><td>accepts a set of model outputs and provides a measure of how likely those outputs are given some observed data with some noise. Tasmanian provides likelihood functions that can be used here, e.g., <a class="el" href="classTasDREAM_1_1LikelihoodGaussIsotropic.html" title="Implements likelihood under the assumption of isotropic white noise.">TasDREAM::LikelihoodGaussIsotropic</a> and <a class="el" href="classTasDREAM_1_1LikelihoodGaussAnisotropic.html" title="Implements likelihood under the assumption of anisotropic white noise.">TasDREAM::LikelihoodGaussAnisotropic</a>.<ul>
<li>The <a class="el" href="group__DREAMEnumerates.html#ga71a406371701ba98394a923434395ff5" title="Describes whether sampling should be done with the regular or logarithm form of the probability densi...">TasDREAM::TypeSamplingForm</a> will always match the template parameter <b>form</b>, thus, it is sufficient to implement only one sampling from. The Tasmanian likelihood classes implement both forms, hence the added flexibility.</li>
<li>The <b>model_outputs</b> is a vector with size equal to the number of candidates times the number of outputs, i.e., must match the output of the <b>model</b>.</li>
<li>The <b>likely</b> will have size equal to the number of candidates and must be filled (without resize) with the likelihood for each set of model outputs.</li>
</ul>
</td></tr>
    <tr><td class="paramname">prior</td><td>provides the values of the prior distribution in either regular or logarithm form. The prior will take in the same <b>candidates</b> as the model and a vector of the same size as <b>likely</b>, and must return the values of the corresponding prior distribution in either regular or logarithm form.</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> model = TasGrid::read(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><a class="code" href="classTasDREAM_1_1LikelihoodGaussIsotropic.html">TasDREAM::LikelihoodGaussIsotropic</a> likely(0.1, data);</div>
<div class="line"><a class="code" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc">TasDREAM::SampleDREAM</a>(..., <a class="code" href="group__DREAMSampleCore.html#ga631fef1c5cc457528b0857c3d4ad2043">TasDREAM::posterior</a>(likely, model, <a class="code" href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747">TasDREAM::uniform_prior</a>), ...);</div>
<div class="ttc" id="aclassTasDREAM_1_1LikelihoodGaussIsotropic_html"><div class="ttname"><a href="classTasDREAM_1_1LikelihoodGaussIsotropic.html">TasDREAM::LikelihoodGaussIsotropic</a></div><div class="ttdoc">Implements likelihood under the assumption of isotropic white noise.</div><div class="ttdef"><b>Definition:</b> tsgDreamLikelyGaussian.hpp:59</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9133b6fe7da7bcf959b319c1cb2e422e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9133b6fe7da7bcf959b319c1cb2e422e">&#9670;&nbsp;</a></span>posterior() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TypeSamplingForm form = regform&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">DreamPDF</a> TasDREAM::posterior </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#ga1aaf27a3d3639c0f0cdf270af1f45c22">DreamMergedLikelyModel</a>&#160;</td>
          <td class="paramname"><em>likelihood_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#gaf3ac315139d1f687abe581f344af92f1">DreamPrior</a>&#160;</td>
          <td class="paramname"><em>prior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload where the model and likelihood are combined into a single call. </p>
<p>There are situations where splitting the model and likelihood is undesirable, e.g., if the model has a huge number of outputs it may be easier to construct a sparse grid surrogate to the single-output combined model and likelihood. This is a short hand-template that uses such model-likelihood and combines it with a prior distribution. </p>

</div>
</div>
<a id="ga3a3d35404c9a3afcf10048364b3ce6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3d35404c9a3afcf10048364b3ce6dc">&#9670;&nbsp;</a></span>SampleDREAM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TypeSamplingForm form = regform&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasDREAM::SampleDREAM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_burnup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_collect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">DreamPDF</a>&#160;</td>
          <td class="paramname"><em>probability_distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">DreamDomain</a>&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasDREAM_1_1TasmanianDREAM.html">TasmanianDREAM</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::vector&lt; double &gt; &amp;x)&gt;&#160;</td>
          <td class="paramname"><em>independent_update</em> = <code><a class="el" href="group__DREAMSampleCore.html#ga22795d18ab97c804ae7a4feec71d0da2">no_update</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(void)&gt;&#160;</td>
          <td class="paramname"><em>differential_update</em> = <code><a class="el" href="group__DREAMSampleCore.html#ga72d96d12972b7baca992d9fc4f9ed7d4">const_one</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(void)&gt;&#160;</td>
          <td class="paramname"><em>get_random01</em> = <code><a class="el" href="namespaceTasDREAM.html#a7bd06b0f18e539d527de0951594e75a7">tsgCoreUniform01</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core template for the sampling algorithm. </p>
<p>Evolves the chains of the <b>state</b> using the Metropolis algorithm where the updates are comprised of two components, independent and differential. The independent component relies on independently sampled (pesudo)-random numbers with zero mean (could be deterministic constant zero). The differential component is based on the difference between two randomly chosen chains, which effectively exchanges information between the chains.</p>
<p>The implementation is very generic using lambda objects to describe most aspects of the problem, including the probability distribution, domain, etc. However, the generality comes with some sacrifice in resilience, i.e.,</p><ul>
<li>each lambda object must respect the problem dimensions, the template will populate the inputs with the correct number of entries, but the lambdas have to properly utilize the entries.</li>
<li>each lambda will have to capture external objects and variables and should avoid capture by value for large vectors, e.g., a sparse grid or a large data vector, while objects captured by reference must remain alive during the call to the template. See couple of examples after the variable listing.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">form</td><td>indicates whether the <b>probability_distribution()</b> function return the regular form or the logarithm of the desired pdf; in some cases, taking the exponential of a very large negative number can lead to problems with rounding comparison between numbers very close to zero, hence the logarithm from could be more stable from the round-off error perspective.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_burnup</td><td>is the number of initial iterations that will not be saved in the history; the Metropolis algorithm guarantees convergence to the desired distribution but only in the limit; when working with a finite number of samples the results can be contaminated by the initial state which can be significantly different from the limit. A common practice is to take <b>num_burnup</b> to be roughly equal to <b>num_collect</b>, but that is only a heuristic suggestion.</td></tr>
    <tr><td class="paramname">num_collect</td><td>is the number of iterations that will be saved in the <b>state</b> history, the total number of collected samples is <b>num_collect</b> times <b>state.getNumChains()</b>.</td></tr>
    <tr><td class="paramname">probability_distribution</td><td>must accept a vector of <b>candidates</b> locations and return the <b>values</b> of the unscaled probability distribution at those points. The input-output relation is similar to working with TasmanianSparseGrid::evaluateBatch() when the grid has a a single output.<ul>
<li>The <b>candidates</b> input will be logically divided into strips of size <b>state.getNumDimensions()</b>, the total number of strips will be between 1 and <b>state.getNumChains()</b> depending on the number of proposals that fall within the domain, i.e., the inputs will always satisfy the <b>inside()</b> condition.</li>
<li>The <b>values</b> will have size equal to the number of strips and each entry should be filled the corresponding value of the probability density function. The <b>values</b> vector should not be resized.</li>
<li>Any <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html" title="The master-class that represents an instance of a Tasmanian sparse grid.">TasGrid::TasmanianSparseGrid</a> object with a single output and non-zero loaded points can be passed in as a <b>probability_distribution</b>; when using <a class="el" href="group__DREAMEnumerates.html#gga71a406371701ba98394a923434395ff5a72f0ea425fcdf8ac86f37c261ef9fc5a" title="Use the standard form for the probability density.">TasDREAM::regform</a> the output of the grid must be always non-negative, using <a class="el" href="group__DREAMEnumerates.html#gga71a406371701ba98394a923434395ff5ad662ab51216cd8c4f7cc6a832bc63e80" title="Use the logarithm form for the probability density.">TasDREAM::logform</a> has no lower bound requirements.</li>
<li>In the context of Bayesian inference, there probability distribution is comprised of three components: model, likelihood, and prior. See <a class="el" href="group__DREAMSampleCore.html#ga631fef1c5cc457528b0857c3d4ad2043" title="Combines the three components of a Bayesian posterior into a single distribution.">TasDREAM::posterior()</a>.</li>
</ul>
</td></tr>
    <tr><td class="paramname">inside</td><td>must accept a vector of size equal tot he number of dimensions and return <b>true</b> if the vector describes a point in the domain and <b>false</b> otherwise. The function will be called for every proposed sample and unlike the <b>probability_distribution</b> only one vector will be given as input at a time. Each <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html" title="The master-class that represents an instance of a Tasmanian sparse grid.">TasGrid::TasmanianSparseGrid</a> object some with a canonical domain that depends on the rule and can be optionally transformed, the TasmanianSparseGrid::getDomainInside() method will produce a lambda object describing the sparse grid domain. See also TasDREAM::hyperbube().</td></tr>
    <tr><td class="paramname">state</td><td>must be an initialized instance of <a class="el" href="classTasDREAM_1_1TasmanianDREAM.html" title="Contains the current state and the history of the DREAM chains.">TasmanianDREAM</a>. The number of chains and dimensions must be set to match the lambda objects and <a class="el" href="classTasDREAM_1_1TasmanianDREAM.html#af21dfe71359d25ae03d5ea00138009b1" title="Set the current DREAM state to the new_state.">TasmanianDREAM::setState()</a> must be called to load the state with a valid initial set of vectors. The <b>state</b> will be evolved in total of <b>num_burnup</b> + <b>num_collect</b> iterations and the last set of <b>num_collect</b> iterations will be appended to the state history.</td></tr>
    <tr><td class="paramname">independent_update</td><td>must accept a vector of size <b>state.getNumDimensions()</b> and (without resizing) perturb each entry by adding an independent zero-mean random number. It is possible to omit the <b>independent_update</b>, e.g., pass an object that will not modify the input vector x; however, this can lock the chains to a set of values not dense in the domain which in turn will break convergence. For example, if the domain is the real line, the initial state has integer entries, and the <b>differential_update</b> is set to 100%, then all proposals will be integers, non-integer values will never be considered. <a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">TasDREAM::SampleDREAM</a> provides an overload where the independent update is set to a distribution from an included list with known magnitude.</td></tr>
    <tr><td class="paramname">differential_update</td><td>is a random or deterministic number between zero and one, indicating the magnitude of the difference between two randomly chosen chains that will be added to the next proposal. Using deterministic zero will decouple the chains, i.e., the state of one chain will never affect any other chain and the algorithm will reduce to the propagation of multiple independent chains of the standard Metropolis-Hastings method with the selected <b>independent_update</b>. Using negative values (by symmetry) is equivalent to using a positive value with the same magnitude, and values larger than 1 are likely to result in poor mixing and bad convergence rate. The default differential update is deterministic one and deterministic percentage can be specified with the <b><a class="el" href="group__DREAMSampleCore.html#ga1c17682f1d9e0eb669a74cbd6c5fadfa" title="Template that returns a constant based on the percentage, i.e., weight_percent / 100....">const_percent()</a></b> template.</td></tr>
    <tr><td class="paramname">get_random01</td><td>is the pseudo-random number generator to be used in the sampling procedure. By default, Tasmanian will use <b>rand()</b> divided by <b>RAND_MAX</b>, but this is implementation dependent and not always optimal.</td></tr>
  </table>
  </dd>
</dl>
<p>Correct call using a sparse grid object as input: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> grid = TasGrid::read(<span class="stringliteral">&quot;foo&quot;</span>); <span class="comment">// create a grid object</span></div>
<div class="line"><a class="code" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc">SampleDREAM</a>(..., grid, ...);</div>
<div class="line"><span class="comment">// above, the grid will create a lambda object that will capture grid by reference</span></div>
<div class="line"><span class="comment">// the lambda object is destroyed at the end of the call and before grid</span></div>
</div><!-- fragment --><p> Incorrect call, <b>never</b> <b>do</b> <b>that:</b> </p><div class="fragment"><div class="line"><a class="code" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc">SampleDREAM</a>(..., TasGrid::read(<span class="stringliteral">&quot;foo&quot;</span>), ...); <span class="comment">// &lt;- Incorrect</span></div>
<div class="line"><span class="comment">// above, read() will create a TasmanianSparseGrid object which will create a lambda</span></div>
<div class="line"><span class="comment">// but the grid will be destroyed before entering the SampleDREAM() and cause a segfault.</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga1f61969203c5fbe30334dfe7cbcca8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f61969203c5fbe30334dfe7cbcca8bf">&#9670;&nbsp;</a></span>SampleDREAM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TypeSamplingForm form = regform&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasDREAM::SampleDREAM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_burnup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_collect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#ga7a5add005db743d24f08a6ace332bb90">DreamPDF</a>&#160;</td>
          <td class="paramname"><em>probability_distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">DreamDomain</a>&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasDREAM_1_1TasmanianDREAM.html">TasmanianDREAM</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DREAMEnumerates.html#ga0bb0e31a49288d281d3039eb3fb32d36">TypeDistribution</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(void)&gt;&#160;</td>
          <td class="paramname"><em>differential_update</em> = <code><a class="el" href="group__DREAMSampleCore.html#ga72d96d12972b7baca992d9fc4f9ed7d4">const_one</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(void)&gt;&#160;</td>
          <td class="paramname"><em>get_random01</em> = <code><a class="el" href="namespaceTasDREAM.html#a7bd06b0f18e539d527de0951594e75a7">tsgCoreUniform01</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <b><a class="el" href="group__DREAMSampleCore.html#ga3a3d35404c9a3afcf10048364b3ce6dc" title="Core template for the sampling algorithm.">SampleDREAM()</a></b> assuming independent update from a list of internally implemented options. </p>
<p>Uses independent update is applied uniformly to all dimensions and comes from a list of internal functions, e.g., uniform or Gaussian. This overload wraps around functions such as <b>TasDREAM::applyUniformCorrection()</b> and <b>TasDREAM::applyGaussianCorrection()</b>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div> -->
</body>
</html>
