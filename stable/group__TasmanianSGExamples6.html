<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: Tasmanian Sparse Grids module, example 6</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TasmanianSGExamples6.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Tasmanian Sparse Grids module, example 6<div class="ingroups"><a class="el" href="group__TasmanianSGExamples.html">Examples for the Tasmanian Sparse Grid module</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Tasmanian Sparse Grids module, example 6:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianSGExamples6.png" border="0" usemap="#agroup____TasmanianSGExamples6" alt=""/></div>
<map name="agroup____TasmanianSGExamples6" id="agroup____TasmanianSGExamples6">
<area shape="rect" href="group__TasmanianSGExamples.html" title=" " alt="" coords="5,5,193,45"/>
<area shape="rect" title=" " alt="" coords="241,5,407,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacce078219e19854218cd5ec13a7fcf0f" id="r_gacce078219e19854218cd5ec13a7fcf0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSGExamples6.html#gacce078219e19854218cd5ec13a7fcf0f">sparse_grids_example_06</a> ()</td></tr>
<tr class="memdesc:gacce078219e19854218cd5ec13a7fcf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse Grids Example 6: adaptive surrogate modeling.  <br /></td></tr>
<tr class="separator:gacce078219e19854218cd5ec13a7fcf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Example 6</dt><dd>Build a surrogate model using automatic construction. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacce078219e19854218cd5ec13a7fcf0f" name="gacce078219e19854218cd5ec13a7fcf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce078219e19854218cd5ec13a7fcf0f">&#9670;&#160;</a></span>sparse_grids_example_06()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparse_grids_example_06 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sparse Grids Example 6: adaptive surrogate modeling. </p>
<p>Example 5 demonstrates how to construct a surrogate by processing the samples in batches. The batch construction can facilitate parallel sampling, but the exact number of samples is hard to control since the points from the entire batch are needed at once. Furthermore, if a fixed number of computing nodes is available (e.g., processor cores or MPI ranks) it may be hard to keep all nodes loaded if the batch size does not divide evenly.</p>
<p>The construction procedure offers a more flexible refinement alternative. The batch size can be controlled at a much finer scale to accommodate a fixed budget and occupancy across all parallel resources can be guaranteed (unless the level limits or tolerance are about to be reached, or the initial grid is too coarse). See the documentation for <a class="el" href="group__TasmanianAddonsMPIConstruct.html#ga959c5c21a2c9bffd485ac75f7098eafb" title="Construct a sparse grid surrogate to the model defined by the lambda, MPI version.">TasGrid::mpiConstructSurrogate()</a> for the MPI variant of this method that differs only in some MPI related parameters.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n---------------------------------------------------------------------------------------------------\n&quot;</span>;</div>
<div class="line">    cout &lt;&lt; std::scientific; cout.precision(4);</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Example 6: interpolate f(x,y) = exp(-x^2) * exp(y) * cos(z), using the rleja rule\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           employs adaptive construction\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// define the model as a C++ lambda expression, the advantage of lambdas</span></div>
<div class="line">    <span class="comment">// is that they can wrap around very complex models</span></div>
<div class="line">    <span class="comment">// the construction signature uses std::vector&lt;double&gt;</span></div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> num_inputs  = 3;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> num_outputs = 1;</div>
<div class="line">    <span class="keyword">auto</span> model = [&amp;](std::vector&lt;double&gt; <span class="keyword">const</span> &amp;x, std::vector&lt;double&gt; &amp;y, size_t)-&gt;</div>
<div class="line">        <span class="keywordtype">void</span>{</div>
<div class="line">            <span class="comment">// if no initial guess is used, then y will be guaranteed to have</span></div>
<div class="line">            <span class="comment">// the correct size, i.e., num_outputs</span></div>
<div class="line">            <span class="comment">// otherwise, y must be correctly resized</span></div>
<div class="line">            y.resize(num_outputs);</div>
<div class="line">            y[0] = std::exp(-x[0] * x[0]) * std::exp(x[1]) * std::cos(x[2]);</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the accuracy of the surrogate models is measure from 1000 random reference points</span></div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> num_test_points = 1000;</div>
<div class="line">    std::vector&lt;double&gt; test_points(num_test_points * num_inputs);</div>
<div class="line">    std::minstd_rand park_miller(42);</div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; domain(-1.0, 1.0);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;t : test_points) t = domain(park_miller);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;double&gt; reference_values(num_test_points * num_outputs);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_test_points; i++){</div>
<div class="line">        std::vector&lt;double&gt; y(1);</div>
<div class="line">        model(std::vector&lt;double&gt;(test_points.begin() + i * num_inputs,</div>
<div class="line">                                  test_points.begin() + (i+1) * num_inputs),</div>
<div class="line">              y, 0);</div>
<div class="line">        std::copy(y.begin(), y.end(), reference_values.begin() + i * num_outputs);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// computes the maximum error between the reference values and the grid interpolant</span></div>
<div class="line">    <span class="keyword">auto</span> test_grid = [&amp;](<a class="code hl_class" href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a> <span class="keyword">const</span> &amp;grid)-&gt;</div>
<div class="line">        <span class="keywordtype">double</span>{</div>
<div class="line">            std::vector&lt;double&gt; result;</div>
<div class="line">            grid.evaluateBatch(test_points, result);</div>
<div class="line">            <span class="keywordtype">double</span> diff = 0.0;</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_test_points; i++)</div>
<div class="line">                diff = std::max(diff, std::abs(result[i] - reference_values[i]));</div>
<div class="line">            <span class="keywordflow">return</span> diff;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// when the model is cheap to compute, running multiple-threads results in a large</span></div>
<div class="line">    <span class="comment">// difference in the time-per-sample due to the dominating cost of thread</span></div>
<div class="line">    <span class="comment">// synchronization</span></div>
<div class="line">    <span class="comment">// unfortunately, this can have adverse effect when important samples are delayed</span></div>
<div class="line">    <span class="comment">// and less important samples are computed thus wasting the budget</span></div>
<div class="line">    <span class="comment">// for that reason, the example runs sequentially</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> mode = <a class="code hl_variable" href="group__TasmanianAddonsConstruct.html#gab3bad3a625ef67b3daacad075f9ef730">TasGrid::mode_sequential</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> grid = <a class="code hl_function" href="group__TasmanianSG.html#ga40cde16ae94c02a23271df606918cfb9">TasGrid::makeSequenceGrid</a>(num_inputs, num_outputs, 2,</div>
<div class="line">                                          <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa6feeea3001da5a72dcf3602b9e3cfb0c">TasGrid::type_level</a>, <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67">TasGrid::rule_rleja</a>);</div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; setw(10) &lt;&lt; <span class="stringliteral">&quot;points&quot;</span> &lt;&lt; setw(20) &lt;&lt; <span class="stringliteral">&quot;error\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> budget = 25; <span class="comment">// try budget 50, 100, 200, 400, etc.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// running examples with ever increasing budget</span></div>
<div class="line">    <span class="comment">// the budget is defined as the sum of loaded + new points</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> itr=0; itr&lt;6; itr++){ <span class="comment">// run 6 example iterations</span></div>
<div class="line"> </div>
<div class="line">        budget *= 2; <span class="comment">// try budget 100, 200, 400, ...</span></div>
<div class="line"> </div>
<div class="line">        TasGrid::constructSurrogate&lt;mode&gt;(model, budget, 12, 1, grid,</div>
<div class="line">                                          <a class="code hl_enumvalue" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">TasGrid::type_iptotal</a>, 0);</div>
<div class="line"> </div>
<div class="line">        cout &lt;&lt; setw(10) &lt;&lt; grid.getNumPoints() &lt;&lt; setw(20) &lt;&lt; test_grid(grid) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Note: when using a sequence rule, the actual number of points always matches the budget</span></div>
<div class="line">    <span class="comment">// but this cannot be guaranteed for rules that grow by more than one node per level</span></div>
<div class="line">    <span class="comment">// because a tensor can be added only when all points are present and each tensor requires</span></div>
<div class="line">    <span class="comment">// more than one point</span></div>
<div class="line">    <span class="comment">// for fast growing rules, sometime it is simply not possible to build a grid</span></div>
<div class="line">    <span class="comment">// with exactly the given number of points</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef __TASMANIAN_DOXYGEN_SKIP</span></div>
<div class="ttc" id="aclassTasGrid_1_1TasmanianSparseGrid_html"><div class="ttname"><a href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a></div><div class="ttdoc">The master-class that represents an instance of a Tasmanian sparse grid.</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:293</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67">TasGrid::rule_rleja</a></div><div class="ttdeci">@ rule_rleja</div><div class="ttdoc">Classic sequence rule based on complex analysis, moderate Lebesgue constant growth (theoretically pro...</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:303</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga94134756077eff395566c64e6426455fa6feeea3001da5a72dcf3602b9e3cfb0c"><div class="ttname"><a href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa6feeea3001da5a72dcf3602b9e3cfb0c">TasGrid::type_level</a></div><div class="ttdeci">@ type_level</div><div class="ttdoc">Ignoring the polynomial space, use rules with index .</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:209</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431"><div class="ttname"><a href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">TasGrid::type_iptotal</a></div><div class="ttdeci">@ type_iptotal</div><div class="ttdoc">Total degree polynomial space for interpolation, i.e., the span of   .</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:221</div></div>
<div class="ttc" id="agroup__TasmanianAddonsConstruct_html_gab3bad3a625ef67b3daacad075f9ef730"><div class="ttname"><a href="group__TasmanianAddonsConstruct.html#gab3bad3a625ef67b3daacad075f9ef730">TasGrid::mode_sequential</a></div><div class="ttdeci">constexpr bool mode_sequential</div><div class="ttdoc">Allows for expressive calls to TasGrid::constructSurrogate().</div><div class="ttdef"><b>Definition</b> tsgConstructSurrogate.hpp:78</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_ga40cde16ae94c02a23271df606918cfb9"><div class="ttname"><a href="group__TasmanianSG.html#ga40cde16ae94c02a23271df606918cfb9">TasGrid::makeSequenceGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeSequenceGrid(int dimensions, int outputs, int depth, TypeDepth type, TypeOneDRule rule, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeSequenceGrid().</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:2302</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
