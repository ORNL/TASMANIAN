<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1: Tasmanian DREAM module, example 5</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.1
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TasmanianDREAMExamples5.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tasmanian DREAM module, example 5<div class="ingroups"><a class="el" href="group__TasmanianDREAMExamples.html">Examples for the Tasmanian DREAM module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Tasmanian DREAM module, example 5:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianDREAMExamples5.png" border="0" usemap="#agroup____TasmanianDREAMExamples5" alt=""/></div>
<map name="agroup____TasmanianDREAMExamples5" id="agroup____TasmanianDREAMExamples5">
<area shape="rect" title=" " alt="" coords="241,5,429,45"/>
<area shape="rect" href="group__TasmanianDREAMExamples.html" title=" " alt="" coords="5,5,193,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f9023617da230f349aa8a97dec2e14d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianDREAMExamples5.html#ga2f9023617da230f349aa8a97dec2e14d">dream_example_05</a> ()</td></tr>
<tr class="memdesc:ga2f9023617da230f349aa8a97dec2e14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DREAM Example 5: signal decomposition, finding the best fit.  <a href="group__TasmanianDREAMExamples5.html#ga2f9023617da230f349aa8a97dec2e14d">More...</a><br /></td></tr>
<tr class="separator:ga2f9023617da230f349aa8a97dec2e14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Example 5: Given noisy data that is the superposition of two sin-waves, find the frequency and magnitude of the waves, the frequency is on of 5 possible integer values. Unlike the previous cases where we were looking at the mean and variance of the solution, here we consider the mode of the posterior distribution, i.e., we want the values that give us best-fit in deterministic sense. The problem can be viewed as a deterministic optimization problem, but the noise in the data would offer significant challenges for any global optimization scheme; even if the solution computed by the DREAM algorithm is not sufficiently "close", it is still a very good initial guess for local optimization methods.</p>
<p>This example shows how to use DREAM with a custom model (without Tasmanian sparse grids) and a custom likelihood (not implemented in Tasmanian). The example also shows how to use DREAM sampling to search for the (approximate) solution to an optimization problem. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2f9023617da230f349aa8a97dec2e14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f9023617da230f349aa8a97dec2e14d">&#9670;&nbsp;</a></span>dream_example_05()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dream_example_05 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DREAM Example 5: signal decomposition, finding the best fit. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    <span class="comment">// using the default random engine, but must reset the random number generator</span></div>
<div class="line">    srand((<span class="keywordtype">int</span>) time(<span class="keyword">nullptr</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// EXAMPLE 5:</span></div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;---------------------------------------------------------------------------------------------------\n&quot;</span>;</div>
<div class="line">    cout &lt;&lt; std::scientific; cout.precision(5);</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;EXAMPLE 5: infer the frequency and magnitude of two signals from noisy data\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           the model has 5 parameters: f(x_1 ... x_5) = sum x_k sin(k * pi * t)\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           data = 2.0 * sin(2 * pi * t) + sin(4 * pi * t) + noise\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           t in [0, 1], t is discretized using 64 equidistant nodes\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           we use two different likelihood functions,&quot;</span></div>
<div class="line">         &lt;&lt;            <span class="stringliteral">&quot;corresponding to l-2 and l-1 norms\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           we are looking for the mode of the posterior,&quot;</span></div>
<div class="line">         &lt;&lt;            <span class="stringliteral">&quot;i.e., the optimal fit to the data\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keywordtype">double</span> pi = 3.14159265358979323846; <span class="comment">// half-period of the std::sin() function</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// higher dimensions require more samples</span></div>
<div class="line">    <span class="keywordtype">int</span> num_dimensions = 5;</div>
<div class="line">    <span class="keywordtype">int</span> num_chains = 50;</div>
<div class="line">    <span class="keywordtype">int</span> num_burnup_iterations = 1000;</div>
<div class="line">    <span class="keywordtype">int</span> num_sample_iterations = 1000;</div>
<div class="line">    <span class="comment">// the total number of samples is num_chains * num_iterations</span></div>
<div class="line">    <span class="keywordtype">int</span> num_discrete_nodes = 64;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a lambda function that represents the model</span></div>
<div class="line">    <span class="comment">// normally this would be a call to an external code</span></div>
<div class="line">    <span class="keyword">auto</span> model = [&amp;](std::vector&lt;double&gt; <span class="keyword">const</span> &amp;x, std::vector&lt;double&gt; &amp;y)-&gt;</div>
<div class="line">        <span class="keywordtype">void</span>{</div>
<div class="line">            <span class="keywordtype">double</span> dt = 1.0 / ((double) y.size());</div>
<div class="line">            <span class="keywordtype">double</span> t = 0.5 * dt;</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;output : y){</div>
<div class="line">                output = 0.0;</div>
<div class="line">                <span class="keywordtype">int</span> frequency = 1;</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span> &amp;weight : x)</div>
<div class="line">                    output += weight * std::sin(<span class="keywordtype">double</span>(frequency++) * t * pi);</div>
<div class="line">                t += dt;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the model defined above deals with single set of inputs</span></div>
<div class="line">    <span class="comment">// sampling requires that models are computed in batch</span></div>
<div class="line">    <span class="comment">// the size of x will always be a multiple of the number of inputs</span></div>
<div class="line">    <span class="comment">// the size of y MUST be set to the corresponding multiple of the number of outputs</span></div>
<div class="line">    <span class="comment">// batch evaluations are best done in parallel</span></div>
<div class="line">    <span class="keyword">auto</span> batch_model = [&amp;](std::vector&lt;double&gt; <span class="keyword">const</span> &amp;x, std::vector&lt;double&gt; &amp;y)-&gt;</div>
<div class="line">        <span class="keywordtype">void</span>{</div>
<div class="line">            <span class="keywordtype">int</span> num_samples = (int) x.size() / num_dimensions;</div>
<div class="line">            y.resize(num_samples * num_discrete_nodes);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// use up to 4 threads (if available)</span></div>
<div class="line">            <span class="keywordtype">int</span> num_threads = std::min((<span class="keywordtype">int</span>) std::thread::hardware_concurrency(), 4);</div>
<div class="line"> </div>
<div class="line">            std::vector&lt;std::thread&gt; workers(num_threads);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> start = 0; start&lt;num_threads; start++){</div>
<div class="line">                workers[start] = std::thread([&amp;, start]()-&gt;</div>
<div class="line">                    <span class="keywordtype">void</span>{</div>
<div class="line">                        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=start; i&lt;num_samples; i+=num_threads){</div>
<div class="line">                            std::vector&lt;double&gt; single_input(&amp;x[i*num_dimensions],</div>
<div class="line">                                                            &amp;x[i*num_dimensions] + num_dimensions);</div>
<div class="line">                            std::vector&lt;double&gt; single_output(num_discrete_nodes);</div>
<div class="line"> </div>
<div class="line">                            model(single_input, single_output);</div>
<div class="line"> </div>
<div class="line">                            std::copy(single_output.begin(), single_output.end(),</div>
<div class="line">                                      &amp;y[i*num_discrete_nodes]);</div>
<div class="line">                        }</div>
<div class="line">                    });</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;w : workers) w.join();</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;double&gt; signal = {0.0, 2.0, 0.0, 1.0, 0.0};</div>
<div class="line">    std::vector&lt;double&gt; data(num_discrete_nodes);</div>
<div class="line">    model(signal, data);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// add noise to the data, use magnitude 1 / num_discrete_nodes</span></div>
<div class="line">    <span class="comment">// you can adjust the example to consider more/less noise</span></div>
<div class="line">    <a class="code" href="group__DREAMPDF.html#gae26b853a8ef5382bbbd51bddc9688f73">TasDREAM::applyUniformUpdate</a>(data, 1.0 / ((<span class="keywordtype">double</span>) num_discrete_nodes));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// first use Gaussian likelihood: exp( - sigma * (f(x) - d)^2 )</span></div>
<div class="line">    <span class="comment">// note that the numerator uses the l-2 norm of the difference between model and data</span></div>
<div class="line">    <span class="comment">// using smaller variance since we are looking for best-fit (even with the noise)</span></div>
<div class="line">    <a class="code" href="classTasDREAM_1_1LikelihoodGaussIsotropic.html">TasDREAM::LikelihoodGaussIsotropic</a> likely(1.0 / ((<span class="keywordtype">double</span>) num_discrete_nodes/2), data);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define the search domain, each parameter is assumed to be in [0, 3]</span></div>
<div class="line">    std::vector&lt;double&gt; lower(num_dimensions, 0.0);</div>
<div class="line">    std::vector&lt;double&gt; upper(num_dimensions, 3.0);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTasDREAM_1_1TasmanianDREAM.html">TasDREAM::TasmanianDREAM</a> state(num_chains, num_dimensions);</div>
<div class="line">    <span class="keyword">auto</span> initial_chains = <a class="code" href="group__DREAMPDF.html#ga0458a26702ac73fb0026602ae3750ed4">TasDREAM::genUniformSamples</a>(lower, upper, num_chains); <span class="comment">// uniform initial state</span></div>
<div class="line">    state.setState(initial_chains);</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">auto</span> sampling_form = <a class="code" href="group__DREAMEnumerates.html#gga71a406371701ba98394a923434395ff5ad662ab51216cd8c4f7cc6a832bc63e80">TasDREAM::logform</a>; <span class="comment">// ensure uniform sampling form</span></div>
<div class="line">    TasDREAM::SampleDREAM&lt;sampling_form&gt;</div>
<div class="line">                         (num_burnup_iterations, num_sample_iterations,</div>
<div class="line">                          TasDREAM::posterior&lt;sampling_form&gt;</div>
<div class="line">                                (batch_model, <span class="comment">// must use the batch model</span></div>
<div class="line">                                 likely,      <span class="comment">// provide the likelihood</span></div>
<div class="line">                                 <a class="code" href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747">TasDREAM::uniform_prior</a>), <span class="comment">// assume non-informative prior</span></div>
<div class="line">                          <a class="code" href="group__DREAMSampleCore.html#ga51ca0fa1e74342db600bb9186fdd8158">TasDREAM::hypercube</a>(lower, upper),</div>
<div class="line">                          state,</div>
<div class="line">                          <a class="code" href="group__DREAMSampleCore.html#ga22795d18ab97c804ae7a4feec71d0da2">TasDREAM::no_update</a>,</div>
<div class="line">                          TasDREAM::const_percent&lt;100&gt; <span class="comment">// use only the differential update</span></div>
<div class="line">                          );</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;double&gt; solution = state.getApproximateMode();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//cout &lt;&lt; &quot; l-2 acceptance rate: &quot; &lt;&lt; state.getAcceptanceRate() &lt;&lt; endl;</span></div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Using Gaussian likelihood, the computed solution is:\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot; computed: &quot;</span> &lt;&lt; std::fixed;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> x : solution) cout &lt;&lt; setw(13) &lt;&lt; x;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n    error: &quot;</span> &lt;&lt; std::scientific;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_dimensions; i++) cout &lt;&lt; setw(13) &lt;&lt; std::abs(solution[i] - signal[i]);</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Change the likelihood to use the l-1 norm</span></div>
<div class="line">    <span class="comment">// Combine the model and the likelihood in a single function similar to batch_model()</span></div>
<div class="line">    <span class="comment">// The main difference is that y doesn&#39;t need to be resized</span></div>
<div class="line">    <span class="comment">// and the likelihood is applied right after the model</span></div>
<div class="line">    <span class="comment">// Note that the sampling form has to be hard-coded or captured</span></div>
<div class="line">    <span class="keyword">auto</span> model_likelihood = [&amp;](std::vector&lt;double&gt; <span class="keyword">const</span> &amp;x,</div>
<div class="line">                                std::vector&lt;double&gt; &amp;y)-&gt;</div>
<div class="line">        <span class="keywordtype">void</span>{</div>
<div class="line">            <span class="keywordtype">int</span> num_samples = (int) x.size() / num_dimensions;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// use up to 4 threads (if available)</span></div>
<div class="line">            <span class="keywordtype">int</span> num_threads = std::min((<span class="keywordtype">int</span>) std::thread::hardware_concurrency(), 4);</div>
<div class="line"> </div>
<div class="line">            std::vector&lt;std::thread&gt; workers(num_threads);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> start = 0; start&lt;num_threads; start++){</div>
<div class="line">                workers[start] = std::thread([&amp;, start]()-&gt;</div>
<div class="line">                    <span class="keywordtype">void</span>{</div>
<div class="line">                        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=start; i&lt;num_samples; i+=num_threads){</div>
<div class="line">                            std::vector&lt;double&gt; single_input(&amp;x[i*num_dimensions],</div>
<div class="line">                                                            &amp;x[i*num_dimensions] + num_dimensions);</div>
<div class="line">                            std::vector&lt;double&gt; single_output(num_discrete_nodes);</div>
<div class="line"> </div>
<div class="line">                            model(single_input, single_output);</div>
<div class="line"> </div>
<div class="line">                            y[i] = 0.0; <span class="comment">// compute the l-1 norm of the difference</span></div>
<div class="line">                            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;num_discrete_nodes; j++)</div>
<div class="line">                                y[i] += std::abs(single_output[j] - data[j]);</div>
<div class="line">                            y[i] = - double(num_discrete_nodes/2) * y[i]; <span class="comment">// apply the scale</span></div>
<div class="line"> </div>
<div class="line">                            <span class="comment">// added for completeness, only logform is used in this example</span></div>
<div class="line">                            <span class="keywordflow">if</span> (sampling_form == <a class="code" href="group__DREAMEnumerates.html#gga71a406371701ba98394a923434395ff5a72f0ea425fcdf8ac86f37c261ef9fc5a">TasDREAM::regform</a>) y[i] = std::exp(y[i]);</div>
<div class="line"> </div>
<div class="line">                        }</div>
<div class="line">                    });</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;w : workers) w.join();</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// reset the state</span></div>
<div class="line">    state = <a class="code" href="classTasDREAM_1_1TasmanianDREAM.html">TasDREAM::TasmanianDREAM</a>(num_chains, num_dimensions);</div>
<div class="line">    state.setState(initial_chains);</div>
<div class="line"> </div>
<div class="line">    TasDREAM::SampleDREAM&lt;sampling_form&gt;</div>
<div class="line">                         (num_burnup_iterations, num_sample_iterations,</div>
<div class="line">                          TasDREAM::posterior&lt;sampling_form&gt;</div>
<div class="line">                                (model_likelihood, <span class="comment">// provide both the likelihood and the model</span></div>
<div class="line">                                 <a class="code" href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747">TasDREAM::uniform_prior</a>), <span class="comment">// assume non-informative prior</span></div>
<div class="line">                          <a class="code" href="group__DREAMSampleCore.html#ga51ca0fa1e74342db600bb9186fdd8158">TasDREAM::hypercube</a>(lower, upper),</div>
<div class="line">                          state,</div>
<div class="line">                          <a class="code" href="group__DREAMSampleCore.html#ga22795d18ab97c804ae7a4feec71d0da2">TasDREAM::no_update</a>,</div>
<div class="line">                          TasDREAM::const_percent&lt;100&gt; <span class="comment">// use only the differential update</span></div>
<div class="line">                          );</div>
<div class="line"> </div>
<div class="line">    solution = state.getApproximateMode();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//cout &lt;&lt; &quot; l-1 acceptance rate: &quot; &lt;&lt; state.getAcceptanceRate() &lt;&lt; endl;</span></div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Using l-1 likelihood, the computed solution is:\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot; computed: &quot;</span> &lt;&lt; std::fixed;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> x : solution) cout &lt;&lt; setw(13) &lt;&lt; x;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n    error: &quot;</span> &lt;&lt; std::scientific;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_dimensions; i++) cout &lt;&lt; setw(13) &lt;&lt; std::abs(solution[i] - signal[i]);</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Note: the l-1 likelihood is expected to produce a slightly more accurate solution</span></div>
<div class="line">    <span class="comment">//       but the search is based on random numbers, hence this cannot be guaranteed.</span></div>
<div class="line">    <span class="comment">//       The l-1 likelihood has a much sharper mode, but that reduces the acceptance rate.</span></div>
<div class="line">    <span class="comment">//       Both likelihood methods should identify the signal components to the precision</span></div>
<div class="line">    <span class="comment">//       allowed by the relatively high signal-to-noise ratio.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef __TASMANIAN_DOXYGEN_SKIP</span></div>
<div class="ttc" id="aclassTasDREAM_1_1LikelihoodGaussIsotropic_html"><div class="ttname"><a href="classTasDREAM_1_1LikelihoodGaussIsotropic.html">TasDREAM::LikelihoodGaussIsotropic</a></div><div class="ttdoc">Implements likelihood under the assumption of isotropic white noise.</div><div class="ttdef"><b>Definition:</b> tsgDreamLikelyGaussian.hpp:59</div></div>
<div class="ttc" id="aclassTasDREAM_1_1TasmanianDREAM_html"><div class="ttname"><a href="classTasDREAM_1_1TasmanianDREAM.html">TasDREAM::TasmanianDREAM</a></div><div class="ttdoc">Contains the current state and the history of the DREAM chains.</div><div class="ttdef"><b>Definition:</b> tsgDreamState.hpp:70</div></div>
<div class="ttc" id="agroup__DREAMEnumerates_html_gga71a406371701ba98394a923434395ff5a72f0ea425fcdf8ac86f37c261ef9fc5a"><div class="ttname"><a href="group__DREAMEnumerates.html#gga71a406371701ba98394a923434395ff5a72f0ea425fcdf8ac86f37c261ef9fc5a">TasDREAM::regform</a></div><div class="ttdeci">@ regform</div><div class="ttdoc">Use the standard form for the probability density.</div><div class="ttdef"><b>Definition:</b> tsgDreamEnumerates.hpp:92</div></div>
<div class="ttc" id="agroup__DREAMEnumerates_html_gga71a406371701ba98394a923434395ff5ad662ab51216cd8c4f7cc6a832bc63e80"><div class="ttname"><a href="group__DREAMEnumerates.html#gga71a406371701ba98394a923434395ff5ad662ab51216cd8c4f7cc6a832bc63e80">TasDREAM::logform</a></div><div class="ttdeci">@ logform</div><div class="ttdoc">Use the logarithm form for the probability density.</div><div class="ttdef"><b>Definition:</b> tsgDreamEnumerates.hpp:95</div></div>
<div class="ttc" id="agroup__DREAMPDF_html_ga0458a26702ac73fb0026602ae3750ed4"><div class="ttname"><a href="group__DREAMPDF.html#ga0458a26702ac73fb0026602ae3750ed4">TasDREAM::genUniformSamples</a></div><div class="ttdeci">void genUniformSamples(const std::vector&lt; double &gt; &amp;lower, const std::vector&lt; double &gt; &amp;upper, int num_samples, std::vector&lt; double &gt; &amp;x, std::function&lt; double(void)&gt; get_random01=tsgCoreUniform01)</div><div class="ttdoc">Generate uniform random samples in the hypercube defined by lower and upper limits.</div><div class="ttdef"><b>Definition:</b> tsgDreamCoreRandom.hpp:99</div></div>
<div class="ttc" id="agroup__DREAMPDF_html_gae26b853a8ef5382bbbd51bddc9688f73"><div class="ttname"><a href="group__DREAMPDF.html#gae26b853a8ef5382bbbd51bddc9688f73">TasDREAM::applyUniformUpdate</a></div><div class="ttdeci">void applyUniformUpdate(std::vector&lt; double &gt; &amp;x, double magnitude, std::function&lt; double(void)&gt; get_random01=tsgCoreUniform01)</div><div class="ttdoc">Add a correction to every entry in x, use uniform samples over (-magnitude, magnitude).</div><div class="ttdef"><b>Definition:</b> tsgDreamCoreRandom.hpp:67</div></div>
<div class="ttc" id="agroup__DREAMSampleCore_html_ga22795d18ab97c804ae7a4feec71d0da2"><div class="ttname"><a href="group__DREAMSampleCore.html#ga22795d18ab97c804ae7a4feec71d0da2">TasDREAM::no_update</a></div><div class="ttdeci">void no_update(std::vector&lt; double &gt; &amp;)</div><div class="ttdoc">Dummy function that does not make any changes to the vector as default for the independent_update() i...</div><div class="ttdef"><b>Definition:</b> tsgDreamSample.hpp:89</div></div>
<div class="ttc" id="agroup__DREAMSampleCore_html_ga51ca0fa1e74342db600bb9186fdd8158"><div class="ttname"><a href="group__DREAMSampleCore.html#ga51ca0fa1e74342db600bb9186fdd8158">TasDREAM::hypercube</a></div><div class="ttdeci">DreamDomain hypercube(std::vector&lt; double &gt; const &amp;lower, std::vector&lt; double &gt; const &amp;upper)</div><div class="ttdoc">Make a lambda that matches the inside signature in SampleDREAM(), test if the vector x is in the hype...</div><div class="ttdef"><b>Definition:</b> tsgDreamSample.hpp:75</div></div>
<div class="ttc" id="agroup__DREAMSampleCore_html_ga7100467a4cf3a6335fff1fe5f6a5a747"><div class="ttname"><a href="group__DREAMSampleCore.html#ga7100467a4cf3a6335fff1fe5f6a5a747">TasDREAM::uniform_prior</a></div><div class="ttdeci">void uniform_prior(TypeSamplingForm, const std::vector&lt; double &gt; &amp;, std::vector&lt; double &gt; &amp;values)</div><div class="ttdoc">Uniform prior distribution for both regular and log form.</div><div class="ttdef"><b>Definition:</b> tsgDreamSample.hpp:120</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div> -->
</body>
</html>
