<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1: Tasmanian Sparse Grids module, example 7</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.1
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TasmanianSGExamples7.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tasmanian Sparse Grids module, example 7<div class="ingroups"><a class="el" href="group__TasmanianSGExamples.html">Examples for the Tasmanian Sparse Grid module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Tasmanian Sparse Grids module, example 7:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianSGExamples7.png" border="0" usemap="#agroup____TasmanianSGExamples7" alt=""/></div>
<map name="agroup____TasmanianSGExamples7" id="agroup____TasmanianSGExamples7">
<area shape="rect" href="group__TasmanianSGExamples.html" title=" " alt="" coords="5,5,193,45"/>
<area shape="rect" title=" " alt="" coords="241,5,407,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf3212f0c41c0616e26100be82d36c8d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianSGExamples7.html#gaf3212f0c41c0616e26100be82d36c8d7">sparse_grids_example_07</a> ()</td></tr>
<tr class="memdesc:gaf3212f0c41c0616e26100be82d36c8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse Grids Example 7: Global vs. Sequence grids.  <a href="group__TasmanianSGExamples7.html#gaf3212f0c41c0616e26100be82d36c8d7">More...</a><br /></td></tr>
<tr class="separator:gaf3212f0c41c0616e26100be82d36c8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Example 7</dt><dd>Benchmark Global vs. Sequence grids. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf3212f0c41c0616e26100be82d36c8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3212f0c41c0616e26100be82d36c8d7">&#9670;&nbsp;</a></span>sparse_grids_example_07()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparse_grids_example_07 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sparse Grids Example 7: Global vs. Sequence grids. </p>
<p>Sequence rules are those that form the next level by adding one point to the previous one, in Tasmanian those rules are: <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc" title="Classic sequence rule, moderate Lebesgue constant growth (empirical result only).">TasGrid::rule_leja</a>, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ae1d14fcbf34badb42266661868b53e67" title="Classic sequence rule based on complex analysis, moderate Lebesgue constant growth (theoretically pro...">TasGrid::rule_rleja</a>, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2ab25addae4849761fabd0648c409e4fe0" title="Similar sequence to rule_rleja but with nodes strictly in the interior.">TasGrid::rule_rlejashifted</a>, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2aae014e63a109512fecddb1a0b1a6443f" title="A greedy sequence rule with nodes placed at the maximum of the Lebesgue function.">TasGrid::rule_maxlebesgue</a>, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a013fec186e156860f5c89b56c18be6ca" title="A greedy sequence rule with nodes added to minimize the Lebesgue constant.">TasGrid::rule_minlebesgue</a>, <a class="el" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a4f62c63dee6ab4c61c62ea4b179bb92c" title="A greedy sequence rule with nodes added to minimize the norm of the surplus operator.">TasGrid::rule_mindelta</a>. Two implementations are provided that deal with such rules, Global grids that use the standard Lagrange polynomial interpolation and Sequence grids that use Newton polynomials. Mathematically the two implementations yield the same result (to within rounding error), but the two processes can have very different computational overhead. Sequence grids offer much faster TasmanianSparseGrid::evaluate() and TasmanianSparseGrid::evaluateBatch() algorithms, at the cost of nearly double the storage and more than double the cost of <a class="el" href="group__TasmanianAddonsLoadNeededVals.html#gad239942d20e99244061b4886f96dea4a" title="Loads the current grid with model values, does not perform any refinement.">TasmanianSparseGrid::loadNeededValues()</a>.</p>
<p>This example serves as a simple demonstration of the difference.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n---------------------------------------------------------------------------------------------------\n&quot;</span>;</div>
<div class="line">    cout &lt;&lt; std::scientific; cout.precision(4);</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Example 7: interpolate f(x_1, x_2, x_3, x_4) = exp(-x_1^2 - x_3^2) * exp(x_2) * cos(x_4)\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           using rleja rule and comparing Global and Sequence grids\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> time_start = std::chrono::system_clock::now();</div>
<div class="line">    <span class="keyword">auto</span> global = <a class="code" href="group__TasmanianSG.html#ga734013b4f52c4d1d9a35d674b459e13a">TasGrid::makeGlobalGrid</a>(4, 1, 15, <a class="code" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">TasGrid::type_iptotal</a>, <a class="code" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">TasGrid::rule_leja</a>);</div>
<div class="line">    <span class="keyword">auto</span> time_end = std::chrono::system_clock::now();</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> make_global =</div>
<div class="line">        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_end - time_start).count();</div>
<div class="line"> </div>
<div class="line">    time_start = std::chrono::system_clock::now();</div>
<div class="line">    <span class="keyword">auto</span> sequence = <a class="code" href="group__TasmanianSG.html#ga40cde16ae94c02a23271df606918cfb9">TasGrid::makeSequenceGrid</a>(4, 1, 15, <a class="code" href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">TasGrid::type_iptotal</a>, <a class="code" href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">TasGrid::rule_leja</a>);</div>
<div class="line">    time_end = std::chrono::system_clock::now();</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> make_sequence =</div>
<div class="line">        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_end - time_start).count();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// define batch model</span></div>
<div class="line">    <span class="keyword">auto</span> model = [](std::vector&lt;double&gt; <span class="keyword">const</span> &amp;points)-&gt;</div>
<div class="line">        std::vector&lt;double&gt;{</div>
<div class="line">            <span class="keywordtype">size_t</span> num_points = points.size() / 4;</div>
<div class="line">            std::vector&lt;double&gt; result(num_points);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;num_points; i++){</div>
<div class="line">                <span class="keywordtype">double</span> x1 = points[4*i];</div>
<div class="line">                <span class="keywordtype">double</span> x2 = points[4*i + 1];</div>
<div class="line">                <span class="keywordtype">double</span> x3 = points[4*i + 2];</div>
<div class="line">                <span class="keywordtype">double</span> x4 = points[4*i + 3];</div>
<div class="line">                result[i] = std::exp(-x1*x1) * std::cos(x2) * std::exp(-x3*x3) * std::cos(x4);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> result;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// load the model values into the grids</span></div>
<div class="line">    time_start = std::chrono::system_clock::now();</div>
<div class="line">    global.loadNeededValues(model(global.getNeededPoints()));</div>
<div class="line">    time_end = std::chrono::system_clock::now();</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> load_global =</div>
<div class="line">        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_end - time_start).count();</div>
<div class="line"> </div>
<div class="line">    time_start = std::chrono::system_clock::now();</div>
<div class="line">    sequence.loadNeededValues(model(sequence.getNeededPoints()));</div>
<div class="line">    time_end = std::chrono::system_clock::now();</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> load_sequence =</div>
<div class="line">        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_end - time_start).count();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the benchmark surrogate models is measure from 1000 random reference points</span></div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> num_test_points = 1000;</div>
<div class="line">    std::vector&lt;double&gt; test_points(4 * num_test_points);</div>
<div class="line">    std::minstd_rand park_miller(42);</div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; domain(-1.0, 1.0);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;t : test_points) t = domain(park_miller);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// reference points</span></div>
<div class="line">    std::vector&lt;double&gt; reference_result = model(test_points);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// get the surrogate values at the test points</span></div>
<div class="line">    time_start = std::chrono::system_clock::now();</div>
<div class="line">    std::vector&lt;double&gt; global_result;</div>
<div class="line">    global.evaluateBatch(test_points, global_result);</div>
<div class="line">    time_end = std::chrono::system_clock::now();</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> eval_global =</div>
<div class="line">        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_end - time_start).count();</div>
<div class="line"> </div>
<div class="line">    time_start = std::chrono::system_clock::now();</div>
<div class="line">    std::vector&lt;double&gt; sequence_result;</div>
<div class="line">    sequence.evaluateBatch(test_points, sequence_result);</div>
<div class="line">    time_end = std::chrono::system_clock::now();</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> eval_sequence =</div>
<div class="line">        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_end - time_start).count();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> global_error = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_test_points; i++)</div>
<div class="line">        global_error = std::max(global_error,</div>
<div class="line">                                std::abs(global_result[i] - reference_result[i]));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> sequence_error = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_test_points; i++)</div>
<div class="line">        sequence_error = std::max(sequence_error,</div>
<div class="line">                                  std::abs(sequence_result[i] - reference_result[i]));</div>
<div class="line"> </div>
<div class="line">    cout.precision(4);</div>
<div class="line">    cout &lt;&lt; std::scientific;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; Using &quot;</span> &lt;&lt; global.getNumPoints() &lt;&lt; <span class="stringliteral">&quot; points,  &quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot; Global error: &quot;</span> &lt;&lt; global_error &lt;&lt; <span class="stringliteral">&quot;,  Sequence error: &quot;</span> &lt;&lt; sequence_error &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; setw(15) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; setw(20) &lt;&lt; <span class="stringliteral">&quot;Global&quot;</span> &lt;&lt; setw(20) &lt;&lt; <span class="stringliteral">&quot;Sequence&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    cout &lt;&lt; setw(15) &lt;&lt; <span class="stringliteral">&quot;make grid&quot;</span> &lt;&lt; setw(20) &lt;&lt; make_global &lt;&lt; setw(20) &lt;&lt; make_sequence</div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;  microseconds\n&quot;</span>;</div>
<div class="line">    cout &lt;&lt; setw(15) &lt;&lt; <span class="stringliteral">&quot;load values&quot;</span> &lt;&lt; setw(20) &lt;&lt; load_global &lt;&lt; setw(20) &lt;&lt; load_sequence</div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;  microseconds\n&quot;</span>;</div>
<div class="line">    cout &lt;&lt; setw(15) &lt;&lt; <span class="stringliteral">&quot;evaluate&quot;</span> &lt;&lt; setw(20) &lt;&lt; eval_global &lt;&lt; setw(20) &lt;&lt; eval_sequence</div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;  microseconds\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef __TASMANIAN_DOXYGEN_SKIP</span></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc"><div class="ttname"><a href="group__SGEnumerates.html#gga145e27d5ae92acdd5f74149c6d4f2ca2a174e9da702f1529bc8e342ed711068fc">TasGrid::rule_leja</a></div><div class="ttdeci">@ rule_leja</div><div class="ttdoc">Classic sequence rule, moderate Lebesgue constant growth (empirical result only).</div><div class="ttdef"><b>Definition:</b> tsgEnumerates.hpp:299</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431"><div class="ttname"><a href="group__SGEnumerates.html#gga94134756077eff395566c64e6426455fa7c69365975463a61d10deed9e1d91431">TasGrid::type_iptotal</a></div><div class="ttdeci">@ type_iptotal</div><div class="ttdoc">Total degree polynomial space for interpolation, i.e., the span of   .</div><div class="ttdef"><b>Definition:</b> tsgEnumerates.hpp:221</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_ga40cde16ae94c02a23271df606918cfb9"><div class="ttname"><a href="group__TasmanianSG.html#ga40cde16ae94c02a23271df606918cfb9">TasGrid::makeSequenceGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeSequenceGrid(int dimensions, int outputs, int depth, TypeDepth type, TypeOneDRule rule, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeSequenceGrid().</div><div class="ttdef"><b>Definition:</b> TasmanianSparseGrid.hpp:2287</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_ga734013b4f52c4d1d9a35d674b459e13a"><div class="ttname"><a href="group__TasmanianSG.html#ga734013b4f52c4d1d9a35d674b459e13a">TasGrid::makeGlobalGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeGlobalGrid(int dimensions, int outputs, int depth, TypeDepth type, TypeOneDRule rule, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), double alpha=0.0, double beta=0.0, const char *custom_filename=nullptr, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeGlobalGrid().</div><div class="ttdef"><b>Definition:</b> TasmanianSparseGrid.hpp:2272</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div> -->
</body>
</html>
