<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: TasOptimization::ParticleSwarmState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classTasOptimization_1_1ParticleSwarmState.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTasOptimization_1_1ParticleSwarmState-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TasOptimization::ParticleSwarmState Class Reference<div class="ingroups"><a class="el" href="group__TasmanianOptimization.html">Optimization</a> &raquo; <a class="el" href="group__OptimizationState.html">Optimization States</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Stores the information about a particle swarm.  
 <a href="classTasOptimization_1_1ParticleSwarmState.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tsgParticleSwarm_8hpp_source.html">tsgParticleSwarm.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af4deaeba8579e344db792948e315fcb6" id="r_af4deaeba8579e344db792948e315fcb6"><td class="memItemLeft" align="right" valign="top"><a id="af4deaeba8579e344db792948e315fcb6" name="af4deaeba8579e344db792948e315fcb6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleSwarmState</b> ()=delete</td></tr>
<tr class="memdesc:af4deaeba8579e344db792948e315fcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The particle swarm state must be initialized with data that defines number of particles and dimensions. <br /></td></tr>
<tr class="separator:af4deaeba8579e344db792948e315fcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f60e44c096604d03ca9870456b27b0" id="r_a72f60e44c096604d03ca9870456b27b0"><td class="memItemLeft" align="right" valign="top"><a id="a72f60e44c096604d03ca9870456b27b0" name="a72f60e44c096604d03ca9870456b27b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleSwarmState</b> (const int num_dimensions, const int num_particles)</td></tr>
<tr class="memdesc:a72f60e44c096604d03ca9870456b27b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a particle swarm state with the number of particles and dimensions. <br /></td></tr>
<tr class="separator:a72f60e44c096604d03ca9870456b27b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7d5f6ed62ce32fc29c6e111dd6f2f8" id="r_ace7d5f6ed62ce32fc29c6e111dd6f2f8"><td class="memItemLeft" align="right" valign="top"><a id="ace7d5f6ed62ce32fc29c6e111dd6f2f8" name="ace7d5f6ed62ce32fc29c6e111dd6f2f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleSwarmState</b> (const int num_dimensions, std::vector&lt; double &gt; &amp;&amp;pp, std::vector&lt; double &gt; &amp;&amp;pv)</td></tr>
<tr class="memdesc:ace7d5f6ed62ce32fc29c6e111dd6f2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a particle swarm state with the number of dimensions and the number of particles inferred from a set of input particle positions <b>pp</b> and a set of input particle velocities <b>pv</b>. <br /></td></tr>
<tr class="separator:ace7d5f6ed62ce32fc29c6e111dd6f2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdf7d02ef8ce9930aab6df1673e4ff5" id="r_a2bdf7d02ef8ce9930aab6df1673e4ff5"><td class="memItemLeft" align="right" valign="top"><a id="a2bdf7d02ef8ce9930aab6df1673e4ff5" name="a2bdf7d02ef8ce9930aab6df1673e4ff5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleSwarmState</b> (const <a class="el" href="classTasOptimization_1_1ParticleSwarmState.html">ParticleSwarmState</a> &amp;source)=default</td></tr>
<tr class="memdesc:a2bdf7d02ef8ce9930aab6df1673e4ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a2bdf7d02ef8ce9930aab6df1673e4ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281cb793150d946326ad25cb1d41f92" id="r_a2281cb793150d946326ad25cb1d41f92"><td class="memItemLeft" align="right" valign="top"><a id="a2281cb793150d946326ad25cb1d41f92" name="a2281cb793150d946326ad25cb1d41f92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleSwarmState</b> (<a class="el" href="classTasOptimization_1_1ParticleSwarmState.html">ParticleSwarmState</a> &amp;&amp;source)=default</td></tr>
<tr class="memdesc:a2281cb793150d946326ad25cb1d41f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a2281cb793150d946326ad25cb1d41f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688673ebc2df15ba0a235a6c867d5a5c" id="r_a688673ebc2df15ba0a235a6c867d5a5c"><td class="memItemLeft" align="right" valign="top"><a id="a688673ebc2df15ba0a235a6c867d5a5c" name="a688673ebc2df15ba0a235a6c867d5a5c"></a>
<a class="el" href="classTasOptimization_1_1ParticleSwarmState.html">ParticleSwarmState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classTasOptimization_1_1ParticleSwarmState.html">ParticleSwarmState</a> &amp;&amp;source)=default</td></tr>
<tr class="memdesc:a688673ebc2df15ba0a235a6c867d5a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a688673ebc2df15ba0a235a6c867d5a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d7a2c03cb1575d3001b93d610b44cb" id="r_a41d7a2c03cb1575d3001b93d610b44cb"><td class="memItemLeft" align="right" valign="top"><a id="a41d7a2c03cb1575d3001b93d610b44cb" name="a41d7a2c03cb1575d3001b93d610b44cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumDimensions</b> () const</td></tr>
<tr class="memdesc:a41d7a2c03cb1575d3001b93d610b44cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of dimensions. <br /></td></tr>
<tr class="separator:a41d7a2c03cb1575d3001b93d610b44cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1487994aa2f047532fc5f571f8a1bd32" id="r_a1487994aa2f047532fc5f571f8a1bd32"><td class="memItemLeft" align="right" valign="top"><a id="a1487994aa2f047532fc5f571f8a1bd32" name="a1487994aa2f047532fc5f571f8a1bd32"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumParticles</b> () const</td></tr>
<tr class="memdesc:a1487994aa2f047532fc5f571f8a1bd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of particles. <br /></td></tr>
<tr class="separator:a1487994aa2f047532fc5f571f8a1bd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91a21112d4869a357e10d9f78171a7a" id="r_ac91a21112d4869a357e10d9f78171a7a"><td class="memItemLeft" align="right" valign="top"><a id="ac91a21112d4869a357e10d9f78171a7a" name="ac91a21112d4869a357e10d9f78171a7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getParticlePositions</b> (double pp[]) const</td></tr>
<tr class="memdesc:ac91a21112d4869a357e10d9f78171a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the particle positions. <br /></td></tr>
<tr class="separator:ac91a21112d4869a357e10d9f78171a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab512006b9ec10acf00bbd4f87e4d074b" id="r_ab512006b9ec10acf00bbd4f87e4d074b"><td class="memItemLeft" align="right" valign="top"><a id="ab512006b9ec10acf00bbd4f87e4d074b" name="ab512006b9ec10acf00bbd4f87e4d074b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getParticlePositions</b> () const</td></tr>
<tr class="memdesc:ab512006b9ec10acf00bbd4f87e4d074b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the particle positions, vector overload. <br /></td></tr>
<tr class="separator:ab512006b9ec10acf00bbd4f87e4d074b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf47cd22988f252c9fbdb1bb072424d9" id="r_acf47cd22988f252c9fbdb1bb072424d9"><td class="memItemLeft" align="right" valign="top"><a id="acf47cd22988f252c9fbdb1bb072424d9" name="acf47cd22988f252c9fbdb1bb072424d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getParticleVelocities</b> (double pv[]) const</td></tr>
<tr class="memdesc:acf47cd22988f252c9fbdb1bb072424d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the particle velocities. <br /></td></tr>
<tr class="separator:acf47cd22988f252c9fbdb1bb072424d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d9aabb62cb5194ab6ac90480a94a7a" id="r_a32d9aabb62cb5194ab6ac90480a94a7a"><td class="memItemLeft" align="right" valign="top"><a id="a32d9aabb62cb5194ab6ac90480a94a7a" name="a32d9aabb62cb5194ab6ac90480a94a7a"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getParticleVelocities</b> () const</td></tr>
<tr class="memdesc:a32d9aabb62cb5194ab6ac90480a94a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the particle velocities, vector overload. <br /></td></tr>
<tr class="separator:a32d9aabb62cb5194ab6ac90480a94a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11953a2eb49d055d1914e84e82c57a0e" id="r_a11953a2eb49d055d1914e84e82c57a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a11953a2eb49d055d1914e84e82c57a0e">getBestParticlePositions</a> (double bpp[]) const</td></tr>
<tr class="memdesc:a11953a2eb49d055d1914e84e82c57a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the best known particle positions.  <br /></td></tr>
<tr class="separator:a11953a2eb49d055d1914e84e82c57a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d70ff1cc97e7cffeaf163d7aedf883" id="r_a94d70ff1cc97e7cffeaf163d7aedf883"><td class="memItemLeft" align="right" valign="top"><a id="a94d70ff1cc97e7cffeaf163d7aedf883" name="a94d70ff1cc97e7cffeaf163d7aedf883"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBestParticlePositions</b> () const</td></tr>
<tr class="memdesc:a94d70ff1cc97e7cffeaf163d7aedf883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the best known particle positions, vector overload. <br /></td></tr>
<tr class="separator:a94d70ff1cc97e7cffeaf163d7aedf883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a79f96dfc5404f8e5e7624bb62cf12" id="r_a40a79f96dfc5404f8e5e7624bb62cf12"><td class="memItemLeft" align="right" valign="top"><a id="a40a79f96dfc5404f8e5e7624bb62cf12" name="a40a79f96dfc5404f8e5e7624bb62cf12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getBestPosition</b> (double bp[]) const</td></tr>
<tr class="memdesc:a40a79f96dfc5404f8e5e7624bb62cf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the best known position in the swarm. <br /></td></tr>
<tr class="separator:a40a79f96dfc5404f8e5e7624bb62cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300ca4d85ed612180d2a4b071622d142" id="r_a300ca4d85ed612180d2a4b071622d142"><td class="memItemLeft" align="right" valign="top"><a id="a300ca4d85ed612180d2a4b071622d142" name="a300ca4d85ed612180d2a4b071622d142"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBestPosition</b> () const</td></tr>
<tr class="memdesc:a300ca4d85ed612180d2a4b071622d142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best knows position in the swarm. <br /></td></tr>
<tr class="separator:a300ca4d85ed612180d2a4b071622d142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88cc62d1b332f9b20e20686340d7cc6" id="r_ae88cc62d1b332f9b20e20686340d7cc6"><td class="memItemLeft" align="right" valign="top"><a id="ae88cc62d1b332f9b20e20686340d7cc6" name="ae88cc62d1b332f9b20e20686340d7cc6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPositionInitialized</b> () const</td></tr>
<tr class="memdesc:ae88cc62d1b332f9b20e20686340d7cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the particle positions have been initialized. <br /></td></tr>
<tr class="separator:ae88cc62d1b332f9b20e20686340d7cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54490f4a1ded3f22b1079ef9c7548f3c" id="r_a54490f4a1ded3f22b1079ef9c7548f3c"><td class="memItemLeft" align="right" valign="top"><a id="a54490f4a1ded3f22b1079ef9c7548f3c" name="a54490f4a1ded3f22b1079ef9c7548f3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isVelocityInitialized</b> () const</td></tr>
<tr class="memdesc:a54490f4a1ded3f22b1079ef9c7548f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the particle velocities have been initialized. <br /></td></tr>
<tr class="separator:a54490f4a1ded3f22b1079ef9c7548f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dbe71a1d214b9e92415cab4d4cb8bf" id="r_a66dbe71a1d214b9e92415cab4d4cb8bf"><td class="memItemLeft" align="right" valign="top"><a id="a66dbe71a1d214b9e92415cab4d4cb8bf" name="a66dbe71a1d214b9e92415cab4d4cb8bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBestPositionInitialized</b> () const</td></tr>
<tr class="memdesc:a66dbe71a1d214b9e92415cab4d4cb8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the best particle positions have been initialized. <br /></td></tr>
<tr class="separator:a66dbe71a1d214b9e92415cab4d4cb8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b913a2586ef2fe8c012969d23a4144" id="r_a07b913a2586ef2fe8c012969d23a4144"><td class="memItemLeft" align="right" valign="top"><a id="a07b913a2586ef2fe8c012969d23a4144" name="a07b913a2586ef2fe8c012969d23a4144"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isCacheInitialized</b> () const</td></tr>
<tr class="memdesc:a07b913a2586ef2fe8c012969d23a4144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the cache has been initialized. <br /></td></tr>
<tr class="separator:a07b913a2586ef2fe8c012969d23a4144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986209c892ad787b408b72a8974636c6" id="r_a986209c892ad787b408b72a8974636c6"><td class="memItemLeft" align="right" valign="top"><a id="a986209c892ad787b408b72a8974636c6" name="a986209c892ad787b408b72a8974636c6"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getStateVector</b> () const</td></tr>
<tr class="memdesc:a986209c892ad787b408b72a8974636c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complete state vector. <br /></td></tr>
<tr class="separator:a986209c892ad787b408b72a8974636c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df0a1501ac809fd347a81985572f1ea" id="r_a2df0a1501ac809fd347a81985572f1ea"><td class="memItemLeft" align="right" valign="top"><a id="a2df0a1501ac809fd347a81985572f1ea" name="a2df0a1501ac809fd347a81985572f1ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setParticlePositions</b> (const double pp[])</td></tr>
<tr class="memdesc:a2df0a1501ac809fd347a81985572f1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the particle positions, raw-array variant. <br /></td></tr>
<tr class="separator:a2df0a1501ac809fd347a81985572f1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c62b1755c36a1177bb6cf423845326" id="r_af8c62b1755c36a1177bb6cf423845326"><td class="memItemLeft" align="right" valign="top"><a id="af8c62b1755c36a1177bb6cf423845326" name="af8c62b1755c36a1177bb6cf423845326"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setParticlePositions</b> (const std::vector&lt; double &gt; &amp;pp)</td></tr>
<tr class="memdesc:af8c62b1755c36a1177bb6cf423845326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the particle positions, vector variant. <br /></td></tr>
<tr class="separator:af8c62b1755c36a1177bb6cf423845326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b49c4fd43eb64bdc3282879f9261e51" id="r_a5b49c4fd43eb64bdc3282879f9261e51"><td class="memItemLeft" align="right" valign="top"><a id="a5b49c4fd43eb64bdc3282879f9261e51" name="a5b49c4fd43eb64bdc3282879f9261e51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setParticlePositions</b> (std::vector&lt; double &gt; &amp;&amp;pp)</td></tr>
<tr class="memdesc:a5b49c4fd43eb64bdc3282879f9261e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the particle positions, with a move. <br /></td></tr>
<tr class="separator:a5b49c4fd43eb64bdc3282879f9261e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e8c2425b1b4526dae81104ce7c540a" id="r_ac6e8c2425b1b4526dae81104ce7c540a"><td class="memItemLeft" align="right" valign="top"><a id="ac6e8c2425b1b4526dae81104ce7c540a" name="ac6e8c2425b1b4526dae81104ce7c540a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setParticleVelocities</b> (const double pv[])</td></tr>
<tr class="memdesc:ac6e8c2425b1b4526dae81104ce7c540a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the particle velocities. <br /></td></tr>
<tr class="separator:ac6e8c2425b1b4526dae81104ce7c540a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea63426f6c92cbe66e7a9944ed89e66" id="r_a6ea63426f6c92cbe66e7a9944ed89e66"><td class="memItemLeft" align="right" valign="top"><a id="a6ea63426f6c92cbe66e7a9944ed89e66" name="a6ea63426f6c92cbe66e7a9944ed89e66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setParticleVelocities</b> (const std::vector&lt; double &gt; &amp;pv)</td></tr>
<tr class="memdesc:a6ea63426f6c92cbe66e7a9944ed89e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the best position. <br /></td></tr>
<tr class="separator:a6ea63426f6c92cbe66e7a9944ed89e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff3d453f5165d8ad240ce3c0c58e856" id="r_a3ff3d453f5165d8ad240ce3c0c58e856"><td class="memItemLeft" align="right" valign="top"><a id="a3ff3d453f5165d8ad240ce3c0c58e856" name="a3ff3d453f5165d8ad240ce3c0c58e856"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setParticleVelocities</b> (std::vector&lt; double &gt; &amp;&amp;pv)</td></tr>
<tr class="memdesc:a3ff3d453f5165d8ad240ce3c0c58e856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the best position, with a move. <br /></td></tr>
<tr class="separator:a3ff3d453f5165d8ad240ce3c0c58e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88908020646cd759ae6d10d9c996b9ce" id="r_a88908020646cd759ae6d10d9c996b9ce"><td class="memItemLeft" align="right" valign="top"><a id="a88908020646cd759ae6d10d9c996b9ce" name="a88908020646cd759ae6d10d9c996b9ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBestParticlePositions</b> (const double bpp[])</td></tr>
<tr class="memdesc:a88908020646cd759ae6d10d9c996b9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the previously best known particle velocities. <br /></td></tr>
<tr class="separator:a88908020646cd759ae6d10d9c996b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fff9a4cb8f3a175db7b816fc9fb818" id="r_a72fff9a4cb8f3a175db7b816fc9fb818"><td class="memItemLeft" align="right" valign="top"><a id="a72fff9a4cb8f3a175db7b816fc9fb818" name="a72fff9a4cb8f3a175db7b816fc9fb818"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBestParticlePositions</b> (const std::vector&lt; double &gt; &amp;bpp)</td></tr>
<tr class="memdesc:a72fff9a4cb8f3a175db7b816fc9fb818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the best position per particle. <br /></td></tr>
<tr class="separator:a72fff9a4cb8f3a175db7b816fc9fb818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fb27f1ced843df326a3f754775be90" id="r_a74fb27f1ced843df326a3f754775be90"><td class="memItemLeft" align="right" valign="top"><a id="a74fb27f1ced843df326a3f754775be90" name="a74fb27f1ced843df326a3f754775be90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBestParticlePositions</b> (std::vector&lt; double &gt; &amp;&amp;bpp)</td></tr>
<tr class="memdesc:a74fb27f1ced843df326a3f754775be90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the best position per particle, allows for a move. <br /></td></tr>
<tr class="separator:a74fb27f1ced843df326a3f754775be90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4440ee6fab2d62bbcbce864ece6ac932" id="r_a4440ee6fab2d62bbcbce864ece6ac932"><td class="memItemLeft" align="right" valign="top"><a id="a4440ee6fab2d62bbcbce864ece6ac932" name="a4440ee6fab2d62bbcbce864ece6ac932"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearBestParticles</b> ()</td></tr>
<tr class="memdesc:a4440ee6fab2d62bbcbce864ece6ac932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the previously best known particle velocities. <br /></td></tr>
<tr class="separator:a4440ee6fab2d62bbcbce864ece6ac932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cdfc304c8ad42d2fffa1bd32a714d5" id="r_a50cdfc304c8ad42d2fffa1bd32a714d5"><td class="memItemLeft" align="right" valign="top"><a id="a50cdfc304c8ad42d2fffa1bd32a714d5" name="a50cdfc304c8ad42d2fffa1bd32a714d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearCache</b> ()</td></tr>
<tr class="memdesc:a50cdfc304c8ad42d2fffa1bd32a714d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the particle swarm cache. <br /></td></tr>
<tr class="separator:a50cdfc304c8ad42d2fffa1bd32a714d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8b646d046631e0ec141516da18837d" id="r_a1e8b646d046631e0ec141516da18837d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a1e8b646d046631e0ec141516da18837d">initializeParticlesInsideBox</a> (const double box_lower[], const double box_upper[], const std::function&lt; double(void)&gt; get_random01=<a class="el" href="namespaceTasDREAM.html#a7bd06b0f18e539d527de0951594e75a7">TasDREAM::tsgCoreUniform01</a>)</td></tr>
<tr class="memdesc:a1e8b646d046631e0ec141516da18837d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly initializes all of the particle positions and velocities inside of a box.  <br /></td></tr>
<tr class="separator:a1e8b646d046631e0ec141516da18837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51ba4e1b4bb41b9854bb292c267f2a8" id="r_ac51ba4e1b4bb41b9854bb292c267f2a8"><td class="memItemLeft" align="right" valign="top"><a id="ac51ba4e1b4bb41b9854bb292c267f2a8" name="ac51ba4e1b4bb41b9854bb292c267f2a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initializeParticlesInsideBox</b> (const std::vector&lt; double &gt; &amp;box_lower, const std::vector&lt; double &gt; &amp;box_upper, const std::function&lt; double(void)&gt; get_random01=<a class="el" href="namespaceTasDREAM.html#a7bd06b0f18e539d527de0951594e75a7">TasDREAM::tsgCoreUniform01</a>)</td></tr>
<tr class="memdesc:ac51ba4e1b4bb41b9854bb292c267f2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly initializes all of the particles, vector API overload. <br /></td></tr>
<tr class="separator:ac51ba4e1b4bb41b9854bb292c267f2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9f7c168dbeabf07bbb934f959b68035b" id="r_a9f7c168dbeabf07bbb934f959b68035b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a9f7c168dbeabf07bbb934f959b68035b">ParticleSwarm</a> (const <a class="el" href="group__OptimizationUtil.html#gaec31d033396fbbfdce0b5c54950b0074">ObjectiveFunction</a> f, const <a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">TasDREAM::DreamDomain</a> inside, const double inertia_weight, const double cognitive_coeff, const double social_coeff, const int num_iterations, <a class="el" href="classTasOptimization_1_1ParticleSwarmState.html">ParticleSwarmState</a> &amp;state, const std::function&lt; double(void)&gt; get_random01)</td></tr>
<tr class="memdesc:a9f7c168dbeabf07bbb934f959b68035b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the classic particle swarm algorithm to a particle swarm state.  <br /></td></tr>
<tr class="separator:a9f7c168dbeabf07bbb934f959b68035b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores the information about a particle swarm. </p>
<dl class="section user"><dt>class ParticleSwarmState</dt><dd>A state class associated with the Particle Swarm State algorithm.</dd></dl>
<dl class="section user"><dt>Constructors and Copy/Move assignment</dt><dd>All constructors requires the number of dimensions and particles, those <b>cannot</b> be modified but can be retrieved by get methods. The class is movable and copyable by constructor or operator=.<ul>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#af4deaeba8579e344db792948e315fcb6" title="The particle swarm state must be initialized with data that defines number of particles and dimension...">ParticleSwarmState()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a41d7a2c03cb1575d3001b93d610b44cb" title="Return the number of dimensions.">getNumDimensions()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a1487994aa2f047532fc5f571f8a1bd32" title="Return the number of particles.">getNumParticles()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Data layout</dt><dd>The logical organization of the particle data follows conventions similar to the Sparse Grid module. Namely, the data is organized into strips of size <b>num_dimensions</b> and there is one strip for each particle. Each particle has several vectors: position, best-known position and velocity; as well as cached values for the objective functional at the position and best-position.</dd></dl>
<dl class="section user"><dt>Set and Get Particle Positions and Velocities</dt><dd>Each particle of the swarm is associated with a (possibly empty) position and velocity vector. Methods are also available to determine if the positions and velocities are empty (uninitialized) or non-empty (initialized).<ul>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#ac91a21112d4869a357e10d9f78171a7a" title="Return the particle positions.">getParticlePositions()</a>, <a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a2df0a1501ac809fd347a81985572f1ea" title="Set the particle positions, raw-array variant.">setParticlePositions()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#acf47cd22988f252c9fbdb1bb072424d9" title="Return the particle velocities.">getParticleVelocities()</a>, <a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#ac6e8c2425b1b4526dae81104ce7c540a" title="Set the particle velocities.">setParticleVelocities()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#ae88cc62d1b332f9b20e20686340d7cc6" title="Returns true if the particle positions have been initialized.">isPositionInitialized()</a>, <a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a54490f4a1ded3f22b1079ef9c7548f3c" title="Returns true if the particle velocities have been initialized.">isVelocityInitialized()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Set and Get Best Particle Positions</dt><dd>A <b>best</b> known position will be assigned to each particle during the execution of the algorithm. The <b>best</b> know position for the entire swarm is also available and it is the current "solution", i.e., the point with smallest observed functional.<ul>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a40a79f96dfc5404f8e5e7624bb62cf12" title="Loads the best known position in the swarm.">getBestPosition()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a11953a2eb49d055d1914e84e82c57a0e" title="Return the best known particle positions.">getBestParticlePositions()</a>, <a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a88908020646cd759ae6d10d9c996b9ce" title="Set the previously best known particle velocities.">setBestParticlePositions()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a4440ee6fab2d62bbcbce864ece6ac932" title="Clear the previously best known particle velocities.">clearBestParticles()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a66dbe71a1d214b9e92415cab4d4cb8bf" title="Returns true if the best particle positions have been initialized.">isBestPositionInitialized()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Initializing a Random Swarm</dt><dd>Helper methods are available for initializing random particle positions and velocities.<ul>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a1e8b646d046631e0ec141516da18837d" title="Randomly initializes all of the particle positions and velocities inside of a box.">initializeParticlesInsideBox()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a66dbe71a1d214b9e92415cab4d4cb8bf" title="Returns true if the best particle positions have been initialized.">isBestPositionInitialized()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Particle Swarm Algorithm</dt><dd>If all of particles of the swarm are initialized with velocities and positions, then the particle swarm optimization algorithm can be used on the swarm with the goal of minimizing a particular objective function. The best point, with respect to the given objective function, can be obtained from the swarm using the <a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a40a79f96dfc5404f8e5e7624bb62cf12" title="Loads the best known position in the swarm.">getBestPosition()</a> method.<ul>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a9f7c168dbeabf07bbb934f959b68035b" title="Applies the classic particle swarm algorithm to a particle swarm state.">ParticleSwarm()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>More information about the particle swarm algorithm can be found in the following paper:</dd></dl>
<dl class="section user"><dt></dt><dd><blockquote class="doxtable">
<p>&zwj;M. R. Bonyadi and Z. Michalewicz, "Particle Swarm Optimization for Single Objective Continuous Space Problems: A Review," in <em>Evolutionary Computation</em>, vol. 25, no. 1, pp. 1-54, March 2017, doi: 10.1162/EVCO_r_00180. </p>
</blockquote>
</dd></dl>
<dl class="section user"><dt>Clearing the Cache</dt><dd>After an optimization method is applied to the swarm, certain data related to the objective function are stored in cache variables inside this class. If an optimization method needs to be applied to the swarm with a different objective function than the one used to generate the cache, the cache <b>must</b> be cleared.<ul>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a50cdfc304c8ad42d2fffa1bd32a714d5" title="Clear the particle swarm cache.">clearCache()</a></li>
<li><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html#a07b913a2586ef2fe8c012969d23a4144" title="Returns true if the cache has been initialized.">isCacheInitialized()</a> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a11953a2eb49d055d1914e84e82c57a0e" name="a11953a2eb49d055d1914e84e82c57a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11953a2eb49d055d1914e84e82c57a0e">&#9670;&#160;</a></span>getBestParticlePositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasOptimization::ParticleSwarmState::getBestParticlePositions </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bpp</em>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the best known particle positions. </p>
<p>The method actually returns positions with one more than the total number of particles, the last <b>num_dimensions</b> entries of this vector contain the best particle position of the entire swarm. </p>

</div>
</div>
<a id="a1e8b646d046631e0ec141516da18837d" name="a1e8b646d046631e0ec141516da18837d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8b646d046631e0ec141516da18837d">&#9670;&#160;</a></span>initializeParticlesInsideBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasOptimization::ParticleSwarmState::initializeParticlesInsideBox </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_lower</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>box_upper</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(void)&gt;&#160;</td>
          <td class="paramname"><em>get_random01</em> = <code><a class="el" href="namespaceTasDREAM.html#a7bd06b0f18e539d527de0951594e75a7">TasDREAM::tsgCoreUniform01</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly initializes all of the particle positions and velocities inside of a box. </p>
<p>The i-th component of each particle's position is uniformly sampled from the interval [<b>box_lower</b>[i], <b>box_upper</b>[i]]. The i-th velocity of each particle's velocity is uniformly sampled from the interval [-R, R] where R = abs(<b>box_upper</b>[i] - <b>box_lower</b>[i]). The uniform [0,1] random number generator used in the sampling is specified by <b>get_random01</b>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a9f7c168dbeabf07bbb934f959b68035b" name="a9f7c168dbeabf07bbb934f959b68035b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7c168dbeabf07bbb934f959b68035b">&#9670;&#160;</a></span>ParticleSwarm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParticleSwarm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__OptimizationUtil.html#gaec31d033396fbbfdce0b5c54950b0074">ObjectiveFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DREAMSampleCore.html#gafeb68ea720f1eaaf79fa2e02422d760f">TasDREAM::DreamDomain</a>&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>inertia_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cognitive_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>social_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html">ParticleSwarmState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(void)&gt;&#160;</td>
          <td class="paramname"><em>get_random01</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the classic particle swarm algorithm to a particle swarm state. </p>
<p>Runs <b>num_iterations</b> of the particle swarm algorithm to a particle swarm <b>state</b> to minimize the function <b>f</b> over the domain <b>inside</b>. The parameters of the algorithm are <b>inertia_weight</b> , <b>cognitive_coeff</b> , and <b>social_coeff</b>. The uniform [0,1] random number generator used by the algorithm is <b>get_random01</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Objective function to be minimized </td></tr>
    <tr><td class="paramname">inside</td><td>indicates whether a given point is inside or outside of the domain of interest </td></tr>
    <tr><td class="paramname">inertia_weight</td><td>inertial weight for the particle swarm algorithm </td></tr>
    <tr><td class="paramname">cognitive_coeff</td><td>cognitive coefficient for the particle swarm algorithm </td></tr>
    <tr><td class="paramname">social_coeff</td><td>social coefficient for the particle swarm algorithm </td></tr>
    <tr><td class="paramname">num_iterations</td><td>number of iterations to perform </td></tr>
    <tr><td class="paramname">state</td><td>holds the state of the particles, e.g., positions and velocities, see <a class="el" href="classTasOptimization_1_1ParticleSwarmState.html" title="Stores the information about a particle swarm.">TasOptimization::ParticleSwarmState</a> </td></tr>
    <tr><td class="paramname">get_random01</td><td>random number generator, defaults to rand()</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if either the positions or the velocities of the <b>state</b> have not been initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>DREAM/Optimization/<a class="el" href="tsgParticleSwarm_8hpp_source.html">tsgParticleSwarm.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="navelem"><a class="el" href="namespaceTasOptimization.html">TasOptimization</a></li><li class="navelem"><a class="el" href="classTasOptimization_1_1ParticleSwarmState.html">ParticleSwarmState</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
