<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2: Automated Surrogate Construction Procedure</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.8
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.2
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TasmanianAddonsConstruct.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Automated Surrogate Construction Procedure<div class="ingroups"><a class="el" href="group__TasmanianAddons.html">Additional Capabilities</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Automated Surrogate Construction Procedure:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianAddonsConstruct.png" border="0" usemap="#agroup____TasmanianAddonsConstruct" alt=""/></div>
<map name="agroup____TasmanianAddonsConstruct" id="agroup____TasmanianAddonsConstruct">
<area shape="rect" href="group__TasmanianAddons.html" title=" " alt="" coords="5,13,156,38"/>
<area shape="rect" title=" " alt="" coords="204,5,367,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga18daa9a18e54407f6dfd5909274de6c9" id="r_ga18daa9a18e54407f6dfd5909274de6c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">TasGrid::ModelSignature</a> = std::function&lt; void(std::vector&lt; double &gt; const &amp;x, std::vector&lt; double &gt; &amp;y, size_t thread_id)&gt;</td></tr>
<tr class="memdesc:ga18daa9a18e54407f6dfd5909274de6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of a model function to be used in the construction procedures.  <br /></td></tr>
<tr class="separator:ga18daa9a18e54407f6dfd5909274de6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga868eb3d17df0eefb438376c92002b8de" id="r_ga868eb3d17df0eefb438376c92002b8de"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga868eb3d17df0eefb438376c92002b8de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de">TasGrid::constructSurrogate</a> (<a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a> model, size_t max_num_points, size_t num_parallel_jobs, size_t max_samples_per_job, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, double tolerance, <a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a> criteria, int output=-1, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:ga868eb3d17df0eefb438376c92002b8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda.  <br /></td></tr>
<tr class="separator:ga868eb3d17df0eefb438376c92002b8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0788f48fb2593d686d3b2173f5821f0" id="r_gac0788f48fb2593d686d3b2173f5821f0"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:gac0788f48fb2593d686d3b2173f5821f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#gac0788f48fb2593d686d3b2173f5821f0">TasGrid::constructSurrogate</a> (<a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a> model, size_t max_num_points, size_t num_parallel_jobs, size_t max_samples_per_job, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, std::vector&lt; int &gt; const &amp;anisotropic_weights=std::vector&lt; int &gt;(), std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:gac0788f48fb2593d686d3b2173f5821f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda.  <br /></td></tr>
<tr class="separator:gac0788f48fb2593d686d3b2173f5821f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ed57c25a9f903ce06604091bd1fe500" id="r_ga4ed57c25a9f903ce06604091bd1fe500"><td class="memTemplParams" colspan="2">template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </td></tr>
<tr class="memitem:ga4ed57c25a9f903ce06604091bd1fe500"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAddonsConstruct.html#ga4ed57c25a9f903ce06604091bd1fe500">TasGrid::constructSurrogate</a> (<a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a> model, size_t max_num_points, size_t num_parallel_jobs, size_t max_samples_per_job, <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;grid, <a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a> type, int output, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</td></tr>
<tr class="memdesc:ga4ed57c25a9f903ce06604091bd1fe500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse grid surrogate to the model defined by the lambda.  <br /></td></tr>
<tr class="separator:ga4ed57c25a9f903ce06604091bd1fe500"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3c8066806409c50730ab7c7843643912" id="r_ga3c8066806409c50730ab7c7843643912"><td class="memItemLeft" align="right" valign="top"><a id="ga3c8066806409c50730ab7c7843643912" name="ga3c8066806409c50730ab7c7843643912"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>TasGrid::mode_parallel</b> = true</td></tr>
<tr class="memdesc:ga3c8066806409c50730ab7c7843643912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. <br /></td></tr>
<tr class="separator:ga3c8066806409c50730ab7c7843643912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3bad3a625ef67b3daacad075f9ef730" id="r_gab3bad3a625ef67b3daacad075f9ef730"><td class="memItemLeft" align="right" valign="top"><a id="gab3bad3a625ef67b3daacad075f9ef730" name="gab3bad3a625ef67b3daacad075f9ef730"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>TasGrid::mode_sequential</b> = false</td></tr>
<tr class="memdesc:gab3bad3a625ef67b3daacad075f9ef730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. <br /></td></tr>
<tr class="separator:gab3bad3a625ef67b3daacad075f9ef730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59a05cea9ff38590c1c81e3c05a06dc2" id="r_ga59a05cea9ff38590c1c81e3c05a06dc2"><td class="memItemLeft" align="right" valign="top"><a id="ga59a05cea9ff38590c1c81e3c05a06dc2" name="ga59a05cea9ff38590c1c81e3c05a06dc2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>TasGrid::with_initial_guess</b> = true</td></tr>
<tr class="memdesc:ga59a05cea9ff38590c1c81e3c05a06dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. <br /></td></tr>
<tr class="separator:ga59a05cea9ff38590c1c81e3c05a06dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24a8f8d52cd2c6fb54f6f21c4389a7f" id="r_gae24a8f8d52cd2c6fb54f6f21c4389a7f"><td class="memItemLeft" align="right" valign="top"><a id="gae24a8f8d52cd2c6fb54f6f21c4389a7f" name="gae24a8f8d52cd2c6fb54f6f21c4389a7f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>TasGrid::no_initial_guess</b> = false</td></tr>
<tr class="memdesc:gae24a8f8d52cd2c6fb54f6f21c4389a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>. <br /></td></tr>
<tr class="separator:gae24a8f8d52cd2c6fb54f6f21c4389a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Templates that perform an automated surrogate construction to a model defined by a lambda expression. This allows for a one-click (or one function call) grid construction where the samples can be computed either sequentially or in parallel. The procedure is carried out until either a target accuracy is reached or a computational budget is exhausted. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga18daa9a18e54407f6dfd5909274de6c9" name="ga18daa9a18e54407f6dfd5909274de6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18daa9a18e54407f6dfd5909274de6c9">&#9670;&#160;</a></span>ModelSignature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">TasGrid::ModelSignature</a> = typedef std::function&lt;void(std::vector&lt;double&gt; const &amp;x, std::vector&lt;double&gt; &amp;y, size_t thread_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature of a model function to be used in the construction procedures. </p>
<p>This types describes an abstract model with inputs, outputs and a specific thread-id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the model inputs, the vector is logically organized in strips each containing a set of model inputs. </td></tr>
    <tr><td class="paramname">y</td><td>is the model outputs, the vector must be logically organized in strips each containing a set of model outputs corresponding to a set of inputs (the order must match, first set of inputs to first set outputs and so on). In most cases, <b>y</b> will have the correct size before the call, the exception is when there is insufficient data to compute an initial guess in a context that asks for an initial guess, then <b>y</b> will be empty and must be resized. </td></tr>
    <tr><td class="paramname">thread_id</td><td>is a unique identifier of the thread associated with this model call, useful in multi-threaded context e.g., to assign a GPU accelerator to the current call.</td></tr>
  </table>
  </dd>
</dl>
<p>The call to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a> will control the maximum number of inputs in a single model call, the total number of threads, and whether <b>y</b> will have the correct size and/or contain an initial guess. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga868eb3d17df0eefb438376c92002b8de" name="ga868eb3d17df0eefb438376c92002b8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga868eb3d17df0eefb438376c92002b8de">&#9670;&#160;</a></span>constructSurrogate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::constructSurrogate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_parallel_jobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_samples_per_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#gac709fc494353223f300235750f8b96ed">TypeRefinement</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>checkpoint_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse grid surrogate to the model defined by the lambda. </p>
<p>Creates a two way feedback between the model and the grid, samples from the model are collected and loaded into the grid, while algorithms from the grid propose new samples according to estimated importance. The procedure is carried out until either tolerance is reached, the budget is exhausted, or no more samples satisfy the level limits. If set to parallel mode, the lambda will be called in separate threads concurrently up to the specified maximum number.</p>
<p>Two notable options are the ability to call the model with batches of samples and the ability to assign an initial guess for each sample.</p><ul>
<li>In some cases, model evaluations can be performed much more efficiently using batches of samples, e.g., by allowing the usage of BLAS level 3 methods (as opposed to level 2), better occupancy on GPU accelerators, or better memory cohesion in sparse linear algebra. For more details, see the work by:<br  />
E. Phipps, M. D'Elia, H. Edwards, M. Hoemmen, J. Hu, <a href="https://epubs.siam.org/doi/abs/10.1137/15M1044679" style="font-weight:bold">Embedded Ensemble Propagation for Improving Performance, Portability, and Scalability of Uncertainty Quantification on Emerging Computational Architectures</a>, SIAM Journal on Scientific Computing, vol. 39, num. 2, pp. C162&ndash;C193, 2017.<br  />
M. D'Elia, E. Phipps, A. Rushdi, M. Ebeida, <a href="https://arxiv.org/abs/1705.02003" style="font-weight:bold">Surrogate-based Ensemble Grouping Strategies for Embedded Sampling-based Uncertainty Quantification</a>, arXiv:1705.02003.</li>
<li>Some models can utilize (or even require) a good initial guess to perform a simulation, e.g., when using linear or non-linear iterative solvers. As the sparse grid surrogate becomes closer and closer to the model, increasingly better guess can be computes, effectively relying on the model to solve only for the correction between the current sparse grid approximation and the actual model. For more details and examples see the work of:<br  />
D. Galindo, P. Jantsch, C. G. Webster, and G. Zhang, <a href="https://doi.org/10.1137/15M1019568" style="font-weight:bold">Accelerating Stochastic Collocation Methods for Partial Differential Equations with Random Input Data</a>, SIAM/ASA Journal on Uncertainty Quantification, vol. 4, num. 1, pp. 1111&ndash;1137, 2016.</li>
</ul>
<p>The template can be instantiated in either parallel or single threaded mode, with or without an initial guess feedback, and sampling can be performed in batches or single point. The rest of the parameters control the computational budget and the specifics of the refinement scheme.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_construction</td><td>defines the use of parallel or sequential mode. The variable is of type <b>bool</b> but the constexpr constants <a class="el" href="group__TasmanianAddonsConstruct.html#ga3c8066806409c50730ab7c7843643912" title="Allows for expressive calls to TasGrid::constructSurrogate().">TasGrid::mode_parallel</a> and <a class="el" href="group__TasmanianAddonsConstruct.html#gab3bad3a625ef67b3daacad075f9ef730" title="Allows for expressive calls to TasGrid::constructSurrogate().">TasGrid::mode_sequential</a> can be used to for more expressive calls. </td></tr>
    <tr><td class="paramname">initial_guess</td><td>defines the state of the output vector <b>y</b> when the model is called. If the initial guess is set to <b>true</b> (or <a class="el" href="group__TasmanianAddonsConstruct.html#ga59a05cea9ff38590c1c81e3c05a06dc2" title="Allows for expressive calls to TasGrid::constructSurrogate().">TasGrid::with_initial_guess</a>), then the input will be filled with the best guess for <b>y</b> based on the current grid, i.e., the previously computed samples. This mode is useful when the model can benefit from a good initial guess, e.g., when using an iterative solver. If the model cannot use an initial guess, then use <b>false</b> or <a class="el" href="group__TasmanianAddonsConstruct.html#gae24a8f8d52cd2c6fb54f6f21c4389a7f" title="Allows for expressive calls to TasGrid::constructSurrogate().">TasGrid::no_initial_guess</a> to avoid extraneous calls to <b>grid.evaluateBatch()</b>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>defines the input-output relation to be approximated by the surrogate.<ul>
<li>Entering each call, <b>x</b> will have size equal to an even multiple of the dimension of the gird and will hold the required sample inputs for a set of points; the number of points is controlled by <b>max_samples_per_job</b>.</li>
<li>Exiting the call, <b>y</b> must have size equal to the number of samples time the number of outputs and must be loaded the outputs corresponding to <b>x</b>. If running with <b>initial_guess</b>, on entry, <b>y</b> will be either loaded with the best guess based on the previously computed samples or empty which will indicate that there are not enough samples to make even a coarse grid. If running without <b>initial_guess</b>, the vector will always have the correct size, but the values will be unspecified and should be overwritten.</li>
<li>If using the parallel mode, <b>thread_id</b> will be a number between 0 and <b>max_num_samples</b> <b>-1</b>, all threads running simultaneously will be given a different thread id. </li>
</ul>
</td></tr>
    <tr><td class="paramname">max_num_points</td><td>defines the computational budget for the surrogate construction. The construction procedure will terminate after the grid has reached the maximum number of points. </td></tr>
    <tr><td class="paramname">num_parallel_jobs</td><td>defined the maximum number of concurent thread executing different calls to the <b>model</b>. In sequential mode, i.e., when <b>parallel_construction</b> is <b>false</b>, this number will loosely control the frequency of recalculating the list of candidate "most important" samples. If set to 0, it will be used as if set to 1. </td></tr>
    <tr><td class="paramname">max_samples_per_job</td><td>defines the largest number of samples per call to <b>model</b>. In some cases, outputs can be more efficiently computed when the samples are lumped together. If the model evaluations are not oprimized for batching then this can be simply set to one. If set to 0, it will be used as if set to 1. </td></tr>
    <tr><td class="paramname">grid</td><td>is the resulting surrogate model. The grid must be initialized with the appropriate type, number of dimensions, number of outputs, and sufficiently large number of initial points (e.g., there are enough candidates to load all threads). This template works with local polynomial grids. </td></tr>
    <tr><td class="paramname">tolerance</td><td>defines the target tolerance, identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">TasmanianSparseGrid::setSurplusRefinement()</a>. </td></tr>
    <tr><td class="paramname">criteria</td><td>defines the refinement algorithm, identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">TasmanianSparseGrid::setSurplusRefinement()</a>. </td></tr>
    <tr><td class="paramname">output</td><td>defines the output to use in the algorithm, identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">TasmanianSparseGrid::setSurplusRefinement()</a>. </td></tr>
    <tr><td class="paramname">level_limits</td><td>defines the maximum level to use in each direction, identical to <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a555ded26e1a839b210eb21ac7b488d37" title="Refine the grid based on the surplus coefficients, Sequence grids and Global grids with a sequence ru...">TasmanianSparseGrid::setSurplusRefinement()</a>. If level limits are already set in the construction and/or refinement those weights will be used, this parameter can overwrite them. </td></tr>
    <tr><td class="paramname">checkpoint_filename</td><td>defines the two filenames to be used in to store the intermediate constructed grids so that the procedure can be restarted in case of a system crash. If the filename is "foo" then the files will be called "foo" and "foo_old". No intermediate saves will be made if the string is empty. If the string is not empty, the procedure will first attempt to recover from "foo" and "foo_old".</td></tr>
  </table>
  </dd>
</dl>
<p><b>WARNING:</b> if the checkpoint files contain data from an older runs, the files must be deleted to avoid recovering from the old executing.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if called for a grid that is not local polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Constructing a surrogate to a simple exponential function with budget of 100 points and running on 4 threads with one sample per thread: <div class="fragment"><div class="line"><span class="keyword">auto</span> grid = <a class="code hl_function" href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a>(2, ..); <span class="comment">// sync the dimensions with number of model inputs</span></div>
<div class="line"><a class="code hl_function" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de">TasGrid::constructSurrogate</a>([&amp;](std::vector&lt;double&gt; <span class="keyword">const</span> &amp;x, std::vector&lt;double&gt; &amp;y)</div>
<div class="line">                            -&gt;<span class="keywordtype">void</span>{ y[0] = std::exp(x[0] + x[1]); },</div>
<div class="line">                            100, 4, 1, grid, 1.E-6, <a class="code hl_enumvalue" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd">TasGrid::refine_classic</a>);</div>
<div class="ttc" id="agroup__SGEnumerates_html_ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd"><div class="ttname"><a href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd">TasGrid::refine_classic</a></div><div class="ttdeci">@ refine_classic</div><div class="ttdoc">Isotropic refinement using only the children and disregarding missing parents.</div><div class="ttdef"><b>Definition</b> tsgEnumerates.hpp:427</div></div>
<div class="ttc" id="agroup__TasmanianAddonsConstruct_html_ga868eb3d17df0eefb438376c92002b8de"><div class="ttname"><a href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de">TasGrid::constructSurrogate</a></div><div class="ttdeci">void constructSurrogate(ModelSignature model, size_t max_num_points, size_t num_parallel_jobs, size_t max_samples_per_job, TasmanianSparseGrid &amp;grid, double tolerance, TypeRefinement criteria, int output=-1, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;(), std::string const &amp;checkpoint_filename=std::string())</div><div class="ttdoc">Construct a sparse grid surrogate to the model defined by the lambda.</div><div class="ttdef"><b>Definition</b> tsgConstructSurrogate.hpp:464</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_gaaa84e44ca8145727564dbb57e7c939a3"><div class="ttname"><a href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeLocalPolynomialGrid(int dimensions, int outputs, int depth, int order=1, TypeOneDRule rule=rule_localp, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeLocalPolynomialGrid().</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:2316</div></div>
</div><!-- fragment --> The procedure will terminate after 100 samples or after the tolerance of 1.E-6 has been reached.</dd></dl>
<dl class="section user"><dt>Checkpoint Restart</dt><dd>Large scale simulations that take long time to complete, run a significant risk of system failure which can waste significant computing resources. Checkpoint-restart is a technique to periodically save the computed result and, in case of a crash, restart from the last saved point. For example, suppose the following call crashes mid-way: <div class="fragment"><div class="line"><span class="comment">// original call</span></div>
<div class="line"><a class="code hl_class" href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a> grid = <a class="code hl_function" href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a>(...);</div>
<div class="line"><a class="code hl_function" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de">constructSurrogate</a>(model, budget, num_parallel, grid, 1.E-6, <a class="code hl_enumvalue" href="group__SGEnumerates.html#ggac709fc494353223f300235750f8b96eda7f94ba19af9490c0dc8b8cb2778a82fd">TasGrid::refine_classic</a>, -1,</div>
<div class="line">                   std::vector&lt;int&gt;(), std::vector&lt;double&gt;(), <span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="ttc" id="aclassTasGrid_1_1TasmanianSparseGrid_html"><div class="ttname"><a href="classTasGrid_1_1TasmanianSparseGrid.html">TasGrid::TasmanianSparseGrid</a></div><div class="ttdoc">The master-class that represents an instance of a Tasmanian sparse grid.</div><div class="ttdef"><b>Definition</b> TasmanianSparseGrid.hpp:293</div></div>
</div><!-- fragment --> After the crash, Tasmanian will attempt to recover the computed samples from files "foo" and "foo_old", if the files don't exist or do not contain valid recovery data, the procedure will restart from scratch. However, if the files were saved successfully the procedure will restart mid-way and samples will not have to be recomputed. </dd></dl>

</div>
</div>
<a id="gac0788f48fb2593d686d3b2173f5821f0" name="gac0788f48fb2593d686d3b2173f5821f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0788f48fb2593d686d3b2173f5821f0">&#9670;&#160;</a></span>constructSurrogate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::constructSurrogate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_parallel_jobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_samples_per_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>anisotropic_weights</em> = <code>std::vector&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>checkpoint_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse grid surrogate to the model defined by the lambda. </p>
<p>Uses the user provided <b>anisotropic_weights</b> to order the samples by importance and calles the anisotropic overload of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">TasmanianSparseGrid::getCandidateConstructionPoints()</a>. Otherwise the function is identical to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>.</p>
<p><b>WARNING:</b> anisotropic refinement does not target a tolerance, thus sampling will continue until the budget is exhausted or the level limits are reached (which will produce a full tensor grid). </p>

</div>
</div>
<a id="ga4ed57c25a9f903ce06604091bd1fe500" name="ga4ed57c25a9f903ce06604091bd1fe500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ed57c25a9f903ce06604091bd1fe500">&#9670;&#160;</a></span>constructSurrogate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_construction = TasGrid::mode_parallel, bool initial_guess = no_initial_guess&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::constructSurrogate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TasmanianAddonsConstruct.html#ga18daa9a18e54407f6dfd5909274de6c9">ModelSignature</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_parallel_jobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_samples_per_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html">TasmanianSparseGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga94134756077eff395566c64e6426455f">TypeDepth</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>level_limits</em> = <code>std::vector&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>checkpoint_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse grid surrogate to the model defined by the lambda. </p>
<p>Uses anisotropic weights to order the samples by importance, starts with a fully isotropic grid until enough points are loaded to allow to estimate the weights. The procedure uses the anisotropic overload of <a class="el" href="classTasGrid_1_1TasmanianSparseGrid.html#a7121e196e2f8e7bd5a1cc6a698231789" title="Generate a sorted list of points weighted by descending importance.">TasmanianSparseGrid::getCandidateConstructionPoints()</a>, otherwise the function is identical to <a class="el" href="group__TasmanianAddonsConstruct.html#ga868eb3d17df0eefb438376c92002b8de" title="Construct a sparse grid surrogate to the model defined by the lambda.">TasGrid::constructSurrogate()</a>.</p>
<p><b>WARNING:</b> anisotropic refinement does not target a tolerance, thus sampling will continue until the budget is exhausted or the level limits are reached (which will produce a full tensor grid). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div> -->
</body>
</html>
