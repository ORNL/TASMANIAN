<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1: Tasmanian Optimization module, example 1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                Doxygen
                </a> 1.9.1
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v8.1
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TasmanianOPTExamples1.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tasmanian Optimization module, example 1<div class="ingroups"><a class="el" href="group__TasmanianOPTExamples.html">Examples for the Tasmanian Optimization module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Tasmanian Optimization module, example 1:</div>
<div class="dyncontent">
<div class="center"><img src="group__TasmanianOPTExamples1.png" border="0" usemap="#agroup____TasmanianOPTExamples1" alt=""/></div>
<map name="agroup____TasmanianOPTExamples1" id="agroup____TasmanianOPTExamples1">
<area shape="rect" href="group__TasmanianOPTExamples.html" title=" " alt="" coords="5,5,193,45"/>
<area shape="rect" title=" " alt="" coords="241,5,404,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa0dc5702f9087ce6dfbc63c5fc0bb1cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianOPTExamples1.html#gaa0dc5702f9087ce6dfbc63c5fc0bb1cb">optimizaiton_example_01</a> ()</td></tr>
<tr class="memdesc:gaa0dc5702f9087ce6dfbc63c5fc0bb1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization Example 1: Demonstrates the use of the Particle Swarm method.  <a href="group__TasmanianOPTExamples1.html#gaa0dc5702f9087ce6dfbc63c5fc0bb1cb">More...</a><br /></td></tr>
<tr class="separator:gaa0dc5702f9087ce6dfbc63c5fc0bb1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Example 1: Particle Swarm method </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa0dc5702f9087ce6dfbc63c5fc0bb1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0dc5702f9087ce6dfbc63c5fc0bb1cb">&#9670;&nbsp;</a></span>optimizaiton_example_01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optimizaiton_example_01 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimization Example 1: Demonstrates the use of the Particle Swarm method. </p>
<p>Find the minimum of the six-hump camel function <img class="formulaInl" alt="$ f(x,y) = ( 4 - 2.1 x^2 + x^4 / 3) x^2 + x y + ( - 4 + 4 y^2) y^2 $" src="form_69.png" width="392" height="21"/> the problem is challenging due to the multiple relative and global extrema. Classic gradient based methods often stagnate and fail when applied to this benchmark problem. In contrast, the Particle Swarm method uses multiple "particles" that move around the domain in search for an optimal position. The "swarm" shares global information and is fairly insensitive to local extrema. The algorithm shares many similarities with the DREAM sampling procedure and is a good fit for the Tasmanian framework. While the method is probabilistic, identifying a correct global minimum comes with a high probability of success. </p><div class="fragment"><div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    <span class="comment">// using the default random engine, but must reset the random number generator</span></div>
<div class="line">    std::srand(std::time(<span class="keyword">nullptr</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Example 1:</span></div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;---------------------------------------------------------------------------------------------------\n&quot;</span>;</div>
<div class="line">    cout &lt;&lt; std::scientific; cout.precision(5);</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;EXAMPLE 1: use the Particle Swarm algorithm to minimize the six-hump camel function\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           f(x,y) = (4-2.1 *x^2 + x^4 / 3) * x^2 + x * y + (-4 + 4 * y^2) * y^2\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           domain is x in (-3, +3), y in (-2, +2)\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;           using 50 particles and 200 iterations\n&quot;</span></div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot;    See the comments in example_optimization_01.cpp\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;the problem has two solutions at (-8.98420e-02, 7.12656e-01) and (8.98420e-02, -7.12656e-01)\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;the objective at the solutions is -1.03163.\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">     <span class="keywordtype">int</span> num_dimensions = 2;</div>
<div class="line">     <span class="keywordtype">int</span> num_particles = 50;</div>
<div class="line"> </div>
<div class="line">     <a class="code" href="classTasOptimization_1_1ParticleSwarmState.html">TasOptimization::ParticleSwarmState</a> state(num_dimensions, num_particles);</div>
<div class="line">     state.initializeParticlesInsideBox({-3.0, -2.0}, {3.0, 2.0});</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">auto</span> objective = <a class="code" href="group__OptimizationUtil.html#ga9c5629ee6b0c4786a1c477e305068743">TasOptimization::makeObjectiveFunction</a>(</div>
<div class="line">                    num_dimensions,</div>
<div class="line">                    [](<span class="keyword">const</span> std::vector&lt;double&gt; &amp;x)-&gt;<span class="keywordtype">double</span> {</div>
<div class="line">                         <span class="keywordflow">return</span> (4.0 - 2.1 * x[0]*x[0] + x[0]*x[0]*x[0]*x[0] / 3.0) * x[0]*x[0] +</div>
<div class="line">                              x[0] * x[1] +</div>
<div class="line">                              (-4.0 + 4.0 * x[1]*x[1]) * x[1]*x[1];</div>
<div class="line">                    });</div>
<div class="line"> </div>
<div class="line">     <span class="keywordtype">int</span> num_iterations = 200;</div>
<div class="line">     <span class="keywordtype">double</span> inertia_weight = 0.5, cognitive_coeff = 2.0, social_coeff = 2.0;</div>
<div class="line">     <a class="code" href="group__OptimizationAlgorithm.html#ga917f7b894daf3c63805a196264bc1e08">TasOptimization::ParticleSwarm</a>(objective,</div>
<div class="line">                                    <a class="code" href="group__DREAMSampleCore.html#ga51ca0fa1e74342db600bb9186fdd8158">TasDREAM::hypercube</a>({-3.0, -2.0}, {3.0, 2.0}),</div>
<div class="line">                                    inertia_weight, cognitive_coeff, social_coeff,</div>
<div class="line">                                    num_iterations, state);</div>
<div class="line"> </div>
<div class="line">     std::vector&lt;double&gt; best_position = state.getBestPosition();</div>
<div class="line">     std::vector&lt;double&gt; best_objective(1);</div>
<div class="line">     objective(best_position, best_objective);</div>
<div class="line"> </div>
<div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;Using the objective function\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;found best position after 200 iteration:\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;best value for x = &quot;</span> &lt;&lt; best_position[0] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;best value for y = &quot;</span> &lt;&lt; best_position[1] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;value of the objective = &quot;</span> &lt;&lt; best_objective[0] &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">     <span class="comment">// solve the same optimization problem, but use a sparse grid surrogate</span></div>
<div class="line">     <span class="comment">// first we create the surrogate, then we optimize</span></div>
<div class="line"> </div>
<div class="line">     <span class="keyword">auto</span> grid = <a class="code" href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a>(2, 1, 10);</div>
<div class="line">     grid.setDomainTransform({-3.0, -2.0}, {3.0, 2.0});</div>
<div class="line"> </div>
<div class="line">     std::vector&lt;double&gt; points = grid.getNeededPoints();</div>
<div class="line">     std::vector&lt;double&gt; values(grid.getNumNeeded());</div>
<div class="line">     objective(points, values);</div>
<div class="line">     grid.loadNeededValues(values); <span class="comment">// at this point, we have the surrogate</span></div>
<div class="line"> </div>
<div class="line">     <span class="comment">// reset the state</span></div>
<div class="line">     state = <a class="code" href="classTasOptimization_1_1ParticleSwarmState.html">TasOptimization::ParticleSwarmState</a>(num_dimensions, num_particles);</div>
<div class="line">     state.initializeParticlesInsideBox({-3.0, -2.0}, {3.0, 2.0});</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// the values of the objective function for all particle positions are computed in batch</span></div>
<div class="line">     <span class="comment">// thus, the problem is amenable to GPU acceleration</span></div>
<div class="line">     <span class="comment">// Note: if GPU acceleration is not available, Tasmanian will automatically fallback to CPU</span></div>
<div class="line">     grid.enableAcceleration(<a class="code" href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622">TasGrid::accel_gpu_cuda</a>);</div>
<div class="line">     <a class="code" href="group__OptimizationAlgorithm.html#ga917f7b894daf3c63805a196264bc1e08">TasOptimization::ParticleSwarm</a>(</div>
<div class="line">                              [&amp;](std::vector&lt;double&gt; <span class="keyword">const</span> &amp;x, std::vector&lt;double&gt; &amp;y)-&gt;<span class="keywordtype">void</span>{</div>
<div class="line">                                   grid.evaluateBatch(x, y);</div>
<div class="line">                              },</div>
<div class="line">                              <a class="code" href="group__DREAMSampleCore.html#ga51ca0fa1e74342db600bb9186fdd8158">TasDREAM::hypercube</a>({-3.0, -2.0}, {3.0, 2.0}),</div>
<div class="line">                              inertia_weight, cognitive_coeff, social_coeff,</div>
<div class="line">                              num_iterations, state);</div>
<div class="line"> </div>
<div class="line">     best_position = state.getBestPosition();</div>
<div class="line">     objective(best_position, best_objective);</div>
<div class="line"> </div>
<div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;Using the surrogate to the objective function\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;found best position after 200 iteration:\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;best value for x = &quot;</span> &lt;&lt; best_position[0] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;best value for y = &quot;</span> &lt;&lt; best_position[1] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;value of the objective = &quot;</span> &lt;&lt; best_objective[0] &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;Note: the method will find only one of the minimums\n&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;      the random seed will determine which one.\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;---------------------------------------------------------------------------------------------------\n&quot;</span>;</div>
<div class="line"><span class="preprocessor">#ifndef __TASMANIAN_DOXYGEN_SKIP</span></div>
<div class="ttc" id="aclassTasOptimization_1_1ParticleSwarmState_html"><div class="ttname"><a href="classTasOptimization_1_1ParticleSwarmState.html">TasOptimization::ParticleSwarmState</a></div><div class="ttdoc">Stores the information about a particle swarm.</div><div class="ttdef"><b>Definition:</b> tsgParticleSwarm.hpp:114</div></div>
<div class="ttc" id="agroup__DREAMSampleCore_html_ga51ca0fa1e74342db600bb9186fdd8158"><div class="ttname"><a href="group__DREAMSampleCore.html#ga51ca0fa1e74342db600bb9186fdd8158">TasDREAM::hypercube</a></div><div class="ttdeci">DreamDomain hypercube(std::vector&lt; double &gt; const &amp;lower, std::vector&lt; double &gt; const &amp;upper)</div><div class="ttdoc">Make a lambda that matches the inside signature in SampleDREAM(), test if the vector x is in the hype...</div><div class="ttdef"><b>Definition:</b> tsgDreamSample.hpp:75</div></div>
<div class="ttc" id="agroup__OptimizationAlgorithm_html_ga917f7b894daf3c63805a196264bc1e08"><div class="ttname"><a href="group__OptimizationAlgorithm.html#ga917f7b894daf3c63805a196264bc1e08">TasOptimization::ParticleSwarm</a></div><div class="ttdeci">void ParticleSwarm(const ObjectiveFunction f, const TasDREAM::DreamDomain inside, const double inertia_weight, const double cognitive_coeff, const double social_coeff, const int num_iterations, ParticleSwarmState &amp;state, const std::function&lt; double(void)&gt; get_random01=TasDREAM::tsgCoreUniform01)</div><div class="ttdoc">Applies the classic particle swarm algorithm to a particle swarm state.</div></div>
<div class="ttc" id="agroup__OptimizationUtil_html_ga9c5629ee6b0c4786a1c477e305068743"><div class="ttname"><a href="group__OptimizationUtil.html#ga9c5629ee6b0c4786a1c477e305068743">TasOptimization::makeObjectiveFunction</a></div><div class="ttdeci">ObjectiveFunction makeObjectiveFunction(const int num_dimensions, const ObjectiveFunctionSingle f_single)</div><div class="ttdoc">Creates a TasOptimization::ObjectiveFunction object from a TasOptimization::ObjectiveFunctionSingle o...</div><div class="ttdef"><b>Definition:</b> tsgOptimizationUtils.hpp:133</div></div>
<div class="ttc" id="agroup__SGEnumerates_html_gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622"><div class="ttname"><a href="group__SGEnumerates.html#gga344ee5be5b77f2ff8e7c98f97ab40581ace1389a7f0e1b7b9313038ea65396622">TasGrid::accel_gpu_cuda</a></div><div class="ttdeci">@ accel_gpu_cuda</div><div class="ttdoc">Similar to the cuBLAS option but also uses a set of Tasmanian custom GPU kernels.</div><div class="ttdef"><b>Definition:</b> tsgEnumerates.hpp:561</div></div>
<div class="ttc" id="agroup__TasmanianSG_html_gaaa84e44ca8145727564dbb57e7c939a3"><div class="ttname"><a href="group__TasmanianSG.html#gaaa84e44ca8145727564dbb57e7c939a3">TasGrid::makeLocalPolynomialGrid</a></div><div class="ttdeci">TasmanianSparseGrid makeLocalPolynomialGrid(int dimensions, int outputs, int depth, int order=1, TypeOneDRule rule=rule_localp, std::vector&lt; int &gt; const &amp;level_limits=std::vector&lt; int &gt;())</div><div class="ttdoc">Factory method, creates a new grid and calls TasmanianSparseGrid::makeLocalPolynomialGrid().</div><div class="ttdef"><b>Definition:</b> TasmanianSparseGrid.hpp:2301</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div> -->
</body>
</html>
