# A collection of structures and functions for general sparse grids.
module TasGrid

include("TasUtil.jl")
using .TasUtil

export Rule1D, GlobalGrid
export generate_weight_cache, generate_quad_surplus_cache
export get_points, get_quadrature_weights

struct Rule1D
    #=
    Container for a 1D interpolation rule.
    =#

    # Indicator for if the rule generates nested points.
    nested::Bool
    # Function that returns the number of nodes for a given level.
    num_nodes::Function
    # Function that returns the points and weights in a pair (points, weights)
    # for a given level. Indices for points and weights should align!
    points_and_weights::Function

    # Constructors
    Rule1D() = new(false, l->0, l->([],[]))
    Rule1D(n::Bool, nn::Function, pw::Function) = new(n, nn, pw)
end

struct GlobalGrid
    #=
    Metadata for a general global sparse grid. Contains only the necessary
    information for generating the points and/or weights of the grid.
    =#

    # The dimension of the grid.
    num_dims::Int
    # The i-th entry is the 1D interpolation rule for the i-th dimension. 
    rule1D_vec::Vector{Rule1D}
    # The lower set for filtering the possible levels of for the rules. Each
    # column represents a particular multi-index.
    lower_set::Array{Int, 2}

    # Constructors.
    GlobalGrid() = new(0, Bool[], Function[], zeros(Int, 0, 0))
    function GlobalGrid(r1d::Vector{Rule1D}, ls::Array{Int, 2})
        if (length(r1d) != size(ls, 1))
            error("The number of 1D rules is not equal to the number of " *
                  "multi-indexes in the given lower set!")
        else
            new(length(r1d), r1d, ls)
        end
    end
end

function generate_weight_cache(grid::GlobalGrid)
    # Generate a cache of weight vectors for every dimension and every possible
    # degree up to the maximum degree that appears in grid.lower_set. In
    # particular, weight_cache[k][l] contains the weights for dimension k
    # at level l generated by grid.rule1D_vec[k](l).
    max_degrees, _ = findmax(grid.lower_set, dims=2)
    weight_cache = Vector{Vector{Vector{Float64}}}(undef, grid.num_dims)
    for k=1:grid.num_dims
        weight_cache[k] = Vector{Float64}[]
        for l=1:max_degrees[k]
            _, wk = grid.rule1D_vec[k].points_and_weights(l)
            push!(weight_cache[k], wk)
        end
    end
    return weight_cache
end

function generate_quad_surplus_cache(grid::GlobalGrid)
    # For over every multi-index in grid.lower_set, create a cache of
    # quadrature surplus weights. In particular, quad_surplus_cache[j][k] contains
    # the nonzero weights for the operator
    #
    #   Î”(l) := R(l) - R(l-1)
    #
    # where l = grid.lower_set[k,j] and R(l) is corresponds to the 1D rule in
    # grid.rule1D_vec[k](l).
    num_dims = grid.num_dims
    num_entries = size(grid.lower_set, 2)
    weight_cache = generate_weight_cache(grid)
    quad_surplus_cache = Vector{Vector{Vector{Float64}}}(undef, num_entries)
    for j=1:num_entries
        quad_surplus_cache[j] = Vector{Float64}[]
        for k=1:num_dims
            if grid.rule1D_vec[k].nested
                l = grid.lower_set[k, j]
                wl = weight_cache[k][l]
                wl_m1 = (l >= 2) ? weight_cache[k][l-1] : zeros(Float64, 0)
                push!(quad_surplus_cache[j],
                      wl - [wl_m1; zeros(Float64, length(wl) - length(wl_m1))])
            else
                # TODO Implement the non-nested case.
                error("Only nested rules are supported!")
            end
        end
    end
    return quad_surplus_cache

end

# NOTE: The ordering of get_points() should coincide with the ordering of
#       get_weights().

function get_points(grid::GlobalGrid)
    # Outputs the points of a global grid using a cache of 1D points. Only
    # covers the nested case right now.
    max_degrees, _ = findmax(grid.lower_set, dims=2)
    point_cache = Vector{Vector{Float64}}(undef, grid.num_dims)
    for k=1:grid.num_dims
        if grid.rule1D_vec[k].nested
            point_cache[k], _ =
                grid.rule1D_vec[k].points_and_weights(max_degrees[k])
        else
            # TODO Implement the non-nested case.
            error("Only nested rules are supported!")
        end
    end
    return cartesian_product(point_cache)
end

function get_quadrature_weights(grid::GlobalGrid)
    # Outputs the quadrature weights of a global grid. Only covers the nested
    # case right now.

    # Compute the number of points in each dimension based on the lower set
    # and rules for each dimension.
    num_points = Vector{Int}(undef, grid.num_dims)
    max_degrees, _ = findmax(grid.lower_set, dims=2)
    for k=1:grid.num_dims
        if grid.rule1D_vec[k].nested
            num_points[k] = grid.rule1D_vec[k].num_nodes(max_degrees[k])
        else
            # TODO Implement the non-nested case.
            error("Only nested rules are supported!")
        end
    end

    # Collapse all of the tensors over the indices in the lower set.
    qs_cache = generate_quad_surplus_cache(grid)
    quad_weights = zeros(Float64, prod(num_points))
    num_entries = size(grid.lower_set, 2)
    for j=1:num_entries
        # Take a full Cartesian product with added zero weights and
        # collapse the tensor product by multiplying the weights at a
        # particular grid point.
        for k=1:grid.num_dims
            fill_length = num_points[k] - length(qs_cache[j][k])
            qs_cache[j][k] = [qs_cache[j][k]; zeros(Float64, fill_length)]
        end
        cprod_qsk = cartesian_product(qs_cache[j])
        # This line aggregates all of the collapsed tensors in the allocated
        # quadrature weight vector.
        quad_weights += map(prod, cprod_qsk)
    end
    return(quad_weights)
end


end # module
