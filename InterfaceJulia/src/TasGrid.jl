# A collection of structures and functions for general sparse grids.

include("TasData.jl")
include("TasUtil.jl")
include("TasOneDimesionalRule.jl")

struct GlobalGrid
    #=
    Metadata for a general global sparse grid. Contains only the necessary
    information for generating the points and/or weights of the grid.
    =#

    # The dimension of the grid.
    num_dims::Int
    # The 1D interpolation rule for the grid.
    rule::Rule1D
    # The lower set for filtering the possible levels of for the rules. Each
    # column represents a particular multi-index.
    lower_set::Matrix{Int}
    # The set of point multi-indices, sorted lexicographically.
    index_set::Matrix{Int}

    # Constructors.
    GlobalGrid() = new(0, ClenshawCurtis(), zeros(Int, 0, 0))
    GlobalGrid(r::Rule1D, ls::Matrix{Int}) =
        new(size(ls, 1), r, ls, get_index_set(ls, r))
end

function get_index_set(ls::SubMatrix{Int}, r::Rule1D)
    # Generate a lexicographically sorted point set that is the union of the
    # points in the grid. If grid.rule.nested is true, then the expansion from
    # a tensor (in the lower set) is done using the index surplus, i.e.,
    # the points considered in level l have indexes m(l-1),...,m(l)-1.
    num_dims, num_entries = size(ls)
    if num_entries == 0
        return Matrix{Int}(undef, num_dims, 0)
    elseif num_entries == 1
        if r.nested
            # All possible combinations are populated if *ls* is a lower set.
            pts_1D = Vector{Vector{Int}}(undef, num_dims)
            for k=1:num_dims
                l = ls[k, 1]
                low_idx = (l == 1 ? 1 : r.num_nodes(l-1) + 1)
                high_idx = r.num_nodes(l)
                pts_1D[k] = collect(low_idx:high_idx)
            end
            return cartesian_product(pts_1D)
        else
            # TODO Implement the non-nested case.
            error("Only nested rules are supported!")
        end
    else
        mid_idx = num_entries ÷ 2
        left = view(ls, :, 1:mid_idx)
        right = view(ls, :, (mid_idx+1):num_entries)
        return lex_merge_matrices(get_index_set(left, r),
                                  get_index_set(right, r))
    end
end

function get_point_cache(grid::GlobalGrid)
    # Generate a cache of point vectors for the the levels in grid.lower_set.
    # If the rule is nested, only return the points for the largest level.
    if grid.rule.nested
        max_degree, _ = findmax(grid.lower_set)
        point_cache, _ = grid.rule.points_and_weights(max_degree)
    else
        # TODO Implement the non-nested case.
        error("Only nested rules are supported!")
    end
    return point_cache
end

function get_points(grid::GlobalGrid)
    # Returns the points of a grid that are generated by the global rule of
    # the grid.
    if grid.rule.nested
        pc = get_point_cache(grid)
        num_dims, num_entries = size(grid.index_set)
        points = Matrix{Float64}(undef, num_dims, num_entries)
        for k=1:num_dims
            for j=1:num_entries
                points[k, j] = pc[grid.index_set[k, j]]
            end
        end
    else
        # TODO Implement the non-nested case.
        error("Only nested rules are supported!")
    end
    return points
end

function get_quad_weight_cache(grid::GlobalGrid)
    # Generate a cache of quadrature weight vectors for all levels up to the
    # largest one l_max in grid.lower_set. In particular, weight_cache[l]
    # contains the weights of level l.
    max_degree, _ = findmax(grid.lower_set)
    weight_cache = Vector{Vector{Float64}}(undef, max_degree)
    for l=1:max_degree
        _, weight_cache[l] = grid.rule.points_and_weights(l)
    end
    return weight_cache
end

function get_quad_weights(grid::GlobalGrid)
    # Generate the quadrature weights that are generated by the global rule
    # of the grid. The ordering of these weights should coincide with
    # grid.index_set.
    if grid.rule.nested
        qwc = get_quad_weight_cache(grid)
        num_dims, num_entries = size(grid.lower_set)
        max_degree, _ = findmax(grid.lower_set)
        num_nodes = map(grid.rule.num_nodes, collect(1:max_degree))
        quad_weights = zeros(Float64, size(grid.index_set, 2))
        for j=1:num_entries
            # Expand the j-th tensor in the lower set into a set of points.
            l = Vector{Int}(undef, num_dims)
            pts_1D = Vector{Vector{Int}}(undef, num_dims)
            for k=1:num_dims
                l[k] = grid.lower_set[k, j]
                high_idx = grid.rule.num_nodes(l[k])
                pts_1D[k] = collect(1:high_idx)
            end
            point_set = cartesian_product(pts_1D)
            # Compute the surplus weights corresponding to the surplus, operator
            #   Δₗ := Rₗ - Rₗ₋₁
            # at the resolution of the point set, where R depends on the grid
            # rule. Then, add these weights to the relevant index in
            # quad_weights, which should align with grid.index_set.
            for p=1:size(point_set, 2)
                surplus_weight = 1
                for k=1:num_dims
                    lk = l[k]
                    pk = point_set[k, p]
                    cur_level_weight = qwc[lk][pk]
                    # If the level is 1, use the fact the weights for level 0
                    # are just zero everywhere.
                    if lk == 1
                        prev_level_weight = 0.0
                    else
                        prev_level_weight =
                            pk > num_nodes[lk-1] ? 0.0 : qwc[lk-1][pk]
                    end
                    surplus_weight *= cur_level_weight - prev_level_weight
                end
                quad_weight_idx = lex_find_idx(grid.index_set, point_set[:, p])
                quad_weights[quad_weight_idx] += surplus_weight
            end
        end
    else
        # TODO Implement the non-nested case.
        error("Only nested rules are supported!")
    end
    return quad_weights
end


