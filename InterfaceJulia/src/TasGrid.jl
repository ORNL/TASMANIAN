# A collection of structures and functions for general sparse grids.

include("TasData.jl")
include("TasUtil.jl")
include("TasOneDimesionalRule.jl")

struct GlobalGrid
    #=
    Metadata for a general global sparse grid. Contains only the necessary
    information for generating the points and/or weights of the grid.
    =#

    # The dimension of the grid.
    num_dims::Int
    # The i-th entry is the 1D interpolation rule for the i-th dimension.
    rule1D_vec::Vector{Rule1D}
    # The lower set for filtering the possible levels of for the rules. Each
    # column represents a particular multi-index.
    lower_set::Array{Int, 2}

    # Constructors.
    GlobalGrid() = new(0, Bool[], Function[], zeros(Int, 0, 0))
    function GlobalGrid(r1d::Vector{Rule1D}, ls::Array{Int, 2})
        if (length(r1d) != size(ls, 1))
            error("The number of 1D rules is not equal to the number of " *
                  "multi-indexes in the given lower set!")
        else
            new(length(r1d), r1d, ls)
        end
    end
end

function generate_point_and_quad_weight_cache(grid::GlobalGrid)
    # Generate a cache of weight vectors for every dimension and every possible
    # degree up to the maximum degree that appears in grid.lower_set. In
    # particular, weight_cache[k][l] contains the weights for dimension k
    # at level l generated by grid.rule1D_vec[k](l). The same indexing is
    # done for the points.
    max_degrees, _ = findmax(grid.lower_set, dims=2)
    point_cache = Vector{Vector{Vector{Float64}}}(undef, grid.num_dims)
    weight_cache = Vector{Vector{Vector{Float64}}}(undef, grid.num_dims)
    for k=1:grid.num_dims
        point_cache[k] = Vector{Float64}[]
        weight_cache[k] = Vector{Float64}[]
        for l=1:max_degrees[k]
            pk, wk = grid.rule1D_vec[k].points_and_weights(l)
            push!(weight_cache[k], wk)
            push!(point_cache[k], pk)
        end
    end
    return point_cache, weight_cache
end


function generate_quad_surplus_cache(grid::GlobalGrid)
    # For over every multi-index in grid.lower_set, create a cache of
    # quadrature surplus weights. In particular, quad_surplus_cache[j][k]
    # contains the nonzero weights for the operator
    #
    #   Î”(l) := R(l) - R(l-1)
    #
    # where l = grid.lower_set[k,j] and R(l) is corresponds to the 1D rule in
    # grid.rule1D_vec[k](l).
    num_dims = grid.num_dims
    num_entries = size(grid.lower_set, 2)
    _, weight_cache = generate_point_and_quad_weight_cache(grid)
    quad_surplus_cache = Vector{Vector{Vector{Float64}}}(undef, num_entries)
    for j=1:num_entries
        quad_surplus_cache[j] = Vector{Float64}[]
        for k=1:num_dims
            if grid.rule1D_vec[k].nested
                l = grid.lower_set[k, j]
                wl = weight_cache[k][l]
                wl_m1 = (l >= 2) ? weight_cache[k][l-1] : zeros(Float64, 0)
                push!(quad_surplus_cache[j],
                      wl - [wl_m1; zeros(Float64, length(wl) - length(wl_m1))])
            else
                # TODO Implement the non-nested case.
                error("Only nested rules are supported!")
            end
        end
    end
    return quad_surplus_cache
end


function get_points_and_quadrature_weights(grid::GlobalGrid)
    # Outputs the points and quadrature weights of a global grid. Both outputs
    # should be arranged in the same order.

    # Start by caching the nested points and weights.
    point_cache, _ = generate_point_and_quad_weight_cache(grid)
    quad_surplus_cache = generate_quad_surplus_cache(grid)

    # Generate the points and weights simultaneously using the lower set.
    XTheta = Matrix{Int}(undef, grid.num_dims, 0)
    points = Matrix{Float64}(undef, grid.num_dims, 0)
    weights = Matrix{Float64}(undef, 1, 0)
    for i=1:size(grid.lower_set, 2)
        ei_set = Vector{Vector{Int64}}(undef, grid.num_dims)
        ep_set = Vector{Vector{Float64}}(undef, grid.num_dims)
        eqw_set = Vector{Vector{Float64}}(undef, grid.num_dims)
        for k=1:grid.num_dims
            l = grid.lower_set[k,i]
            n_kl = grid.rule1D_vec[k].num_nodes(l)
            ei_set[k] = collect(1:n_kl)
            ep_set[k] = point_cache[k][l]
            eqw_set[k] = quad_surplus_cache[i][k]
        end
        prod_ei_set = cartesian_product(ei_set)
        prod_ep_set = cartesian_product(ep_set)
        prod_eqw_set = cartesian_product(eqw_set)
        agg_prod_eqw_set = reshape(map(prod, eachcol(prod_eqw_set)),
                                   1, size(prod_eqw_set, 2))
        points, _ = lex_merge_2d_arrays(
            points, prod_ep_set, XTheta, prod_ei_set, max)
        weights, XTheta = lex_merge_2d_arrays(
            weights, agg_prod_eqw_set, XTheta, prod_ei_set, +)
    end
    quadrature_weights = map(prod, eachcol(weights))
    return points, quadrature_weights
end

