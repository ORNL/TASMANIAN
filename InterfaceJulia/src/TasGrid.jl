# A collection of structures and functions for general sparse grids.

include("TasData.jl")
include("TasUtil.jl")
include("TasOneDimesionalRule.jl")

struct GlobalGrid
    #=
    Metadata for a general global sparse grid. Contains only the necessary
    information for generating the points and/or weights of the grid.
    =#

    # The dimension of the grid.
    num_dims::Int
    # The 1D interpolation rule for the grid.
    rule::Rule1D
    # The lower set for filtering the possible levels of for the rules. Each
    # column represents a particular multi-index.
    lower_set::Array{Int, 2}

    # Constructors.
    GlobalGrid() = new(0, Bool[], Function[], zeros(Int, 0, 0))
    GlobalGrid(r::Rule1D, ls::Array{Int, 2}) = new(size(ls, 1), r, ls)
end


function generate_point_and_quad_weight_cache(grid::GlobalGrid)
    # Generate a cache of weight vectors for every dimension and every possible
    # degree up to the maximum degree that appears in grid.lower_set. In
    # particular, weight_cache[k][l] contains the weights for dimension k
    # at level l generated by grid.rule(l). The same indexing is
    # done for the points.
    max_degrees, _ = findmax(grid.lower_set, dims=2)
    point_cache = Vector{Vector{Vector{Float64}}}(undef, grid.num_dims)
    weight_cache = Vector{Vector{Vector{Float64}}}(undef, grid.num_dims)
    for k=1:grid.num_dims
        point_cache[k] = Vector{Float64}[]
        weight_cache[k] = Vector{Float64}[]
        for l=1:max_degrees[k]
            pk, wk = grid.rule.points_and_weights(l)
            push!(weight_cache[k], wk)
            push!(point_cache[k], pk)
        end
    end
    return point_cache, weight_cache
end


function generate_quad_surplus_cache(grid::GlobalGrid)
    # For over every multi-index in grid.lower_set, create a cache of
    # quadrature surplus weights. In particular, quad_surplus_cache[j][k]
    # contains the nonzero weights for the operator
    #
    #   Î”(l) := R(l) - R(l-1)
    #
    # where l = grid.lower_set[k,j] and R(l) is corresponds to the 1D rule in
    # grid.rule(l).
    num_dims = grid.num_dims
    num_entries = size(grid.lower_set, 2)
    _, weight_cache = generate_point_and_quad_weight_cache(grid)
    quad_surplus_cache = Vector{Vector{Vector{Float64}}}(undef, num_entries)
    for j=1:num_entries
        quad_surplus_cache[j] = Vector{Float64}[]
        for k=1:num_dims
            if grid.rule.nested
                l = grid.lower_set[k, j]
                wl = weight_cache[k][l]
                wl_m1 = (l >= 2) ? weight_cache[k][l-1] : zeros(Float64, 0)
                push!(quad_surplus_cache[j],
                      wl - [wl_m1; zeros(Float64, length(wl) - length(wl_m1))])
            else
                # TODO Implement the non-nested case.
                error("Only nested rules are supported!")
            end
        end
    end
    return quad_surplus_cache
end


function get_points_and_quadrature_weights(grid::GlobalGrid)
    # Outputs the points and quadrature weights of a global grid. Both outputs
    # should be arranged in the same order.

    # Start by caching the nested points and weights.
    point_cache, _ = generate_point_and_quad_weight_cache(grid)
    quad_surplus_cache = generate_quad_surplus_cache(grid)

    # Generate the points and weights simultaneously using the lower set.
    XTheta = Matrix{Int}(undef, grid.num_dims, 0)
    points = Matrix{Float64}(undef, grid.num_dims, 0)
    weights = Matrix{Float64}(undef, 1, 0)
    for i=1:size(grid.lower_set, 2)
        ei_set = Vector{Vector{Int64}}(undef, grid.num_dims)
        ep_set = Vector{Vector{Float64}}(undef, grid.num_dims)
        eqw_set = Vector{Vector{Float64}}(undef, grid.num_dims)
        for k=1:grid.num_dims
            l = grid.lower_set[k,i]
            n_kl = grid.rule.num_nodes(l)
            ei_set[k] = collect(1:n_kl)
            ep_set[k] = point_cache[k][l]
            eqw_set[k] = quad_surplus_cache[i][k]
        end
        prod_ei_set = cartesian_product(ei_set)
        prod_ep_set = cartesian_product(ep_set)
        prod_eqw_set = cartesian_product(eqw_set)
        agg_prod_eqw_set = reshape(map(prod, eachcol(prod_eqw_set)),
                                   1, size(prod_eqw_set, 2))
        points, _ = lex_merge_2d_arrays(
            points, prod_ep_set, XTheta, prod_ei_set, max)
        weights, XTheta = lex_merge_2d_arrays(
            weights, agg_prod_eqw_set, XTheta, prod_ei_set, +)
    end
    quadrature_weights = map(prod, eachcol(weights))
    return points, quadrature_weights
end

# ==============================================================================
# Work In Progress (WIP)
# ==============================================================================

function get_point_cache(grid::GlobalGrid)
    # Generate a cache of point vectors for the the levels in grid.lower_set.
    # If the rule is nested, only return the points for the largest level.
    if grid.rule.nested
        max_degree, _ = findmax(grid.lower_set)
        point_cache, _ = grid.rule.points_and_weights(max_degree)
    else
        # TODO Implement the non-nested case.
        error("Only nested rules are supported!")
    end
    return point_cache
end

function get_point_set(grid::GlobalGrid)
    # Generate a lexicographically sorted point set that is the union of the
    # points in the grid. If grid.rule.nested is true, then the expansion from
    # a tensor (in the lower set) is done using the index surplus, i.e.,
    # the points considered in level l have indexes m(l-1),...,m(l)-1.
    point_set = Matrix{Int}(undef, grid.num_dims, 0)
    comp_idx = Vector{Vector{Int}}(undef, grid.num_dims)
    for j=1:size(grid.lower_set, 2)
        for k=1:grid.num_dims
        end
    end
end

function get_quad_weight_cache(grid::GlobalGrid)
    # Generate a cache of quadrature weight vectors for all levels up to the
    # largest one l_max in grid.lower_set. In particular, weight_cache[l].
    max_degree, _ = findmax(grid.lower_set)
    weight_cache = Vector{Vector{Float64}}(undef, max_degree)
    for l=1:max_degree
        _, weight_cache[l] = grid.rule.points_and_weights(l)
    end
    return weight_cache
end
