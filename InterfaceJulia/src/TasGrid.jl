# A collection of structures and functions for general sparse grids.

module TasGrid

export GlobalGrid, generate_weight_cache, generate_surplus_cache

struct GlobalGrid
    #=
    Metadata for a general global sparse grid. Contains only the necessary
    information for generating the points and/or weights of the grid.
    =#

    # The dimension of the grid.
    num_dims::Int
    # The i-th entry is true if the i-th 1D rule produces nested points.
    is_nested_vec::Vector{Bool}
    # The i-th entry is the 1D rule for the i-th dimension. Each rule function
    # should return a (points, weights) tuple.
    rule1D_vec::Vector{<:Function}
    # The lower set for filtering the possible levels of for the rules. Each
    # column represents a particular multi-index.
    lower_set::Array{Int, 2}

    # Constructors.
    GlobalGrid() = new(0, Bool[], Function[], zeros(Int, 0, 0))
    function GlobalGrid(is::Vector{Bool},
                        r1d::Vector{<:Function},
                        ls::Array{Int, 2})
        if (length(is) != length(r1d))
            error("The lengths of the first two arguments are not equal!")
        elseif (length(r1d) != size(ls, 1))
            error("The number of rows of the third argument is not equal to " *
                  "the lengths of the first two arguments!")
        else
            new(length(is), is, r1d, ls)
        end
    end
end

function generate_weight_cache(grid::GlobalGrid)
    # Generate a cache of weight vectors for every dimension and every possible
    # degree up to the maximum degree that appears in grid.lower_set. In
    # particular, weight_cache[k][l] contains the weights for dimension k
    # at level l generated by grid.rule1D_vec[k](l).
    max_degrees, _ = findmax(grid.lower_set, dims=2)
    weight_cache = Vector{Vector{Vector{Float64}}}(undef, grid.num_dims)
    for k=1:grid.num_dims
        weight_cache[k] = Vector{Float64}[]
        for l=1:max_degrees[k]
            _, wk = grid.rule1D_vec[k](l)
            push!(weight_cache[k], wk)
        end
    end
    return weight_cache
end

function generate_surplus_cache(grid::GlobalGrid)
    # For over every multi-index in grid.lower_set, create a cache of
    # surplus weights. In particular, surplus_cache[k][j] contains the nonzero
    # weights for the operator
    #
    #   Î”(l) := U(l) - U(l-1)
    #
    # where l = grid.lower_set[k,j] and U(l) is corresponds to the 1D rule in
    # grid.rule1D_vec[k](l).
    num_dims = grid.num_dims
    num_entries = size(grid.lower_set, 2)
    weight_cache = generate_weight_cache(grid)
    surplus_cache = Vector{Vector{Vector{Float64}}}(undef, num_dims)
    for k=1:num_dims
        surplus_cache[k] = Vector{Float64}[]
        # Safety check.
        if !grid.is_nested_vec[k] error("Only nested rules are supported!") end
        for j=1:num_entries
            l = grid.lower_set[k, j]
            wl = weight_cache[k][l]
            wl_m1 = (l >= 2) ? weight_cache[k][l-1] : zeros(Float64, 0)
            push!(surplus_cache[k],
                  wl - [wl_m1; zeros(Float64, length(wl) - length(wl_m1))])
        end
    end
    return surplus_cache

end

function get_points_and_weights(grid::GlobalGrid)
    # Outputs the points and weights of a global grid.

    # TODO: Implement the non-nested version. Only grids where all dimensions
    #       have a nested rule are allowed right now.

end

end # module
